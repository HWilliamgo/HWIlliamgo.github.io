局部变量（在方法或函数中声名的变量）：
1. 自动存储期限：当方法返回后，将自动回收局部变量的内存地址。
2. 程序块作用域：局部变量的作用域是从方法的开始到方法的结束。

现实是：对传入的参数进行修改，如果不return的话是拿不到修改后的参数的，也就是对参数的修改是没有意义的。

代码证明：
```
#include<stdio.h>
void method(int i,int j){
    i=999;
    j=999;
}
int main() {
    //声名两个变量并赋值。
    int i=100;
    int j=1;
    //调用method方法并为i和j赋上新的值
    method(i,j);
    //打印i和j的值
    printf("%d\n%d",i,j);
    return 0;
}
```
打印：
```
100
1
```
上述代码声名了两个int并赋值，随后在方法中给他们传递新的值，打印结果显示，跳出了方法之后，赋上的新的值丢失了。

---
**为什么会这样**
###进入正题
下列代码列出了变量进入方法后内存地址的改变情况：
```
#include<stdio.h>
void method(int i,int j){
    //打印传入的参数i和j的内存地址。
    printf("传入方法后i和j的内存地址：%p  %p",&i,&j);
}
int main() {
    //声名两个变量并赋值。
    int i=100;
    int j=1;
    //打印i和j的指针（即内存地址），&就是取址。
    printf("i和j的内存地址：          %p  %p\n",&i,&j);
    //调用method方法。
    method(i,j);
    return 0;
}
```
打印（前方高能）：
```
i和j的内存地址：          0061FF2C  0061FF28
传入方法后i和j的内存地址：0061FF10  0061FF14
```
**惊呆了有木有！**
进入方法之后的参数，直接在方法中新申请了一个内存地址来保存传入的参数。
```
//也就是
void method(int a,int b){
}
//实际上在方法内部进行了
void method(int a,int b){
  int a=a;
  int b=b;
}
//即重新申请了新的变量，因此才有了不同的内存地址！
```

##结论：结论即标题，方法中传入的参数有新的内存地址，这就是为什么对参数的修改在跳出方法之后不会影响原本的变量。
---

