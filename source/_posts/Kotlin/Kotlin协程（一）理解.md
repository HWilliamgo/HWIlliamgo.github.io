> 最近这段时间抽空学习了一下Kotlin协程相关的知识，在此做一个总结和梳理



## 是什么

#### kotlin协程是什么

一个名为` kotlinx.coroutines `包下的库， 是由 JetBrains 开发的功能丰富的协程库，方便大家利用协程来完成异步处理的开发。



#### 当我们创建协程（Coroutine）时，我们创建的是什么？

一种类似于`java.lang.Runnable`，但比`Runnable`功能要强大的多的对象。

```kotlin
//launch函数是CoroutineScope的拓展函数，即launch{}函数需要该对象才能使用，以下代码不能直接使用
launch(Dispatchers.IO) {
    //这段代码块就是协程
}
```

上述代码创建了一个协程，并把该协程指定在`Dispatchers.IO`，意思是把这段协程代码发送到kotlin提供的用于执行io类任务的线程池中。

那么这个协程指的是什么？是一种类似于`java.lang.Runnable`的东西。`Runnable`是运行在某个线程中的代码块，协程本质上也是运行在某个线程中的代码块。

相似点在于：

1. 当一个线程在执行一个`Runnable`任务的时候，这个线程不能同时执行另一个`Runnable`。相似的，线程在某个时刻，只能运行一个协程任务，不可能一个线程同时运行多个协程任务。

2. 我们在使用传统的线程池的时候，线程池内部他自己会构建若干个工作线程，当你调用`submit(Runnable)`方法的时候，你是将你的代码块发送到线程池中，让线程池内部自己分配工作线程去接住传入线程池的`Runnable()`对象。

   协程是一样的，当你创建并启动一个协程，你必须直接（或者通过上下文来获取）指定一个线程或者线程池，来把你创建的协程代码块发送到对应的线程或线程池中让他们去执行或调度。他本质还是在用线程池去调度你启动的任务。所以传统线程池的执行原理依然不变。

不同点在于：

1. 协程有挂起，而java线程池配合`Runnable`不具备这个功能（除非你自己手动实现）。协程挂起是什么？用`Runnable`的角度来理解就是：线程执行某个`Runnable`到一半，把`Runnable`移出了当前的线程执行上下文，那么当前的`Runnable`中执行的代码就暂时停止了，而原先的线程则腾出来可以运行别的Runnable去了，而`Runnable`（协程）中暂停的代码什么时候恢复继续？当协程从挂起恢复的时候，当挂起恢复时，协程又被线程捡起运行了。
2. 协程相比起`Runnable`，有丰富的属性和方法，来让协程方便地开始，取消，在不同的线程之间跳转（单个Runnable无法在不同的线程间跳转，要实现线程切换，就得根据上个Runnable的回调再建一个Runnable并发射到要跳转的线程），等等。



## 为什么

#### 为什么要学协程？

1. 一些开源项目，甚至谷歌自己的示例代码中的异步任务，用上了协程，不学看不懂。



#### 为什么要用协程？

1. 协程能带来比传统回调更简洁的异步处理代码，能用更短的代码实现相同的功能。代码越简洁，越不容易乱，越不容易出错，可读性越强。
2. 这是一种新的编程思想和编写异步代码的风格，且是kotlin官方发布的，连google的开源项目也在用，这是一种趋势。



## 怎么样

#### 怎么学？

[官方教程]( https://www.kotlincn.net/docs/reference/coroutines/basics.html )

[coroutine的github地址]( https://github.com/Kotlin/kotlinx.coroutines )（包含API文档，视频介绍，如何依赖，等等）

更新中...

#### 怎么用？

更新中...
