* gc只负责回收堆内存中的对象，不会回收任何物力资源（如数据库连接，网络IO等）。
* 程序无法精确控制gc的运行，gc会在合适的时候进行。当对象永久失去引用后（=null），系统就会在合适的时候回收它所占的内存。
* 在gc回收任何对象之前，总会调用它的finalize方法，该方法可能使对象重新获得引用，导致gc取消回收。

##对象在内存中的状态：
1. 可达状态：对象被创建后，有一个以上的变量引用它，程序可通过引用变量来调用该对象的实例变量和方法。
2. 可恢复状态：程序中某个对象不再有任何变量引用它，它进入可恢复状态，gc准备回收该对象所占的内存，在回收该对象之前，系统会调用所有可恢复状态对象的finalize方法进行资源清理。 如果在finalize方法中对象重新获得引用，这个对象变成可达状态，否则进入不可达状态。
3. 不可达状态：这个对象与所有的引用变量的关联被切断，且系统调用了所有对象的finalize方法后该对象依然没有变成可达状态，该对象就永远地失去引用，变成不可达状态。只有一个对象处于不可达状态是，系统才会真正回收该对象所占有的资源。


##强制垃圾回收：
当对象失去引用后，系统何时调用finalize方法，何时变成不可达状态，何时被gc回收，程序都无法控制，程序只能控制一个对象何时不再被变量引用。
但是可以通过：
* System.gc();
* Runtim.getRuntime().gc();
来通知系统进行垃圾回收，系统是否进行垃圾回收不确定。

##finalize()方法
特点：
* 不要主动调用某个对象的finalize方法，这个方法是gc调用的。
* finalize方法的调用具有不确定性，不要把它当作一定会被执行的方法。
* 当JVM执行可恢复对象的finalize()方法时，可能时该对象或系统中其他对象重新变成可达状态。
* 当JVM执行fianlize方法出现异常时，gc不会报告异常，程序继续执行。

参考《疯狂java讲义》
