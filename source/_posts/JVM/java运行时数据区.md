读《深入理解Java虚拟机》读书笔记
![image.png](https://upload-images.jianshu.io/upload_images/7177220-356870d534d67272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

### 程序计数器：
* 为了保证程序能够连续地执行下去，处理器必须具有某些手段来确定下一条指令的地址，而程序计数器正是起到这种作用。
* 用来记录当前线程所执行的字节码的行号。字节码解释器的工作就是通过改变程序计数器来选取下一条需要执行的字节码指令（分支，循环，跳转，异常，线程恢复等）。
* JVM的多线程是通过线程轮流切换并分配处理器执行时间来实现的。在一个确定时刻，一个处理器都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确执行位置，每条线程需要一个**独立的程序计数器**，各条线程之间计数器互不影响，独立存储。因此程序计数器的内存区域是**线程私有**的内存。

### Java虚拟机栈：
* 线程私有的，生命周期和线程相同。他描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈桢用于存储局部变量表，操作数栈，动态链接，方法出口等信息。
* 每个方法从调用到执行完成，就对应一个栈桢在虚拟机栈中从入栈到出栈。
* 平时所泛指的内存中的“堆和栈”里的栈指的就是这部分，或者说是虚拟机栈中的局部变量表的部分。
* 局部变量表存放了编译期可知的：基本数据类型，引用数据类型（其实就是对象的内存地址的指针）和returnAddress类型（指向了一条字节码指令的地址）。
* 局部变量表所需的内存空间在编译器完成分配，当进入一个方法时，这个方法需要在桢中分配多大的局部变量控件是确定的。在方法运行期间不会改变局部变量表的大小。
* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；如果虚拟机可以动态扩展，但是扩展时无法申请到足够的内存，抛出OutOfMemoryError。

### 本地方法栈：
* 作用和本地方法栈类似，区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机使用到的Native方法服务。

### Java堆：
* 被所有线程共享的一块内存区域。
* 词内存区的唯一目的：存放所有的对象实例和数组。
* Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError。

### 方法区：
* 各个线程共享的内存区域，用于存储：已被虚拟机加载的**类信息，常量，静态变量，即时编译器编译后的代码**等。
* 垃圾收集行为在该区域比较少出现
* 这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。
* 当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。

### 运行时常量池：
* Class文件中除了类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池。
* 在编译器确定，在类加载后进入方法区的运行时常量池
* 并不一定只有编译器才能产生，运行期也可以将新的常量放入池中，比如String类对象的Intern()方法。
* 当常量池无法申请到内存时会抛出OutOfMemoryError（jdk7之后，常量池从方法区被移动到堆区，调用String#intern方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。）

### 直接内存：
* 不属于虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也会被频繁使用，并且可能报OOM。
* JDK1.4后引入了NIO类：使用Native函数直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块堆内存的引用进行操作。这样能在一些场景中提高性能，因为避免了在JAVA堆和Native堆中来回复制数据。
* 直接内存不会受到Java堆大小的限制，但是会受到本机总内存（RAM等）大小和处理器寻址空间的限制。有时在配置-Xmx时因为忽略了直接内存，导致服务器各个内存区域总和大于物理内存限制，从而导致动态拓展时出现OOM。

