#####通过泛型和反射避免强制类型转换：
下面这个代码是没问题的。
```
Class clazz=Class.forName("java.util.Date");
Date date= (Date) clazz.newInstance();
```
但是这样也没问题，编译器不会报错，但是run肯定会报错。
```
String string= (String) clazz.newInstance();
```
结合泛型反射可以避免强制类型转换，让编译器帮我们检查：
```
@SuppressWarnings(value = "unchecked")
public class MainTest {
    public static void main(String args[]) throws Exception {
        Class<Date> clazz= (Class<Date>) Class.forName("java.util.Date");
        Date date=AFactory.getInstance(clazz);
        String string=AFactory.getInstance(clazz);

    }
}
class AFactory{
    public static<T> T getInstance(Class<T> clazz){
        try {
            return clazz.newInstance();
        }catch (Exception e){
            e.printStackTrace();
            System.out.println("wrong");
            return null;
        }
    }
}
```
![](http://upload-images.jianshu.io/upload_images/7177220-8470a3ad4ada80a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
编译器不允许编译通过。
#####通过反射查看泛型信息。
获取普通的成员变量的信息：
```
public class MainTest {
    public static void main(String args[]) throws Exception {
        Class<Person> clazz=Person.class;
        Field field=clazz.getDeclaredField("name");
        Class<?> a=field.getType();
        System.out.println(a);
    }
}
class Person{
    private String name;
}
```
打印：```class java.lang.String```
按上述方法获取泛型信息：
```
public class MainTest {
    public static void main(String args[]) throws Exception {
        Class<Person> clazz=Person.class;
        Field field=clazz.getDeclaredField("map");
        Class<?> a=field.getType();
        System.out.println(a);
    }
}
class Person{
    private Map<String,Integer> map;
}
```
打印：```java.util.Map```，获取不到泛型String和Interger的信息。

可以如下：
```
public class MainTest {
    public static void main(String args[]) throws Exception {
        Class<Person> clazz=Person.class;
        Field field=clazz.getDeclaredField("map");
        Type type=field.getGenericType();
        System.out.println(type.getTypeName());

        if (type instanceof ParameterizedType){
            ParameterizedType parameterizedType= (ParameterizedType) type;
            Type rType=parameterizedType.getRawType();
            System.out.println("原始类型："+rType);
            Type[] tArgs=parameterizedType.getActualTypeArguments();
            for (int i =0;i<tArgs.length;i++){
                System.out.println("第"+i+"个泛型类型是"+tArgs[i]);
            }
        }else {
            System.out.println("获取泛型类型出错");
        }
    }
}
class Person{
    private Map<Integer,String> map;
}
```
打印：
```
java.util.Map<java.lang.Integer, java.lang.String>
原始类型：interface java.util.Map
第0个泛型类型是class java.lang.Integer
第1个泛型类型是class java.lang.String
```
