**定义**：策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。

**我自己的理解：**一个对象的功能应该由**组合**得来，而非**继承**得来。在此，组合和继承的意思分别是：
* 组合：指的是接口的组合，不同的功能应该对应不同的接口，在父类中声名，由多态来控制灵活性。
* 继承：指的就是由父类固定死的方法继承下来，不具有灵活性。

例子：
比方说我现在创建一个类叫Duck,那么鸭子对象肯定有固定的功能比如：游泳，吃。
```
//固定不变的部分写在父类中继承下去，实现代码复用
protected void swim(){}
protected abstract void display();
```
那么其他功能可能在以后有新的需求或者需求有变的时候，为了更容易维护，让结构更具有弹性，我们把鸭子对象中其他容易变动的代码用接口来组合。比如：
* 鸭子飞：
```
public interface IFlyBehavior {
    void fly();
}
```
* 鸭子叫
```
public interface IQuackBehavior {
    void quack();
}
```

组合到一起：
```
public abstract class Duck {
    //抽象父类鸭子的功能由接口组合而来
    private IFlyBehavior iFlyBehavior;
    private IQuackBehavior iQuackBehavior;

    public void setiFlyBehavior(IFlyBehavior iFlyBehavior) {
        this.iFlyBehavior = iFlyBehavior;
    }

    public void setiQuackBehavior(IQuackBehavior iQuackBehavior) {
        this.iQuackBehavior = iQuackBehavior;
    }

    public void performFly(){
        if (iFlyBehavior!=null){
            iFlyBehavior.fly();
        }
    }
    public void performQuackk(){
        if (iQuackBehavior!=null){
            iQuackBehavior.quack();

        }
    }
    //固定不变的部分写在父类中继承下去，实现代码复用
    protected void swim(){}
    protected abstract void display();
}
```

此时我们把功能用接口抽象，那么抽象的功能的实现类：
```
public class FlyWithRocket implements IFlyBehavior {
    @Override
    public void fly() {
        System.out.println("用火箭飞！");
    }
}
```
```
public class FlyWithWings implements IFlyBehavior{
    @Override
    public void fly() {
        System.out.println("用翅膀飞");
    }
}
```
继承父类Duck，写一个子类：
```
public class ModelDuck extends Duck {
//子类中的功能不是写死的，而是灵活可变的，可以动态地修改的
    @Override
    protected void display() {
        System.out.println("我是一只模型鸭");
    }
}
```
用的时候就这样：
```
public class Main {
    public static void main(String[] args){
        /**
         * 固定的代码部分不变，用继承来做到代码复用。
         * 容易变化的部分的代码用接口和多态来实现。
         * 将容易变化的代码隔离到另一个类去实现。
         *
         * 如果要添加功能，就在父类里面添加接口的引用和对应的set方法。
         * 那么子类就都有了接口并且可以动态地设置实现类。
         * 灵活，具有弹性.
         */
        Duck modelDuck=new ModelDuck();
        modelDuck.setiFlyBehavior(new FlyWithRocket());;
        modelDuck.performFly();
    }
}
```
此为策略模式
一句话总结：为对象或类添加功能时，用接口来组合这些功能，具体的实现类与这个对象或者类分离。

