###线程生命周期
**新建**：`Thread thread=new Thread();`，用new关键字创建一个线程后，构造方法中将当前thread对象加入ThreadGroup，虚拟机为其分配内存。
**就绪**：调用线程实例的`start()`，JVM为其创建方法调用栈和程序计数器，线程何时开始运行取决于JVM里线程调度器的调度。
**阻塞**：如果处于就绪状态的线程获得了CPU,开始执行run方法的线程执行体,则该线程处于运行状态,如果计算机只有一个CPU,那么在任何时刻只有一个线程处于运行状态。当然,在一个多处理器的机器上,将会有多个线程并行执行;当线程数大于处理器数时,依然会存在多个线程在同一个CPU上轮换的现象。当一个线程开始运行后,它不可能一直处于运行状态(除非它的线程执行体足够短,瞬瞬间就执行结束了),线程在运行过程中需要被中断,目的是使其他线程获得执行的机会,线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言,系统会给每个可执行的线程一个小时间段来处
理任务;当该时间段用完后,系统就会剥夺该线程所占用的资源源,让其他线程获得执行的机会。在选择下一个线程时,系统会考虑线程程的优先级。所有现代的桌面和服务器操作系统都采用抢占式调度策略,但一些小型设备如手机则可能采用协作式调度策略,在这样样的系统中,只有当一个线程调用了它的sleep或 yield方法后才会放弃所占用的资源一一也就是必须由该线程主动放弃所占用的资源。
以下情况线程将会进入阻塞：
1. 线程调用sleep()方法主动放弃所占用的处理器资源
2. 线程调用了一个阻塞时IO方法，在该方法返回之前，该线程被阻塞
3. 线程试图获得一个同步监视器（对象），但该同步监视器正在被别的线程所持有。
4. 线程正在等待某个通知（notify）
5. 程序调用了线程的suspend将该线程挂起。容易导致死锁，尽量避免。
6. 线程调用了另一个线程的`join()`，则当前线程被阻塞，直到调用了`join()`的线程执行完成为止。

![](https://upload-images.jianshu.io/upload_images/7177220-1aed22cc2f8fb6b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
**死亡**：
1. run或者call方法执行完成，线程正常结束
2. 线程抛出一个未捕获的Exeption或者Error
3. 直接调用线程的stop方法来结束该线程，容易导致死锁，不推荐使用。

---

### 同步监视器
``` java
synchronized (obj){            
//需要同步的代码
//obj是同步监视器
}
public synchronized void foo(){
//需同步的代码        
//当前对象this是同步监视器
}
```
>《疯狂java讲义》：任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成之后，该线程会释放对该同步监视器的锁定。

我的理解：不同的线程有不同的锁，当一个同步监视器（对象）被一个线程上锁之后，其他调用该方法的线程都无法破解这把独一无二的锁，只能阻塞，等到那条线程对同步监视器解锁后，其他线程才可以进入方法，给同步监视器上锁。

那么死锁是什么概念呢？
**条件**：两个线程实例thread_1,thread_2，两个同步监视器objA, objB。
**开始**：thread_1中调用一个以objA为同步监视器的同步方法fooA，同时thread_2中调用一个以objB为同步监视器的同步方法fooB。下一步,在fooA中，thread_1准备调用以objB为同步监视器的同步方法，同时，在fooB中，thread_2准备调用以objA为同步监视器的同步方法。
**此时开始出问题**：由于objA和objB都被同时作为同步监听器，并且被上锁了，当thread_1想要对objB上锁的时候，发现objB已经被锁上了，并且还没解开，那么thread_1只能阻塞。同时thread_2想要对objA上锁的时候，也发现objA也被锁住了，也只能阻塞。两条线程同时阻塞，并且没有办法解锁，此时成为死锁。
``` java
public class Main {

    public static void main(String args[]){
        A a=new A();
        B b=new B();

        Thread thread_1=new Thread(new Runnable() {
            @Override
            public void run() {
                    a.fooA(b);
            }
        });
        Thread thread_2=new Thread(new Runnable() {
            @Override
            public void run() {
                b.fooB(a);
            }
        });

        thread_1.start();
        thread_2.start();
    }
}

class A{
    public synchronized void fooA(B b){
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        b.last();
    }
    public synchronized void last(){

    }
}
class  B{
    public synchronized void fooB(A a){
        try {
            Thread.sleep(200);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        a.last();
    }
    public synchronized void last(){

    }
}
```
运行之后：
![](https://upload-images.jianshu.io/upload_images/7177220-1b7c5b11281f6d85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
程序一直不能自动结束，需要手动停止，因为死锁导致阻塞。
