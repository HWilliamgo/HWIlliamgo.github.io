<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="https://s1.ax1x.com/2020/03/28/GkotgK.th.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="HWilliamgo">
  <meta name="keywords" content="">
  <title>C语言学习笔记 - William的小星球</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>William的小星球</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://w.wallhaven.cc/full/39/wallhaven-39joqy.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期一, 八月 12日 2019, 9:50 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    5k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      19 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：星期四, 五月 14日 2020, 3:38 下午</p>
            
            <div class="markdown-body">
              <h2 id="1-C的预处理器"><a href="#1-C的预处理器" class="headerlink" title="1. C的预处理器"></a>1. C的预处理器</h2><h3 id="h头文件"><a href="#h头文件" class="headerlink" title=".h头文件"></a>.h头文件</h3><pre><code class="c">//文件名：main.c

#include &lt;stdio.h&gt;
int main(void){
    ...
}</code></pre>
<p><code>#include</code>是C语言的预处理指令，C语言编译器在编译前会对源码进行预处理工作。他的作用就是把所有头文件中的内容，完全copy进入当前的<code>.c</code>文件中。</p>
<p>一般头文件中定义一些常量或者函数，而其函数实现在另一个文件中。那么，编译完成之后，C的连接器就会将这个<code>main.c</code>文件中用到的其他库中的文件给提取出来，一起和当前的<code>main.c</code>文件组合成一个二进制的可执行文件<code>xxx.exe</code>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7177220-a4adc197d23d3697.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p>
<h3 id="defin定义常量"><a href="#defin定义常量" class="headerlink" title="#defin定义常量"></a>#defin定义常量</h3><p>通用格式：<code>#define NAME value</code>（没有=号，结尾没有分号）</p>
<p>在编译程序的时候，程序中所有引用<code>NAME</code>变量的地方都会被替换成<code>value</code>，该过程称为：编译时替换。程序在运行时，所有替换均已完成，这样定义的常量叫做明示常量。</p>
<h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>C99添加了<code>_Bool</code>类型，因为C语言用1表示true，用0表示false，所以<code>_Bool</code>也是一种整数类型。</p>
<p>此外，凡是非0的int类型，都可以表示true，而整数0表示false。示例代码：</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main(void) {
    int a = 3 &gt; 1;
    int b = 3 &lt; 1;
    printf(&quot;%d&quot;, a);
    printf(&quot;\n&quot;);
    printf(&quot;%d&quot;, b);
    printf(&quot;\n&quot;);

    int c = 3;
    if (c) {
        printf(&quot;凡是非0的整数，都视为true&quot;);
    }
    printf(&quot;\n&quot;);
    int d = 0;
    if (!d) {
        printf(&quot;而整数0刚好表示false&quot;);
    }
}

打印：
1
0
凡是非0的整数，都视为true
而整数0刚好表示false</code></pre>
<h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。且char数组中的最后一个元素一定是空字符<code>\0，</code>标志着字符串的结束。</p>
<p>那么如果<code>char stringA[40]</code>的字符串变量<code>stringA</code>，只能放下39个字符。</p>
<p>注意，C语言中声明数组的方式和java不一样，Java中可以用<code>int[] a</code>的方式声明数组变量，而C中一定要用<code>int a[]</code>的方式来声明。</p>
<p>那么单个字符的字符串和字符的区别是什么？</p>
<p>例如<code>‘X’</code>和<code>&quot;X&quot;</code>的区别？区别在于，字符串类型的“X”是用数组来存储的，最后会有一个空字符<code>\0</code>，即会占两个字符的空间。</p>
<h2 id="3-指针"><a href="#3-指针" class="headerlink" title="3. 指针"></a>3. 指针</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><h4 id="取变量的指针：-amp"><a href="#取变量的指针：-amp" class="headerlink" title="取变量的指针：&amp;"></a>取变量的指针：&amp;</h4><p>后面跟一个变量名时，&amp;给出该变量的地址（或指针）。</p>
<p>&amp;取出的地址可以直接赋值给指针，那么就可以这样写：</p>
<pre><code class="c">int value=10;
int *pointerOfValue=&amp;value;</code></pre>
<p>那么变量<code>pointerOfValue</code>就是指向<code>value</code>变量的指针。那么&amp;可以直接理解为取一个变量的指针。</p>
<p>注意，一个变量的指针只能读不能写，因为一个变量的内存地址（指针）是唯一的，你只能读取，你不能写入。</p>
<h4 id="取指针指向的变量："><a href="#取指针指向的变量：" class="headerlink" title="取指针指向的变量：*"></a>取指针指向的变量：*</h4><p>后面跟一个指针变量或者地址时，*给出存储在指针指向地址上的值。</p>
<p>*运算符是直接作用在指针变量上的，返回指针指向的值：</p>
<pre><code class="c">int valueB=*pointerOfValue;</code></pre>
<p>例如这个<code>valueB</code>，此时就等于10。</p>
<p>注意，*运算符可以用来被指针变量用来读值，当然也能用来写入新的值。</p>
<h3 id="3-2-指针变量声明"><a href="#3-2-指针变量声明" class="headerlink" title="3.2 指针变量声明"></a>3.2 指针变量声明</h3><pre><code class="c">//pi变量是指向int类型变量的指针变量。
int *pi;、
//pc变量是指向char类型变量的指针变量。
char *pc;
//同上
float *pf, *pg;</code></pre>
<p>注意：<code>int *pi</code>声明了一个<code>pi</code>变量，他本身的类型不是int类型的，他是指针类型，不是基本数据类型了，只是他这样声明表示指向的int类型的内存地址。例如两个指针不能相乘，但是两个整型可以相乘，而且打印的时候，指针类型的变量也要用<code>%p</code>来转换。</p>
<p>示例：</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main(void) {
    int a = 10;
    int *addressOfA = &amp;a;
    int valueOfA = *addressOfA;
    printf(&quot;%p&quot;, addressOfA);
    printf(&quot;\n&quot;);
    printf(&quot;%d&quot;, valueOfA);
    return 0;
}</code></pre>
<p>打印：</p>
<pre><code>0x7fff0431fba8
10</code></pre><h3 id="3-3-指针实战"><a href="#3-3-指针实战" class="headerlink" title="3.3 指针实战"></a>3.3 指针实战</h3><p>原则：如果一个函数要计算或者处理值，那么就直接传递变量的值；如果一个函数要改变主调函数的变量，那么就传递那个变量的引用。</p>
<p>在面向对象语言如<code>Java</code>或者<code>Kolin</code>中，要在被调函数中改变主调函数的变量，只能通过return语句来实现。而c语言则可以用指针来实现，如下示例：</p>
<pre><code class="c">#include &lt;stdio.h&gt;

void interchange(int *u, int *v);

//u和v都是指针，那么通过*运算符就可以读写所指向的变量实际的值。
void interchange(int *u, int *v) {
    int temp;
    temp = *u;
    *u = *v;
    *v = temp;
}

int main(void) {
    int x = 5, y = 10;
    printf(&quot;原先x=%d ,y=%d&quot;, x, y);
    interchange(&amp;x, &amp;y);
    printf(&quot;\n&quot;);
    printf(&quot;现在x= %d,y=%d&quot;, x, y);
    return 0;
}</code></pre>
<p>打印：</p>
<pre><code>原先x=5 ,y=10
现在x= 10,y=5</code></pre><p>在许多语言中， 地址都归计算机管， 对程序员隐藏。 然而在 C 中， 可以通过&amp;运算符访问地址， 通过*运算符获得地址上的值</p>
<h3 id="3-4-指针和数组"><a href="#3-4-指针和数组" class="headerlink" title="3.4 指针和数组"></a>3.4 指针和数组</h3><h4 id="3-4-1-数组变量就是一个指针变量"><a href="#3-4-1-数组变量就是一个指针变量" class="headerlink" title="3.4.1 数组变量就是一个指针变量"></a>3.4.1 数组变量就是一个指针变量</h4><p>例如：</p>
<pre><code class="c">int intArray[SIZE];</code></pre>
<p>声明了一个<code>SIZE</code>大小的数组变量，而该数组变量<code>intArray</code>实际上是一个指针变量。该指针变量所指向的值是数组的第一个元素的值，即<code>intArray[0]</code>，而<code>intArrya[0]</code>的元素的指针变量就是数组所代表的指针变量。</p>
<p>例如：</p>
<pre><code class="c">//以下语句成立。注：&amp; 表示取变量的指针
intArray=&amp;intArray[0];</code></pre>
<h4 id="3-4-2-指针加1，指针的值递增它所指向的类型的大小。"><a href="#3-4-2-指针加1，指针的值递增它所指向的类型的大小。" class="headerlink" title="3.4.2 指针加1，指针的值递增它所指向的类型的大小。"></a>3.4.2 指针加1，指针的值递增它所指向的类型的大小。</h4><p>例如：</p>
<pre><code class="c">//声明int
int value = 999;
//取999变量的指针
int *pointerOfInt = &amp;value;
//为指针加1
pointerOfInt += 1;
//打印此时指针所代表的值
printf(&quot;----%d&quot;, *pointerOfInt);</code></pre>
<p>输出：<code>----0</code></p>
<p>即，当指针加一的时候，指针会顺延着在内存地址上，增加一个单位的所指向的变量的类型的大小的长度。例如这里是int，那么指针加一的时候，指针就往后移动4个字节的大小。</p>
<p>而数组刚好代表的是一段连续的内存地址，那么当拿到数组第一个元素的指针，又知道了数组的大小，则可以直接使用指针来访问数组了。（得益于数组在内存上是连续的，链表就不行了。）</p>
<p>如下例子演示了如何使用指针来操纵数组，以及如何把数组直接当成一个指针来使用：</p>
<pre><code class="c">#include &lt;stdio.h&gt;

#define SIZE 4

int main()
{
    //声明数组
    int intArray[SIZE];
    //遍历，为每个数组分配变量
    for (int i = 0; i &lt; SIZE; i++)
    {
        intArray[i] = 100 + i;
    }
    //声明指针
    int *pointer;
    //指针指向数组
    pointer = intArray;

    //从指针中取出指向的数组intArray的每个元素
    for (int i = 0; i &lt; SIZE; i++)
    {
        int valueTakeFromPointer = *(pointer + i);
        printf(&quot;value taken from pointer = %d \n&quot;, valueTakeFromPointer);
    }

    printf(&quot;------------------------\n&quot;);

    //同理，由于数组本身就是指针，那么直接操作数组也可以。
    for (int i = 0; i &lt; SIZE; i++)
    {
        int valueTakeFromPointer = *(intArray + i);
        printf(&quot;value taken from pointer = %d \n&quot;, valueTakeFromPointer);
    }
    return 0;
}
</code></pre>
<p>打印：</p>
<pre><code class="c">@&quot;value taken from pointer = 100 \r\n&quot;
@&quot;value taken from pointer = 101 \r\n&quot;
@&quot;value taken from pointer = 102 \r\n&quot;
@&quot;value taken from pointer = 103 \r\n&quot;
@&quot;------------------------\r\n&quot;
@&quot;value taken from pointer = 100 \r\n&quot;
@&quot;value taken from pointer = 101 \r\n&quot;
@&quot;value taken from pointer = 102 \r\n&quot;
@&quot;value taken from pointer = 103 \r\n&quot;</code></pre>
<h4 id="3-4-3-二级指针"><a href="#3-4-3-二级指针" class="headerlink" title="3.4.3 二级指针"></a>3.4.3 二级指针</h4><p>二级指针表示：指向指针的指针</p>
<p>由于指针变量实际上可以表示一个数组，那么指针的指针，实际上可以用来表示指针的数组。</p>
<p>以下内容来自知乎：</p>
<p>在C语言中，二级指针有什么用处？</p>
<ul>
<li><strong>指针的数组</strong>，尤其是指向 struct 的指针的数组，比如</li>
</ul>
<pre><code class="c">typedef struct {...} Record;
typedef struct {
    size_t length;
    Record **records;
} RecordList;</code></pre>
<ul>
<li><strong>指针的引用</strong>，比如拿来改指针变量</li>
<li><strong>值类型的二维数组</strong></li>
</ul>
<blockquote>
<p>作者：Belleve<br>链接：<a href="https://www.zhihu.com/question/19831228/answer/130917500" target="_blank" rel="noopener">https://www.zhihu.com/question/19831228/answer/130917500</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="4-存储类别、链接、和内存管理"><a href="#4-存储类别、链接、和内存管理" class="headerlink" title="4 存储类别、链接、和内存管理"></a>4 存储类别、链接、和内存管理</h2><h3 id="4-1-作用域"><a href="#4-1-作用域" class="headerlink" title="4.1 作用域"></a>4.1 作用域</h3><ol>
<li><p>块作用域</p>
</li>
<li><p>函数作用域</p>
</li>
<li><p>函数原型作用域</p>
</li>
<li><p>文件作用域</p>
<p>文件作用域的变量也叫全局变量，存在于整个程序的运行周期。</p>
<pre><code class="c">#include &lt;stdio.h&gt;

//units变量就是文件作用域的变量。
int units=0;

int main(void){
    ...
}</code></pre>
</li>
</ol>
<h3 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><p>c的变量有三种链接属性：</p>
<ol>
<li><p>外部链接。</p>
<p>可以被外部的文件所使用。</p>
<pre><code class="c">int a=1;
int main(void){

}</code></pre>
</li>
<li><p>内部链接。</p>
<p>只能在当前的文件中使用。</p>
<pre><code class="c">static int a=1;
int main(void){

}</code></pre>
</li>
<li><p>无连接。</p>
<p>块作用域，函数作用域，函数原型作用域的变量，都是无连接的。</p>
</li>
</ol>
<h3 id="4-3-存储期"><a href="#4-3-存储期" class="headerlink" title="4.3 存储期"></a>4.3 存储期</h3><ol>
<li><p>静态存储期</p>
<p>静态存储期的对象在程序执行的期间一直存在。文件作用域的变量具有静态存储期。</p>
</li>
<li><p>线程存储期</p>
<p>线程存储期的对象，从被声明时到线程结束都一直存在。以关键字_Thread_local声明一个对象时，每个线程都将获得该变量的私有备份。</p>
</li>
<li><p>自动存储期</p>
<p>块作用域的变量通常有自动存储期。进入块时为变量分配内存，退出块时释放刚才分配的内存。</p>
<p>一般在方法块中声明的变量都是自动存储期的，但是块作用域变量也能具有静态存储期。例如：</p>
<pre><code class="c">void more(int number){
    int index;
    static int ct=0;
    //...
    return 0;
}</code></pre>
<p>上述代码中，变量ct存储在静态内存中，它从程序被载入到程序结束期间都存在，。但是他的作用域在more()函数中，那么只有执行more的时候，程序才能用ct来访问他所指定的对（但是， 该函数可以给其他函数提供该存储<br>区的地址以便间接访问该对象， 例如通过指针形参或返回值）。</p>
</li>
<li><p>动态分配存储期</p>
</li>
</ol>
<h3 id="4-4-5种存储类"><a href="#4-4-5种存储类" class="headerlink" title="4.4 5种存储类"></a>4.4 5种存储类</h3><p><img src="https://upload-images.jianshu.io/upload_images/7177220-ad48776eedd5fc15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p>
<h3 id="4-5-块作用域的静态变量"><a href="#4-5-块作用域的静态变量" class="headerlink" title="4.5 块作用域的静态变量"></a>4.5 块作用域的静态变量</h3><ol>
<li>静态变量分为两种：①文件类变量：直接定义在文件里面的变，拥有全局声明周期。②用static关键字作前缀的变量，当他定义在文件中时，他是仅该文件可见的全局变量；当他定义在块或者方法里面时，他是当前块中可见的全局变量。</li>
<li>静态变量的初始化在程序被载入内存时已经执行完毕，他们只在编译的时候被初始化一次。（因此在方法中的静态变量之初始化一次，在运行时不会重复初始化的）</li>
</ol>
<h3 id="4-6-外部链接的静态变量"><a href="#4-6-外部链接的静态变量" class="headerlink" title="4.6 外部链接的静态变量"></a>4.6 外部链接的静态变量</h3><p>外部链接的静态变量具有文件作用域、 外部链接和静态存储期</p>
<p>当然， 为了指出该函数使用了外部变量， 可以在函数中用关键字extern再次声明。 如果一个源代码文件使用的外部变量定义在另一个源代码文件中， 则必须用extern在该文件中声明该变量。<br>   printf(“%d”, b);<br>    printf(“\n”);</p>
<pre><code>int c = 3;
if (c) {
    printf(&quot;凡是非0的整数，都视为true&quot;);
}
printf(&quot;\n&quot;);
int d = 0;
if (!d) {
    printf(&quot;而整数0刚好表示false&quot;);
}</code></pre><p>}</p>
<p>打印：<br>1<br>0<br>凡是非0的整数，都视为true<br>而整数0刚好表示false</p>
<pre><code>


### 字符串类型

C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。且char数组中的最后一个元素一定是空字符`\0，`标志着字符串的结束。

那么如果`char stringA[40]`的字符串变量`stringA`，只能放下39个字符。

注意，C语言中声明数组的方式和java不一样，Java中可以用`int[] a`的方式声明数组变量，而C中一定要用`int a[]`的方式来声明。

那么单个字符的字符串和字符的区别是什么？

例如`‘X’`和`&quot;X&quot;`的区别？区别在于，字符串类型的“X”是用数组来存储的，最后会有一个空字符`\0`，即会占两个字符的空间。



## 3. 指针

### 3.1 定义

#### 取变量的指针：&amp;

后面跟一个变量名时，&amp;给出该变量的地址（或指针）。

&amp;取出的地址可以直接赋值给指针，那么就可以这样写：

``` c
int value=10;
int *pointerOfValue=&amp;value;</code></pre><p>那么变量<code>pointerOfValue</code>就是指向<code>value</code>变量的指针。那么&amp;可以直接理解为取一个变量的指针。</p>
<p>注意，一个变量的指针只能读不能写，因为一个变量的内存地址（指针）是唯一的，你只能读取，你不能写入。</p>
<h4 id="取指针指向的变量：-1"><a href="#取指针指向的变量：-1" class="headerlink" title="取指针指向的变量：*"></a>取指针指向的变量：*</h4><p>后面跟一个指针变量或者地址时，*给出存储在指针指向地址上的值。</p>
<p>*运算符是直接作用在指针变量上的，返回指针指向的值：</p>
<pre><code class="c">int valueB=*pointerOfValue;</code></pre>
<p>例如这个<code>valueB</code>，此时就等于10。</p>
<p>注意，*运算符可以用来被指针变量用来读值，当然也能用来写入新的值。</p>
<h3 id="3-2-指针变量声明-1"><a href="#3-2-指针变量声明-1" class="headerlink" title="3.2 指针变量声明"></a>3.2 指针变量声明</h3><pre><code class="c">//pi变量是指向int类型变量的指针变量。
int *pi;、
//pc变量是指向char类型变量的指针变量。
char *pc;
//同上
float *pf, *pg;</code></pre>
<p>注意：<code>int *pi</code>声明了一个<code>pi</code>变量，他本身的类型不是int类型的，他是指针类型，不是基本数据类型了，只是他这样声明表示指向的int类型的内存地址。例如两个指针不能相乘，但是两个整型可以相乘，而且打印的时候，指针类型的变量也要用<code>%p</code>来转换。</p>
<p>示例：</p>
<pre><code class="c">#include &lt;stdio.h&gt;

int main(void) {
    int a = 10;
    int *addressOfA = &amp;a;
    int valueOfA = *addressOfA;
    printf(&quot;%p&quot;, addressOfA);
    printf(&quot;\n&quot;);
    printf(&quot;%d&quot;, valueOfA);
    return 0;
}</code></pre>
<p>打印：</p>
<pre><code>0x7fff0431fba8
10</code></pre><h3 id="3-3-指针实战-1"><a href="#3-3-指针实战-1" class="headerlink" title="3.3 指针实战"></a>3.3 指针实战</h3><p>原则：如果一个函数要计算或者处理值，那么就直接传递变量的值；如果一个函数要改变主调函数的变量，那么就传递那个变量的引用。</p>
<p>在面向对象语言如<code>Java</code>或者<code>Kolin</code>中，要在被调函数中改变主调函数的变量，只能通过return语句来实现。而c语言则可以用指针来实现，如下示例：</p>
<pre><code class="c">#include &lt;stdio.h&gt;

void interchange(int *u, int *v);

//u和v都是指针，那么通过*运算符就可以读写所指向的变量实际的值。
void interchange(int *u, int *v) {
    int temp;
    temp = *u;
    *u = *v;
    *v = temp;
}

int main(void) {
    int x = 5, y = 10;
    printf(&quot;原先x=%d ,y=%d&quot;, x, y);
    interchange(&amp;x, &amp;y);
    printf(&quot;\n&quot;);
    printf(&quot;现在x= %d,y=%d&quot;, x, y);
    return 0;
}</code></pre>
<p>打印：</p>
<pre><code>原先x=5 ,y=10
现在x= 10,y=5</code></pre><p>在许多语言中， 地址都归计算机管， 对程序员隐藏。 然而在 C 中， 可以通过&amp;运算符访问地址， 通过*运算符获得地址上的值</p>
<h3 id="3-4-指针和数组-1"><a href="#3-4-指针和数组-1" class="headerlink" title="3.4 指针和数组"></a>3.4 指针和数组</h3><h4 id="3-4-1-数组变量就是一个指针变量-1"><a href="#3-4-1-数组变量就是一个指针变量-1" class="headerlink" title="3.4.1 数组变量就是一个指针变量"></a>3.4.1 数组变量就是一个指针变量</h4><p>例如：</p>
<pre><code class="c">int intArray[SIZE];</code></pre>
<p>声明了一个<code>SIZE</code>大小的数组变量，而该数组变量<code>intArray</code>实际上是一个指针变量。该指针变量所指向的值是数组的第一个元素的值，即<code>intArray[0]</code>，而<code>intArrya[0]</code>的元素的指针变量就是数组所代表的指针变量。</p>
<p>例如：</p>
<pre><code class="c">//以下语句成立。注：&amp; 表示取变量的指针
intArray=&amp;intArray[0];</code></pre>
<h4 id="3-4-2-指针加1，指针的值递增它所指向的类型的大小。-1"><a href="#3-4-2-指针加1，指针的值递增它所指向的类型的大小。-1" class="headerlink" title="3.4.2 指针加1，指针的值递增它所指向的类型的大小。"></a>3.4.2 指针加1，指针的值递增它所指向的类型的大小。</h4><p>例如：</p>
<pre><code class="c">//声明int
int value = 999;
//取999变量的指针
int *pointerOfInt = &amp;value;
//为指针加1
pointerOfInt += 1;
//打印此时指针所代表的值
printf(&quot;----%d&quot;, *pointerOfInt);</code></pre>
<p>输出：<code>----0</code></p>
<p>即，当指针加一的时候，指针会顺延着在内存地址上，增加一个单位的所指向的变量的类型的大小的长度。例如这里是int，那么指针加一的时候，指针就往后移动4个字节的大小。</p>
<p>而数组刚好代表的是一段连续的内存地址，那么当拿到数组第一个元素的指针，又知道了数组的大小，则可以直接使用指针来访问数组了。（得益于数组在内存上是连续的，链表就不行了。）</p>
<p>如下例子演示了如何使用指针来操纵数组，以及如何把数组直接当成一个指针来使用：</p>
<pre><code class="c">#include &lt;stdio.h&gt;

#define SIZE 4

int main()
{
    //声明数组
    int intArray[SIZE];
    //遍历，为每个数组分配变量
    for (int i = 0; i &lt; SIZE; i++)
    {
        intArray[i] = 100 + i;
    }
    //声明指针
    int *pointer;
    //指针指向数组
    pointer = intArray;

    //从指针中取出指向的数组intArray的每个元素
    for (int i = 0; i &lt; SIZE; i++)
    {
        int valueTakeFromPointer = *(pointer + i);
        printf(&quot;value taken from pointer = %d \n&quot;, valueTakeFromPointer);
    }

    printf(&quot;------------------------\n&quot;);

    //同理，由于数组本身就是指针，那么直接操作数组也可以。
    for (int i = 0; i &lt; SIZE; i++)
    {
        int valueTakeFromPointer = *(intArray + i);
        printf(&quot;value taken from pointer = %d \n&quot;, valueTakeFromPointer);
    }
    return 0;
}
</code></pre>
<p>打印：</p>
<pre><code class="c">@&quot;value taken from pointer = 100 \r\n&quot;
@&quot;value taken from pointer = 101 \r\n&quot;
@&quot;value taken from pointer = 102 \r\n&quot;
@&quot;value taken from pointer = 103 \r\n&quot;
@&quot;------------------------\r\n&quot;
@&quot;value taken from pointer = 100 \r\n&quot;
@&quot;value taken from pointer = 101 \r\n&quot;
@&quot;value taken from pointer = 102 \r\n&quot;
@&quot;value taken from pointer = 103 \r\n&quot;</code></pre>
<h4 id="3-4-3-二级指针-1"><a href="#3-4-3-二级指针-1" class="headerlink" title="3.4.3 二级指针"></a>3.4.3 二级指针</h4><p>二级指针表示：指向指针的指针</p>
<p>由于指针变量实际上可以表示一个数组，那么指针的指针，实际上可以用来表示指针的数组。</p>
<p>以下内容来自知乎：</p>
<p>在C语言中，二级指针有什么用处？</p>
<ul>
<li><strong>指针的数组</strong>，尤其是指向 struct 的指针的数组，比如</li>
</ul>
<pre><code class="c">typedef struct {...} Record;
typedef struct {
    size_t length;
    Record **records;
} RecordList;</code></pre>
<ul>
<li><strong>指针的引用</strong>，比如拿来改指针变量</li>
<li><strong>值类型的二维数组</strong></li>
</ul>
<blockquote>
<p>作者：Belleve<br>链接：<a href="https://www.zhihu.com/question/19831228/answer/130917500" target="_blank" rel="noopener">https://www.zhihu.com/question/19831228/answer/130917500</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h2 id="4-存储类别、链接、和内存管理-1"><a href="#4-存储类别、链接、和内存管理-1" class="headerlink" title="4 存储类别、链接、和内存管理"></a>4 存储类别、链接、和内存管理</h2><h3 id="4-1-作用域-1"><a href="#4-1-作用域-1" class="headerlink" title="4.1 作用域"></a>4.1 作用域</h3><ol>
<li><p>块作用域</p>
</li>
<li><p>函数作用域</p>
</li>
<li><p>函数原型作用域</p>
</li>
<li><p>文件作用域</p>
<p>文件作用域的变量也叫全局变量，存在于整个程序的运行周期。</p>
<pre><code class="c">#include &lt;stdio.h&gt;

//units变量就是文件作用域的变量。
int units=0;

int main(void){
    ...
}</code></pre>
</li>
</ol>
<h3 id="4-2-链接-1"><a href="#4-2-链接-1" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><p>c的变量有三种链接属性：</p>
<ol>
<li><p>外部链接。</p>
<p>可以被外部的文件所使用。</p>
<pre><code class="c">int a=1;
int main(void){

}</code></pre>
</li>
<li><p>内部链接。</p>
<p>只能在当前的文件中使用。</p>
<pre><code class="c">static int a=1;
int main(void){

}</code></pre>
</li>
<li><p>无连接。</p>
<p>块作用域，函数作用域，函数原型作用域的变量，都是无连接的。</p>
</li>
</ol>
<h3 id="4-3-存储期-1"><a href="#4-3-存储期-1" class="headerlink" title="4.3 存储期"></a>4.3 存储期</h3><ol>
<li><p>静态存储期</p>
<p>静态存储期的对象在程序执行的期间一直存在。文件作用域的变量具有静态存储期。</p>
</li>
<li><p>线程存储期</p>
<p>线程存储期的对象，从被声明时到线程结束都一直存在。以关键字_Thread_local声明一个对象时，每个线程都将获得该变量的私有备份。</p>
</li>
<li><p>自动存储期</p>
<p>块作用域的变量通常有自动存储期。进入块时为变量分配内存，退出块时释放刚才分配的内存。</p>
<p>一般在方法块中声明的变量都是自动存储期的，但是块作用域变量也能具有静态存储期。例如：</p>
<pre><code class="c">void more(int number){
    int index;
    static int ct=0;
    //...
    return 0;
}</code></pre>
<p>上述代码中，变量ct存储在静态内�</p>
</li>
</ol>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/C/">C</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2019/08/27/ndk/ndk%EF%BC%9A%E8%BF%98%E7%94%A8%E4%B8%8D%E7%94%A8armeabi/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">ndk：还用不用armeabi</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2019/08/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/IjkPlayer%E7%9A%84-%22dns_cache_clear%22/">
                        <span class="hidden-mobile">IjkPlayer的-"dns_cache_clear"</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  
  <script defer src="https://utteranc.es/client.js"
          repo="HWilliamgo/HWilliamgo.github.io"
          issue-term="pathname"
  
          label="utterances"
    
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


                </div>
              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>





  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "C语言学习笔记&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
