<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="https://s1.ax1x.com/2020/03/28/GkotgK.th.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="HWilliamgo">
  <meta name="keywords" content="">
  <title>RxJava1源码分析 - William的小星球</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>William的小星球</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('https://w.wallhaven.cc/full/39/wallhaven-39joqy.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期日, 一月 26日 2020, 1:08 下午
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    5.9k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      29 分钟
                  </span>
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  <span id="busuanzi_container_page_pv" class="post-meta" style="display: none">
                    <i class="far fa-eye" aria-hidden="true"></i>
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：星期六, 四月 11日 2020, 1:28 下午</p>
            
            <div class="markdown-body">
              <p>我对于RxJava的异常处理和上抛方式有一些不解，而上网查找的文章都是RxJava的一些用于处理异常的操作符，所以只能自己去源码里面找答案了。</p>
<p>虽然RxJava1已经过时了，但是鉴于RxJava1的源码会比RxJava2的简洁一些，因此易于分析。所以我在这里对RxJava1的源码进行分析。</p>
<h3 id="1-构造Observable"><a href="#1-构造Observable" class="headerlink" title="1 构造Observable"></a>1 构造Observable</h3><h4 id="1-1-create方式"><a href="#1-1-create方式" class="headerlink" title="1.1 create方式"></a>1.1 create方式</h4><pre><code class="java">Observable.create&lt;String&gt; { it: Subscriber&lt;in String&gt; -&gt;
    //上游发射数据
    it.onNext(&quot;123&quot;)
    it.onCompleted()
}.subscribe { it: String -&gt;
    //下游处理数据
    LogUtils.d(it)
}</code></pre>
<p>这里看两个方法：create和subscribe</p>
<h5 id="1-1-1-create"><a href="#1-1-1-create" class="headerlink" title="1.1.1 create"></a>1.1.1 create</h5><p>create方法需要<code>OnSubscribe</code>接口作为参数，然后再返回一个<code>Observable</code>类型的对象（这个对象待会再调用<code>subscribe()</code>方法启动数据的发射）。</p>
<pre><code class="java">public final static &lt;T&gt; Observable&lt;T&gt; create(OnSubscribe&lt;T&gt; f) {
    return new Observable&lt;T&gt;(hook.onCreate(f));
}</code></pre>
<p>那么首先看：<code>hook.onCreate(f)</code>，根据注释，这是一个有<strong>装饰者模式</strong>味道的的钩子方法。</p>
<pre><code class="java">public abstract class RxJavaObservableExecutionHook {
     /**
     * Invoked during the construction by {@link Observable#create(OnSubscribe)}
     * &lt;p&gt;
     * This can be used to decorate or replace the &lt;code&gt;onSubscribe&lt;/code&gt; function or just perform extra
     * logging, metrics and other such things and pass-thru the function.
     * 
     * @param f
     *            original {@link OnSubscribe}&lt;{@code T}&gt; to be executed
     * @return {@link OnSubscribe}&lt;{@code T}&gt; function that can be modified, decorated, replaced or just
     *         returned as a pass-thru
     */
    public &lt;T&gt; OnSubscribe&lt;T&gt; onCreate(OnSubscribe&lt;T&gt; f) {
        return f;
    }
}</code></pre>
<p>默认情况下，传进来什么就返回什么，即没有加任何的装饰的逻辑。</p>
<p>Observable的构造函数：将<code>OnSubscribe</code>保存了起来。</p>
<pre><code class="java">public class Observable&lt;T&gt; {
    final OnSubscribe&lt;T&gt; onSubscribe;

    /**
     * Creates an Observable with a Function to execute when it is subscribed to.
     * &lt;p&gt;
     * &lt;em&gt;Note:&lt;/em&gt; Use {@link #create(OnSubscribe)} to create an Observable, instead of this constructor,
     * unless you specifically have a need for inheritance.
     * 
     * @param f
     *            {@link OnSubscribe} to be executed when {@link #subscribe(Subscriber)} is called
     */
    protected Observable(OnSubscribe&lt;T&gt; f) {
        this.onSubscribe = f;
    }
}</code></pre>
<h5 id="1-1-2-subscribe"><a href="#1-1-2-subscribe" class="headerlink" title="1.1.2 subscribe"></a>1.1.2 subscribe</h5><pre><code class="java">public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) {
    if (onNext == null) {
        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);
    }
    //构造一个Subscriber，衔接onNext的方法，并调用subscribe方法返回Subscription
    return subscribe(new Subscriber&lt;T&gt;() {
        @Override
        public final void onCompleted() {
            // do nothing
        }
        @Override
        public final void onError(Throwable e) {
            throw new OnErrorNotImplementedException(e);
        }
        @Override
        public final void onNext(T args) {
            onNext.call(args);
        }
    });
}</code></pre>
<p>返回的是<code>Subscription</code>，和RxJava2中的<code>Disposable</code>是一个东西：用来取消订阅</p>
<pre><code class="java">public interface Subscription {
    void unsubscribe();
    boolean isUnsubscribed();
}</code></pre>
<p>接着看</p>
<pre><code class="java">public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) {
    //调用了静态方法：
    return Observable.subscribe(subscriber, this);
}</code></pre>
<pre><code class="java">private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {
     // validate and proceed
    if (subscriber == null) {
        throw new IllegalArgumentException(&quot;observer can not be null&quot;);
    }
    if (observable.onSubscribe == null) {
        throw new IllegalStateException(&quot;onSubscribe function can not be null.&quot;);
        /*
         * the subscribe function can also be overridden but generally that&#39;s not the appropriate approach
         * so I won&#39;t mention that in the exception
         */
    }

    // new Subscriber so onStart it
    subscriber.onStart();

    /*
     * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on &quot;Guideline 6.4: Protect calls
     * to user code from within an Observer&quot;
     */
    // if not already wrapped
    if (!(subscriber instanceof SafeSubscriber)) {
        // assign to `observer` so we return the protected version
        subscriber = new SafeSubscriber&lt;T&gt;(subscriber);
    }
    // The code below is exactly the same an unsafeSubscribe but not used because it would add a sigificent depth to alreay huge call stacks.
    try {
        // allow the hook to intercept and/or decorate
        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);
        return hook.onSubscribeReturn(subscriber);
    } catch (Throwable e) {
        // special handling for certain Throwable/Error/Exception types
        Exceptions.throwIfFatal(e);
        // if an unhandled error occurs executing the onSubscribe we will propagate it
        try {
            subscriber.onError(hook.onSubscribeError(e));
        } catch (OnErrorNotImplementedException e2) {
            // special handling when onError is not implemented ... we just rethrow
            throw e2;
        } catch (Throwable e2) {
            // if this happens it means the onError itself failed (perhaps an invalid function implementation)
            // so we are unable to propagate the error correctly and will just throw
            RuntimeException r = new RuntimeException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);
            // TODO could the hook be the cause of the error in the on error handling.
            hook.onSubscribeError(r);
            // TODO why aren&#39;t we throwing the hook&#39;s return value.
            throw r;
        }
        return Subscriptions.unsubscribed();
    }
}</code></pre>
<p>对这个<code>subsribe()</code>方法做的事情做一个总结：</p>
<ol>
<li>对参数进行验证，保证Not null</li>
<li>调用subscriber.onStart();</li>
<li>将<code>Subscriber</code>封装成<code>SafeSubscriber</code>，用装饰者模式包装了一层，在这一层加了一些额外的逻辑，但是不影响主要逻辑的执行，所以这一层的逻辑我们稍后再分析。</li>
<li>调用<code>OnSubsribe</code>接口的<code>call</code>方法。并捕捉异常，关于异常捕捉，稍后再分析</li>
</ol>
<p>而由于调用到第四点的<code>call</code>方法，call方法就是create方法的参数传递进去的代码块：</p>
<pre><code class="java">Observable.create&lt;String&gt; { it: Subscriber&lt;in String&gt; -&gt;
    //上游发射数据
    it.onNext(&quot;123&quot;)
    it.onCompleted()
}.subscribe { it: String -&gt;
    //下游处理数据
    LogUtils.d(it)
}</code></pre>
<p>因此我们调用onNext传递的数据就能够在下游被处理到了。</p>
<h4 id="1-2-just方式"><a href="#1-2-just方式" class="headerlink" title="1.2 just方式"></a>1.2 just方式</h4><pre><code class="java">Observable.just(&quot;2&quot;)
    .doOnNext {
        LogUtils.d(it)
    }
    .subscribe {
        val s: String? = null
        s!!
        s.toString()
    }</code></pre>
<p>当调用<code>just</code>方法的时候，就不需要在上游手动调用<code>onNext</code>了，那么一定是<code>RxJava</code>的内部调用了<code>onNext</code>，来看下吧。</p>
<pre><code class="java">public final static &lt;T&gt; Observable&lt;T&gt; just(final T value) {
    return ScalarSynchronousObservable.create(value);
}</code></pre>
<p>返回了一个<code>ScalarSynchronousObservable</code>的create方法：</p>
<pre><code class="java">public final class ScalarSynchronousObservable&lt;T&gt; extends Observable&lt;T&gt; {

    public static final &lt;T&gt; ScalarSynchronousObservable&lt;T&gt; create(T t) {
        return new ScalarSynchronousObservable&lt;T&gt;(t);
    }

    private final T t;

    protected ScalarSynchronousObservable(final T t) {
        super(new OnSubscribe&lt;T&gt;() {

            @Override
            public void call(Subscriber&lt;? super T&gt; s) {
                /*
                 *  We don&#39;t check isUnsubscribed as it is a significant performance impact in the fast-path use cases.
                 *  See PerfBaseline tests and https://github.com/ReactiveX/RxJava/issues/1383 for more information.
                 *  The assumption here is that when asking for a single item we should emit it and not concern ourselves with 
                 *  being unsubscribed already. If the Subscriber unsubscribes at 0, they shouldn&#39;t have subscribed, or it will 
                 *  filter it out (such as take(0)). This prevents us from paying the price on every subscription. 
                 */
                s.onNext(t);
                s.onCompleted();
            }

        });
        this.t = t;
    }
    //...
}</code></pre>
<p><code>ScalarSynchronousObservable</code>的构造方法中传入的<code>OnSubscribe</code>的实现中，已经调用了<code>onNext</code>和<code>onCompleted</code>了。</p>
<h3 id="2-SafeSubscriber"><a href="#2-SafeSubscriber" class="headerlink" title="2 SafeSubscriber"></a>2 SafeSubscriber</h3><p>事件监听就是选择性地重写三个方法：</p>
<p><code>void onNext(T t);</code>，<code>void onError(Throwable e);</code>，<code>void onCompleted();</code>。</p>
<p>而这三个方法的关系，例如onError和onCompleted有调用互斥性等，都借由<code>SafeSubscriber</code>类实现：</p>
<pre><code class="java">private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {
        //...
        if (!(subscriber instanceof SafeSubscriber)) {
            // assign to `observer` so we return the protected version
            subscriber = new SafeSubscriber&lt;T&gt;(subscriber);
        }
        //...
    }</code></pre>
<pre><code class="java">public class SafeSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {

    private final Subscriber&lt;? super T&gt; actual;

    //事件流是否结束
    boolean done = false;
    //用装饰者模式，封装真正的Subscriber在actual变量中
    public SafeSubscriber(Subscriber&lt;? super T&gt; actual) {
        super(actual);
        this.actual = actual;
    }

    @Override
    public void onCompleted() {
        //如果事件流没有结束
        if (!done) {
            done = true;
            //将onCompleted用try catch
            try {
                actual.onCompleted();
            } catch (Throwable e) {
                //抛出致命异常
                Exceptions.throwIfFatal(e);
                //调用内部_onError
                _onError(e);
            } finally {
                unsubscribe();
            }
        }
    }

    @Override
    public void onError(Throwable e) {
        //抛出致命异常
        Exceptions.throwIfFatal(e);
        if (!done) {
            done = true;
            //调用内部_onError
            _onError(e);
        }
    }

    @Override
    public void onNext(T args) {
        try {
            if (!done) {
                actual.onNext(args);
            }
        } catch (Throwable e) {
            //抛出致命异常
            Exceptions.throwIfFatal(e);
            //回调到onError
            onError(e);
        }
    }

    //有两处会调用这里，1. onCompleted。2. onError
    protected void _onError(Throwable e) {
        try {
            //首先调用RxJavaPlugins中的错误统一处理
            RxJavaPlugins.getInstance().getErrorHandler().handleError(e);
        } catch (Throwable pluginException) {
            //捕捉RxJavaPlugins中的错误，并打印出来。
            handlePluginException(pluginException);
        }
        try {
            //调用真正的actual的onError
            actual.onError(e);
        } catch (Throwable e2) {
            //补货onError中的异常
            if (e2 instanceof OnErrorNotImplementedException) {
                //如果异常是OnErrorNotImplementedException
                //unsubscribe
                try {
                    unsubscribe();
                } catch (Throwable unsubscribeException) {
                    try {
                        RxJavaPlugins.getInstance().getErrorHandler().handleError(unsubscribeException);
                    } catch (Throwable pluginException) {
                        handlePluginException(pluginException);
                    }
                    throw new RuntimeException(&quot;Observer.onError not implemented and error while unsubscribing.&quot;, new CompositeException(Arrays.asList(e, unsubscribeException)));
                }
                //将异常抛出
                throw (OnErrorNotImplementedException) e2;
            } else {
                //否则，还是进行错误统一处理
                try {
                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e2);
                } catch (Throwable pluginException) {
                    handlePluginException(pluginException);
                }
                //unsubscirbe
                try {
                    unsubscribe();
                } catch (Throwable unsubscribeException) {
                    try {
                        RxJavaPlugins.getInstance().getErrorHandler().handleError(unsubscribeException);
                    } catch (Throwable pluginException) {
                        handlePluginException(pluginException);
                    }
                    throw new OnErrorFailedException(&quot;Error occurred when trying to propagate error to Observer.onError and during unsubscription.&quot;, new CompositeException(Arrays.asList(e, e2, unsubscribeException)));
                }
                //再将异常抛出
                throw new OnErrorFailedException(&quot;Error occurred when trying to propagate error to Observer.onError&quot;, new CompositeException(Arrays.asList(e, e2)));
            }
        }
        //unsubscribe
        try {
            unsubscribe();
        } catch (RuntimeException unsubscribeException) {
            try {
                RxJavaPlugins.getInstance().getErrorHandler().handleError(unsubscribeException);
            } catch (Throwable pluginException) {
                handlePluginException(pluginException);
            }
            throw new OnErrorFailedException(unsubscribeException);
        }
    }

    private void handlePluginException(Throwable pluginException) {
        System.err.println(&quot;RxJavaErrorHandler threw an Exception. It shouldn&#39;t. =&gt; &quot; + pluginException.getMessage());
        pluginException.printStackTrace();
    }

    public Subscriber&lt;? super T&gt; getActual() {
        return actual;
    }
}</code></pre>
<h3 id="3-RxJava如何处理异常，如何上抛异常"><a href="#3-RxJava如何处理异常，如何上抛异常" class="headerlink" title="3 RxJava如何处理异常，如何上抛异常"></a>3 RxJava如何处理异常，如何上抛异常</h3><p>上文的对<code>SafeSubscriber</code>的分析可以看出RxJava对处理数据下游异常的方式：</p>
<ol>
<li>转到onError将异常抛出。</li>
<li>如果onError未实现，那么直接将异常抛出。</li>
<li>如果onError实现了，但是onError中又有异常，那么RxJava又会将异常抛出。</li>
</ol>
<p>那么如果在数据的上游，即数据发射处就发生异常了，要如何处理呢：</p>
<p>在Observable的构造类的函数中，最终会调用到：</p>
<pre><code class="java">private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {
 // validate and proceed
    if (subscriber == null) {
        throw new IllegalArgumentException(&quot;observer can not be null&quot;);
    }
    if (observable.onSubscribe == null) {
        throw new IllegalStateException(&quot;onSubscribe function can not be null.&quot;);
        /*
         * the subscribe function can also be overridden but generally that&#39;s not the appropriate approach
         * so I won&#39;t mention that in the exception
         */
    }

    // new Subscriber so onStart it
    subscriber.onStart();

    /*
     * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on &quot;Guideline 6.4: Protect calls
     * to user code from within an Observer&quot;
     */
    // if not already wrapped
    if (!(subscriber instanceof SafeSubscriber)) {
        // assign to `observer` so we return the protected version
        subscriber = new SafeSubscriber&lt;T&gt;(subscriber);
    }
    // The code below is exactly the same an unsafeSubscribe but not used because it would add a sigificent depth to alreay huge call stacks.
    try {
        // allow the hook to intercept and/or decorate
        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);
        return hook.onSubscribeReturn(subscriber);
    } catch (Throwable e) {
        // special handling for certain Throwable/Error/Exception types
        Exceptions.throwIfFatal(e);
        // if an unhandled error occurs executing the onSubscribe we will propagate it
        try {
            subscriber.onError(hook.onSubscribeError(e));
        } catch (OnErrorNotImplementedException e2) {
            // special handling when onError is not implemented ... we just rethrow
            throw e2;
        } catch (Throwable e2) {
            // if this happens it means the onError itself failed (perhaps an invalid function implementation)
            // so we are unable to propagate the error correctly and will just throw
            RuntimeException r = new RuntimeException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);
            // TODO could the hook be the cause of the error in the on error handling.
            hook.onSubscribeError(r);
            // TODO why aren&#39;t we throwing the hook&#39;s return value.
            throw r;
        }
        return Subscriptions.unsubscribed();
    }
}</code></pre>
<p>看一下上述的这段代码：</p>
<pre><code class="java">try {
    //将call的调用用try catch保护起来
    hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);
    return hook.onSubscribeReturn(subscriber);
} catch (Throwable e) {
    //抛出致命异常
    Exceptions.throwIfFatal(e);
    try {
        //调用给onError
        subscriber.onError(hook.onSubscribeError(e));
    } catch (OnErrorNotImplementedException e2) {
        throw e2;
    } catch (Throwable e2) {
        RuntimeException r = new RuntimeException(&quot;Error occurred attempting to subscrib
        hook.onSubscribeError(r);
        throw r;
    }
    //unsubscribe
    return Subscriptions.unsubscribed();
}</code></pre>
<p>可以看到：数据发射处也有异常处理：交给观察者的onError处理，然后处理逻辑就又转交给观察了。</p>
<h3 id="4-为什么能够用操作符追加代码逻辑"><a href="#4-为什么能够用操作符追加代码逻辑" class="headerlink" title="4 为什么能够用操作符追加代码逻辑"></a>4 为什么能够用操作符追加代码逻辑</h3><h4 id="4-1-图和大致流程分析"><a href="#4-1-图和大致流程分析" class="headerlink" title="4.1 图和大致流程分析"></a>4.1 图和大致流程分析</h4><p>在进行代码分析之前，先看下这个大致的调用流程图：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/7177220-d519af5b25e37b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p>
<p>这幅图表现出来的几个点：</p>
<ol>
<li>在使用RxJava写调用链代码的时候，<code>onNext</code>等代码块是从上往下执行的，但是每当往调用链上拼接一个RxJava的处理方法例如：<code>doOnNext</code>或者<code>map</code>的时候，都会生成一个新的<code>Subscriber</code>，而当调用最底部的<code>subscribe()</code>方法的时候，调用链上每一个<code>Subscriber</code>中的<code>OnSubscribe.call()</code>方法实际上是从下往上调用的。</li>
<li>在图中，<code>Observable3</code>是最终的观察者创建的对象。当调用subscribe方法的时候，由<code>Observable.subscribe()</code>的源码开始，要调用<code>Observable2</code>的<code>call_2()</code>方法，而<code>call_2()</code>方法的逻辑要参考<code>Observable#lift()</code>方法的逻辑，他会将<code>Observable2</code>的<code>onNext()</code>等代码块保存并拼接在<code>Observable3</code>的<code>onNext</code>之前。然后又调用<code>Observable1</code>的<code>call_1()</code>方法…一直这么重复着往上调用各个链上的call方法。最后，调用到顶部的数据发起处的函数：<code>Observable.create</code>，他的<code>call()</code>方法使我们写好的：<code>it.onNext(&quot;123&quot;)...</code>（或者Observable.just等构造方法，里面内定了如何调用onNext方法来发射数据）。此时，顶部开始发射数据。此时，遇到他的观察者：<code>Observable1</code>的<code>onNext()</code>，那么执行内部的逻辑，并调用了<code>Observable2</code>的<code>onNext()</code>，然后执行后者内部的逻辑，然后又调用<code>Observable3</code>的…，就这样把数据不断地往调用链下部调用，最终到达底部的观察者的代码块。</li>
<li>大的逻辑是：从上往下增加每一个操作符，就会构造一个<code>Subscriber</code>，然后在最后调用<code>subscribe()</code>方法的时候，递归上去一个一个地调用call方法，最终到顶部的<code>onNext</code>，再递归下来，一个一个地调用开发者调用每个操作符时加入的逻辑。</li>
</ol>
<p>那么先来从简单的开始看好了：</p>
<pre><code class="java">Observable.create&lt;String&gt; { it: Subscriber&lt;in String&gt; -&gt;
    it.onNext(&quot;123&quot;)
    it.onCompleted()
}.subscribe { it: String -&gt;
    LogUtils.d(it)
}</code></pre>
<p>这种类型的流程上面已经分析过了，非常简单，就是在subscribe()方法调用的时候，调用call方法里面的:</p>
<pre><code class="java">    it.onNext(&quot;123&quot;)
    it.onCompleted()</code></pre>
<p>然后自然地数据就发送到了下游了。</p>
<p>上述是没有添加任何操作符的情况，那么如果添加操作符了呢？例如添加一个<code>doOnNext()</code></p>
<pre><code class="java">Observable
    .create&lt;String&gt; { it: Subscriber&lt;in String&gt; -&gt;
        it.onNext(&quot;123&quot;)
        it.onCompleted()
    }
    .doOnNext {
        LogUtils.d(&quot;doOnNext=$it&quot;)
    }
    .subscribe { it: String -&gt;
        LogUtils.d(it)
    }</code></pre>
<p>这里我们看一下doOnNext中的代码块是如何追加到调用链上的。</p>
<p>看实现：</p>
<pre><code class="java">public final Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext) {
    Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {
        @Override
        public final void onCompleted() {
        }
        @Override
        public final void onError(Throwable e) {
        }
        @Override
        public final void onNext(T args) {
            onNext.call(args);
        }
    };
    //上述代码是将onNext封装到了一个Observer里面。
    return lift(new OperatorDoOnEach&lt;T&gt;(observer));
}</code></pre>
<p>这个封装过的observer，作为<code>OperatorDoOnEach</code>类的构造器的参数被传递进去，然后又作为<code>lift()</code>方法被调用，并返回一个<code>Observable</code>类型。（是的，因为这个操作符是可以直接调用subscribe()的）</p>
<h4 id="4-2-OperatorDoOnEach类型"><a href="#4-2-OperatorDoOnEach类型" class="headerlink" title="4.2 OperatorDoOnEach类型"></a>4.2 OperatorDoOnEach类型</h4><pre><code class="java">public class OperatorDoOnEach&lt;T&gt; implements Operator&lt;T, T&gt;</code></pre>
<p>他的父类型是Operator：</p>
<pre><code class="java">/**
 * Operator function for lifting into an Observable.
 */
public interface Operator&lt;R, T&gt; extends Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt; {
    // cover for generics insanity
}</code></pre>
<p>Operator实现了Func1接口：</p>
<pre><code class="java">public interface Func1&lt;T, R&gt; extends Function {
    R call(T t);
}</code></pre>
<p>Func1接口的作用是：转化</p>
<p>调用call方法的时候：输入T，返回R。</p>
<p>那么Operator的作用也可以说是：转化。但是他是Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt;，因此他的转化是：输入一个观察者T，返回另一个观察者R。</p>
<p>那么我们也可以说Operator的作用是：给原有的观察者添加额外的逻辑。</p>
<p>那么说具体点：客户端的调用是：</p>
<pre><code class="java">Operator concreteOperator ;
SubscriberB = concreteOperator.call(SubscriberA);</code></pre>
<p>即获取到Operator接口，然后调用call方法，进行转换。</p>
<p>而<code>doOnNext()</code>方法用的是<code>OperatorDoOnEach</code>：</p>
<pre><code class="java">public class OperatorDoOnEach&lt;T&gt; implements Operator&lt;T, T&gt; {
    private final Observer&lt;? super T&gt; doOnEachObserver;

    //构造方法中，保存了一个观察者，称为doOnEachObserver
    public OperatorDoOnEach(Observer&lt;? super T&gt; doOnEachObserver) {
        this.doOnEachObserver = doOnEachObserver;
    }

    //调用call方法，开始转换。call方法返回的新的观察者的每个实现，都是在参数observer的方法之前
    //拼接上构造函数的doOnEachObserver的对应的方法。
    @Override
    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; observer) {
        //传入的是observer
        return new Subscriber&lt;T&gt;(observer) {

            private boolean done = false;

            @Override
            public void onCompleted() {
                if (done) {
                    return;
                }
                //先调用doOnEachObserver.onCompleted()
                try {
                    doOnEachObserver.onCompleted();
                } catch (Throwable e) {
                    onError(e);
                    return;
                }
                // Set `done` here so that the error in `doOnEachObserver.onCompleted()` can be noticed by observer
                done = true;
                //再调用observer.onCompleted()
                observer.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                // need to throwIfFatal since we swallow errors after terminated
                Exceptions.throwIfFatal(e);
                if (done) {
                    return;
                }
                done = true;
                //先调用doOnEachObserver.onError
                try {
                    doOnEachObserver.onError(e);
                } catch (Throwable e2) {
                    observer.onError(e2);
                    return;
                }
                //再调用observer.onError
                observer.onError(e);
            }

            @Override
            public void onNext(T value) {
                if (done) {
                    return;
                }
                //先调用doOnEachObserver.onNext
                try {
                    doOnEachObserver.onNext(value);
                } catch (Throwable e) {
                    onError(OnErrorThrowable.addValueAsLastCause(e, value));
                    return;
                }
                //再调用observer.onNext
                observer.onNext(value);
            }
        };
    }
}</code></pre>
<p>分析完了OperatorDoOnEach的具体实现，接下来要看下他的call方法是如何被调用的：</p>
<h4 id="4-3-lift-方法"><a href="#4-3-lift-方法" class="headerlink" title="4.3 lift()方法"></a>4.3 lift()方法</h4><p>接着看下<code>doOnNext()</code></p>
<pre><code class="java">public final Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext) {
    Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {
        @Override
        public final void onCompleted() {
        }
        @Override
        public final void onError(Throwable e) {
        }
        @Override
        public final void onNext(T args) {
            onNext.call(args);
        }
    };
    //上述代码是将onNext封装到了一个Observer里面。
    return lift(new OperatorDoOnEach&lt;T&gt;(observer));
}</code></pre>
<pre><code class="java">public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) {
    return new Observable&lt;R&gt;(new OnSubscribe&lt;R&gt;() {
        //这个call会被上层调用
        @Override
        public void call(Subscriber&lt;? super R&gt; o) {
            //这个o是上游调用这个return new Observable返回的观察者中的OnSubscribe的call方法传递下来的
            //观察者，在本例中，由于onNext之前就是Observable.create，因此o中的call方法就是：
            //    {
            //        it.onNext(&quot;123&quot;);
            //        it.onCompleted();
            //    }
            try {
                //调用call，将o转换成st。
                //st中的call方法的逻辑参照着OperatorDoOnEach的逻辑就是：将operator的调用逻辑追加在o的调用逻辑之前。
                Subscriber&lt;? super T&gt; st = hook.onLift(operator).call(o);
                try {
                    // new Subscriber created and being subscribed with so &#39;onStart&#39; it
                    st.onStart();
                    //继续调用call方法
                    onSubscribe.call(st);
                } catch (Throwable e) {
                    // localized capture of errors rather than it skipping all operators 
                    // and ending up in the try/catch of the subscribe method which then
                    // prevents onErrorResumeNext and other similar approaches to error handling
                    if (e instanceof OnErrorNotImplementedException) {
                        throw (OnErrorNotImplementedException) e;
                    }
                    st.onError(e);
                }
            } catch (Throwable e) {
                if (e instanceof OnErrorNotImplementedException) {
                    throw (OnErrorNotImplementedException) e;
                }
                // if the lift function failed all we can do is pass the error to the final Subscriber
                // as we don&#39;t have the operator available to us
                o.onError(e);
            }
        }
    });
}</code></pre>
<p>注意，onLift方法是一个全局钩子。</p>
<pre><code class="java">public &lt;T, R&gt; Operator&lt;? extends R, ? super T&gt; onLift(final Operator&lt;? extends R, ? super T&gt; lift) {
    //默认实现是啥都不处理直接返回。
    return lift;
}</code></pre>
<h3 id="5-常用操作符源码分析"><a href="#5-常用操作符源码分析" class="headerlink" title="5 常用操作符源码分析"></a>5 常用操作符源码分析</h3><h4 id="5-1-filter"><a href="#5-1-filter" class="headerlink" title="5.1 filter"></a>5.1 filter</h4><p>过滤</p>
<pre><code class="java">public final Observable&lt;T&gt; filter(Func1&lt;? super T, Boolean&gt; predicate) {
    //调用lift
    return lift(new OperatorFilter&lt;T&gt;(predicate));
}</code></pre>
<pre><code class="java">public final class OperatorFilter&lt;T&gt; implements Operator&lt;T, T&gt; {

    private final Func1&lt;? super T, Boolean&gt; predicate;

    public OperatorFilter(Func1&lt;? super T, Boolean&gt; predicate) {
        this.predicate = predicate;
    }

    @Override
    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; child) {
        return new Subscriber&lt;T&gt;(child) {

            @Override
            public void onCompleted() {
                child.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                child.onError(e);
            }

            @Override
            public void onNext(T t) {
                try {
                    //如果call方法返回true，才继续将数据向下传递
                    if (predicate.call(t)) {
                        child.onNext(t);
                    } else {
                        // TODO consider a more complicated version that batches these
                        request(1);
                    }
                } catch (Throwable e) {
                    child.onError(OnErrorThrowable.addValueAsLastCause(e, t));
                }
            }

        };
    }

}</code></pre>
<h4 id="5-2-map"><a href="#5-2-map" class="headerlink" title="5.2 map"></a>5.2 map</h4><p>映射</p>
<pre><code class="java">public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) {
    return lift(new OperatorMap&lt;T, R&gt;(func));
}</code></pre>
<pre><code class="java">public final class OperatorMap&lt;T, R&gt; implements Operator&lt;R, T&gt; {

    private final Func1&lt;? super T, ? extends R&gt; transformer;

    public OperatorMap(Func1&lt;? super T, ? extends R&gt; transformer) {
        this.transformer = transformer;
    }

    @Override
    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super R&gt; o) {
        return new Subscriber&lt;T&gt;(o) {

            @Override
            public void onCompleted() {
                o.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                o.onError(e);
            }

            @Override
            public void onNext(T t) {
                try {
                    //transformer就是映射，映射后的数据将继续向下游发射。
                    o.onNext(transformer.call(t));
                } catch (Throwable e) {
                    Exceptions.throwIfFatal(e);
                    onError(OnErrorThrowable.addValueAsLastCause(e, t));
                }
            }

        };
    }

}</code></pre>
<p>}<br>    .doOnNext {<br>        LogUtils.d(“doOnNext=$it”)<br>    }<br>    .subscribe { it: String -&gt;<br>        LogUtils.d(it)<br>    }</p>
<pre><code>
这里我们看一下doOnNext中的代码块是如何追加到调用链上的。

看实现：

``` java
public final Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext) {
    Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {
        @Override
        public final void onCompleted() {
        }
        @Override
        public final void onError(Throwable e) {
        }
        @Override
        public final void onNext(T args) {
            onNext.call(args);
        }
    };
    //上述代码是将onNext封装到了一个Observer里面。
    return lift(new OperatorDoOnEach&lt;T&gt;(observer));
}</code></pre><p>这个封装过的observer，作为<code>OperatorDoOnEach</code>类的构造器的参数被传递进去，然后又作为<code>lift()</code>方法被调用，并返回一个<code>Observable</code>类型。（是的，因为这个操作符是可以直接调用subscribe()的）</p>
<h4 id="4-2-OperatorDoOnEach类型-1"><a href="#4-2-OperatorDoOnEach类型-1" class="headerlink" title="4.2 OperatorDoOnEach类型"></a>4.2 OperatorDoOnEach类型</h4><pre><code class="java">public class OperatorDoOnEach&lt;T&gt; implements Operator&lt;T, T&gt;</code></pre>
<p>他的父类型是Operator：</p>
<pre><code class="java">/**
 * Operator function for lifting into an Observable.
 */
public interface Operator&lt;R, T&gt; extends Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt; {
    // cover for generics insanity
}</code></pre>
<p>Operator实现了Func1接口：</p>
<pre><code class="java">public interface Func1&lt;T, R&gt; extends Function {
    R call(T t);
}</code></pre>
<p>Func1接口的作用是：转化</p>
<p>调用call方法的时候：输入T，返回R。</p>
<p>那么Operator的作用也可以说是：转化。但是他是Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt;，因此他的转化是：输入一个观察者T，返回另一个观察者R。</p>
<p>那么我们也可以说Operator的作用是：给原有的观察者添加额外的逻辑。</p>
<p>那么说具体点：客户端的调用是：</p>
<pre><code class="java">Operator concreteOperator ;
SubscriberB = concreteOperator.call(SubscriberA);</code></pre>
<p>即获取到Operator接口，然后调用call方法，进行转换。</p>
<p>而<code>doOnNext()</code>方法用的是<code>OperatorDoOnEach</code>：</p>
<pre><code class="java">public class OperatorDoOnEach&lt;T&gt; implements Operator&lt;T, T&gt; {
    private final Observer&lt;? super T&gt; doOnEachObserver;

    //构造方法中，保存了一个观察者，称为doOnEachObserver
    public OperatorDoOnEach(Observer&lt;? super T&gt; doOnEachObserver) {
        this.doOnEachObserver = doOnEachObserver;
    }

    //调用call方法，开始转换。call方法返回的新的观察者的每个实现，都是在参数observer的方法之前
    //拼接上构造函数的doOnEachObserver的对应的方法。
    @Override
    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; observer) {
        //传入的是observer
        return new Subscriber&lt;T&gt;(observer) {

            private boolean done = false;

            @Override
            public void onCompleted() {
                if (done) {
                    return;
                }
                //先调用doOnEachObserver.onCompleted()
                try {
                    doOnEachObserver.onCompleted();
                } catch (Throwable e) {
                    onError(e);
                    return;
                }
                // Set `done` here so that the error in `doOnEachObserver.onCompleted()` can be noticed by observer
                done = true;
                //再调用observer.onCompleted()
                observer.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                // need to throwIfFatal since we swallow errors after terminated
                Exceptions.throwIfFatal(e);
                if (done) {
                    return;
                }
                done = true;
                //先调用doOnEachObserver.onError
                try {
                    doOnEachObserver.onError(e);
                } catch (Throwable e2) {
                    observer.onError(e2);
                    return;
                }
                //再调用observer.onError
                observer.onError(e);
            }

            @Override
            public void onNext(T value) {
                if (done) {
                    return;
                }
                //先调用doOnEachObserver.onNext
                try {
                    doOnEachObserver.onNext(value);
                } catch (Throwable e) {
                    onError(OnErrorThrowable.addValueAsLastCause(e, value));
                    return;
                }
                //再调用observer.onNext
                observer.onNext(value);
            }
        };
    }
}</code></pre>
<p>分析完了OperatorDoOnEach的具体实现，接下来要看下他的call方法是如何被调用的：</p>
<h4 id="4-3-lift-方法-1"><a href="#4-3-lift-方法-1" class="headerlink" title="4.3 lift()方法"></a>4.3 lift()方法</h4><p>接着看下<code>doOnNext()</code></p>
<pre><code class="java">public final Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext) {
    Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {
        @Override
        public final void onCompleted() {
        }
        @Override
        public final void onError(Throwable e) {
        }
        @Override
        public final void onNext(T args) {
            onNext.call(args);
        }
    };
    //上述代码是将onNext封装到了一个Observer里面。
    return lift(new OperatorDoOnEach&lt;T&gt;(observer));
}</code></pre>
<pre><code class="java">public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) {
    return new Observable&lt;R&gt;(new OnSubscribe&lt;R&gt;() {
        //这个call会被上层调用
        @Override
        public void call(Subscriber&lt;? super R&gt; o) {
            //这个o是上游调用这个return new Observable返回的观察者中的OnSubscribe的call方法传递下来的
            //观察者，在本例中，由于onNext之前就是Observable.create，因此o中的call方法就是：
            //    {
            //        it.onNext(&quot;123&quot;);
            //        it.onCompleted();
            //    }
            try {
                //调用call，将o转换成st。
                //st中的call方法的逻辑参照着OperatorDoOnEach的逻辑就是：将operator的调用逻辑追加在o的调用逻辑之前。
                Subscriber&lt;? super T&gt; st = hook.onLift(operator).call(o);
                try {
                    // new Subscriber created and being subscribed with so &#39;onStart&#39; it
                    st.onStart();
                    //继续调用call方法
                    onSubscribe.call(st);
                } catch (Throwable e) {
                    // localized capture of errors rather than it skipping all operators 
                    // and ending up in the try/catch of the subscribe method which then
                    // prevents onErrorResumeNext and other similar approaches to error handling
                    if (e instanceof OnErrorNotImplementedException) {
                        throw (OnErrorNotImplementedException) e;
                    }
                    st.onError(e);
                }
            } catch (Throwable e) {
                if (e instanceof OnErrorNotImplementedException) {
                    throw (OnErrorNotImplementedException) e;
                }
                // if the lift function failed all we can do is pass the error to the final Subscriber
                // as we don&#39;t have the operator available to us
                o.onError(e);
            }
        }
    });
}</code></pre>
<p>注意，onLift方法是一个全局钩子。</p>
<pre><code class="java">public &lt;T, R&gt; Operator&lt;? extends R, ? super T&gt; onLift(final Operator&lt;? extends R, ? super T&gt; lift) {
    //默认实现是啥都不处理直接返回。
    return lift;
}</code></pre>
<h3 id="5-常用操作符源码分析-1"><a href="#5-常用操作符源码分析-1" class="headerlink" title="5 常用操作符源码分析"></a>5 常用操作符源码分析</h3><h4 id="5-1-filter-1"><a href="#5-1-filter-1" class="headerlink" title="5.1 filter"></a>5.1 filter</h4><p>过滤</p>
<pre><code class="java">public final Observable&lt;T&gt; filter(Func1&lt;? super T, Boolean&gt; predicate) {
    //调用lift
    return lift(new OperatorFilter&lt;T&gt;(predicate));
}</code></pre>
<pre><code class="java">public final class OperatorFilter&lt;T&gt; implements Operator&lt;T, T&gt; {

    private final Func1&lt;? super T, Boolean&gt; predicate;

    public OperatorFilter(Func1&lt;? super T, Boolean&gt; predicate) {
        this.predicate = predicate;
    }

    @Override
    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; child) {
        return new Subscriber&lt;T&gt;(child) {

            @Override
            public void onCompleted() {
                child.onCompleted();
            }

            @Override
            public void onError(Throwable e) {
                child.onError(e);
            }

            @Override
            public void onNext(T t) {
                try {
                    //如果call方法返回true，才继续将数据向下传递
                    if (predicate.call(t)) {
                        child.onNext(t);
                    } else {
                        // TODO consider a more complicated version that batches these
                        request(1);
                    }
                } catch (Throwable e) {
                    child.onError(OnErrorThrowable.addValueAsLastCause(e, t));
                }
            }

        };
    }

}</code></pre>
<h4 id="5-2-map-1"><a href="#5-2-map-1" class="headerlink" title="5.2 map"></a>5.2 map</h4><p>映射</p>
<pre><code class="java">public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) {
    return lift(new OperatorMap&lt;T, R&gt;(func));
}</code></pre>
<p>``` java<br>public final class OperatorMap&lt;T, R&gt; implements Operator&lt;R, T&gt; {</p>
<pre><code>private final Func1&lt;? super T, ? extends R&gt; transformer;

public OperatorMap(Func1&lt;? super T, ? extends R&gt; transformer) {
    this.transformer = transformer;
}

@Override
public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super R&gt; o) {
    return new Subscriber&lt;T&gt;(o) {

        @Override
        public void onCompleted() {
            o.onCompleted();
        }

        @Override
        public void onError(Throwable e) {
            o.onError(e);
        }

        @Override
        public void onNext(T t) {
            try {
                //transformer就是映射，映</code></pre>
            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/">第三方库</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-6">
                    
                    
                      <a href="/2020/02/07/ndk/Android-cmake%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8A%A8%E6%80%81%E5%85%B1%E4%BA%AB%E5%BA%93/">
                        <i class="fa fa-chevron-left"></i>
                        <span class="hidden-mobile">Android-cmake使用外部动态共享库</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-6">
                    
                    
                      <a href="/2020/01/09/Java/Throwable%E7%9A%84%E4%BD%BF%E7%94%A8/">
                        <span class="hidden-mobile">Throwable的使用</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  
  <script defer src="https://utteranc.es/client.js"
          repo="HWilliamgo/HWilliamgo.github.io"
          issue-term="pathname"
  
          label="utterances"
    
          theme="github-light"
          crossorigin="anonymous"
  >
  </script>


                </div>
              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>





  <script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js" ></script>
  <script  src="/js/clipboard-use.js" ></script>





  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "RxJava1源码分析&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
