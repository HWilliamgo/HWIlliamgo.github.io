<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>重新理解MeasureSpec</title>
    <link href="/2020/05/28/View/%E9%87%8D%E5%86%99%E7%90%86%E8%A7%A3MeasureSpec/"/>
    <url>/2020/05/28/View/%E9%87%8D%E5%86%99%E7%90%86%E8%A7%A3MeasureSpec/</url>
    
    <content type="html"><![CDATA[<h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>网上有许多非常好的文章都在介绍MeasureSpec的测量规则，但是没有介绍MeasureSpec的作用和应用场景。</p><p><img src="https://s1.ax1x.com/2020/05/28/tekaEF.png" srcset="/img/loading.gif" alt="tekaEF.png"></p><p>MeasureSpec是一个int，他将SpecMode和SpecSize封装到了一起。</p><p>那么实际上MeasureSpec他是一个对：值和模式的一个封装。</p><p>在这里，size和mode是成对出现的，他们一起作用。</p><p>MeasureSpec可以翻译成：测量说明书。</p><p>他由手机屏幕的Window开始，将测量说明书生成并往下传递给DecorView，DecorView再生成自己的测量说明书，往下传递，不断递归，每个ViewGroup都根据父View的测量说明书和自己的尺寸，生成自己的测量说明书并递归下去。</p><p>什么是测量说明书？由编写测量说明书的一方（父View或者window）编写测量说明书，告诉客户（子View）要按照该测量说明书中的标准和规范来进行测量操作，从而实现父View对子View尺寸限制。</p><p>试问，一个子View如何知道他的父View给他预留了多少尺寸？</p><p>答：父View通过调用子View的measure()方法，将父View留给子View的尺寸传递给子View。</p><h3 id="2-MeasureSpec使用场景"><a href="#2-MeasureSpec使用场景" class="headerlink" title="2 MeasureSpec使用场景"></a>2 MeasureSpec使用场景</h3><p>MeasureSpec的使用场景分为两个：</p><ol><li><p>child View接收到parent View为自己生成的MeasureSpec对象，在onMeasure(int widthMeasureSpec, int heightMeasureSpec)中提取出该对象中的数据并调用setMeasureDimension为自己设置measureWidth和measureHeight.</p></li><li><p>parent View，即ViewGroup，这里先说下ViewGroup的onMeasure()方法的重写套路：</p><p>在收到自己的onMeasure()回调的时候：</p><p>①要先对自己所有的子View进行测量，一般是遍历所有子View并调用ViewGroup的measureChildWithMargins()，然后再调用child.getMeasureWidth方法取出测量值，然后要么累加所有子View的测量者（如LinearLayout），要么从中选出最大的那个（如FrameLayout）。</p><p>②根据业务逻辑和他的父View设置给自己的MeasureSpec，来对他自己调用setMeasureDimension。</p><p>这里的第②点就和1.是一个东西，所以我们说的是①。</p></li></ol><p>   即②中，在测量所有的子View的时候，父View将为每个子View生成他专属的MeasureSpec对象。</p><p>那么我们分别来看看这两种使用场景中是如何使用MeasureSpec的。</p><p>按照MeasureSpec先创建后使用的顺序，我们先看他的创建，后看他在子View中的使用</p><h3 id="3-MeasureSpec的创建"><a href="#3-MeasureSpec的创建" class="headerlink" title="3 MeasureSpec的创建"></a>3 MeasureSpec的创建</h3><h4 id="3-1-Window为DecorView创建MeasureSpec"><a href="#3-1-Window为DecorView创建MeasureSpec" class="headerlink" title="3.1 Window为DecorView创建MeasureSpec"></a>3.1 Window为DecorView创建MeasureSpec</h4><p>从最顶部开始：</p><p>ViewRootImpl.java</p><pre><code class="java">private boolean measureHierarchy(final View host, final WindowManager.LayoutParams lp,                                 final Resources res, final int desiredWindowWidth, final int desiredWindowHeight) {        }    //...    if (!goodMeasure) {        childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);        childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);        performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);        if (mWidth != host.getMeasuredWidth() || mHeight != host.getMeasuredHeight()) {            windowSizeMayChange = true;        }    }    //...    return windowSizeMayChange;</code></pre><p>这里的<code>performMeasure</code>方法里面，调用了DecorView的measure，至此<code>MeasureSpec</code>对象开始从ViewTreee顶部开始向下传递。</p><pre><code class="java">private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {    if (mView == null) {        return;    }    Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;measure&quot;);    try {        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);    } finally {        Trace.traceEnd(Trace.TRACE_TAG_VIEW);    }}</code></pre><p>这里看下传递给DecorView的MeasureSpec是如何生成的：</p><pre><code class="java">private static int getRootMeasureSpec(int windowSize, int rootDimension) {    int measureSpec;    switch (rootDimension) {    case ViewGroup.LayoutParams.MATCH_PARENT:        // Window can&#39;t resize. Force root view to be windowSize.        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);        break;    case ViewGroup.LayoutParams.WRAP_CONTENT:        // Window can resize. Set max size for root view.        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);        break;    default:        // Window wants to be an exact size. Force root view to be that size.        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);        break;    }    return measureSpec;}</code></pre><p>这里的windowSize是从WindowMananger获取到的Window的视图的尺寸，如手机屏幕大小。</p><p>而rootDimension参数是分别是DecorView的宽和高。而这里就是MATCH_PARENT，具体的定义要看创建DecorView的源码的地方，对应的是PhoneWindow类的<code>installDecor()</code>方法里。</p><p>通过这个<code>getRootMeasureSpec()</code>方法我们可以看到，创建的size和mode的对应关系为：</p><table><thead><tr><th>size</th><th>mode</th></tr></thead><tbody><tr><td>MATCH_PARENT</td><td>MeasureSpec.EXACTLY</td></tr><tr><td>WRAP_CONTENT</td><td>MeasureSpec.AT_MOST</td></tr><tr><td>具体值</td><td>MeasureSpec.EXACTLY</td></tr></tbody></table><p>这是window为DecorView创建MeasureSpec时，为后者创建的MeasureSpec的对应的规则，举一反三一下，ViewGroup为子View创建MeasureSpec的时候，也是用的这种规则来生成MeasureSpec对象。</p><h4 id="3-2-ViewGroup为子View创建MeasureSpec"><a href="#3-2-ViewGroup为子View创建MeasureSpec" class="headerlink" title="3.2 ViewGroup为子View创建MeasureSpec"></a>3.2 ViewGroup为子View创建MeasureSpec</h4><p>测量子View这件事都是发生在ViewGroup的onMeasure中，而ViewGroup是没有重写onMeasure的，这个规则他留给了他的子类去重写，我们找到一个最简单的子类：FrameLayout，并截取部分他的onMeasure中的代码：</p><pre><code class="java">@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {    int count = getChildCount();    //...    int maxHeight = 0;    int maxWidth = 0;    int childState = 0;    //遍历子View    for (int i = 0; i &lt; count; i++) {    final View child = getChildAt(i);    if (mMeasureAllChildren || child.getVisibility() != GONE) {        //测量子View        measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);        //提取子View的measuredWidth和measuredHeight        final LayoutParams lp = (LayoutParams) child.getLayoutParams();        maxWidth = Math.max(maxWidth,                child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);        maxHeight = Math.max(maxHeight,                child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);        //...    }    //...}</code></pre><p>那么看他用来测量子View调用的ViewGroup的方法：measureChildWithMargins</p><pre><code class="java">protected void measureChildWithMargins(View child,        int parentWidthMeasureSpec, int widthUsed,        int parentHeightMeasureSpec, int heightUsed) {    //获取子View的LayoutParams    final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();    //创建子View的宽的MeasureSpec    final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin                    + widthUsed, lp.width);    //创建子View的高的MeasureSpec    final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin                    + heightUsed, lp.height);    //将这里创建的MeasureSpec传递给子View，并让子View进行测量    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);}</code></pre><p>当创建子View的宽的MeasureSpec的时候，调用了getChildMeasureSpec方法</p><pre><code class="java">public static int getChildMeasureSpec(int spec, int padding, int childDimension) {    int specMode = MeasureSpec.getMode(spec);    int specSize = MeasureSpec.getSize(spec);    //用父View的尺寸，减去已经使用了的尺寸（包括父view的padding,子View的marging和父View已经使用了的尺寸）。    int size = Math.max(0, specSize - padding);    int resultSize = 0;    int resultMode = 0;    switch (specMode) {            // Parent has imposed an exact size on us        case MeasureSpec.EXACTLY:            if (childDimension &gt;= 0) {                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size. So be it.                resultSize = size;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size. It can&#39;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;            // Parent has imposed a maximum size on us        case MeasureSpec.AT_MOST:            if (childDimension &gt;= 0) {                // Child wants a specific size... so be it                resultSize = childDimension;                resultMode = MeasureSpec.EXACTLY;            } else if (childDimension == LayoutParams.MATCH_PARENT) {                // Child wants to be our size, but our size is not fixed.                // Constrain child to not be bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            } else if (childDimension == LayoutParams.WRAP_CONTENT) {                // Child wants to determine its own size. It can&#39;t be                // bigger than us.                resultSize = size;                resultMode = MeasureSpec.AT_MOST;            }            break;            // Parent asked to see how big we want to be        case MeasureSpec.UNSPECIFIED:            //...    }    //noinspection ResourceType    return MeasureSpec.makeMeasureSpec(resultSize, resultMode);}</code></pre><p>注意这里的参数padding，加上了父View的padding和子View的margin和父View已经使用了的尺寸（如果是FrameLayout，就是0，如果是LinearLayout，则会累加，看ViewGroup的逻辑而定）。size变量则是父View的尺寸减去上述的padding，得出留给子View的剩余空间的大小。</p><p>那么这里给子View生成MeasureSpec的逻辑就是：</p><p><code>父View剩余大小</code>+<code>父View的MeasureSpec</code>+<code>子View的尺寸</code> –&gt; <code>子View的MeasureSpec</code></p><p>图形化表示为：</p><p><img src="https://s1.ax1x.com/2020/05/30/tQgom6.png" srcset="/img/loading.gif" alt="tQgom6.png"></p><p>这里有两个点要注意一下：</p><ol><li><p>当父View的布局大小确定的时候，即EXACTLY的时候，那么生成的子View的MeasureSpec依然符合上面创建根布局的情况：</p><table><thead><tr><th>size</th><th>mode</th></tr></thead><tbody><tr><td>MATCH_PARENT</td><td>MeasureSpec.EXACTLY</td></tr><tr><td>WRAP_CONTENT</td><td>MeasureSpec.AT_MOST</td></tr><tr><td>具体值</td><td>MeasureSpec.EXACTLY</td></tr></tbody></table><p> 而当父View自己的布局大小都不确定的时候，即AT_MOST时（即父View也是用的WRAP_CONTENT，所以他才得到了AT_MOST的mode）,子View的MATCH_PARENT其实就是要求和父View一样的大，那父View不确定大小，子View自然也不确定大小了，即AT_MOST。</p></li><li><p>当子View的尺寸是WRAP_CONTENT的时候，父View给子View生成的size是父View剩下的size。</p><p>为什么？因为父View在此时也不知道你子View有多大，那就把父View剩余的大小给子View，并告诉子View模式是AT_MOST，你子View最大不要超过我给你的这个大小，剩下的你尽管发挥。</p></li></ol><h3 id="4-MeasureSpec的使用"><a href="#4-MeasureSpec的使用" class="headerlink" title="4 MeasureSpec的使用"></a>4 MeasureSpec的使用</h3><h4 id="4-1-View的onMeasure"><a href="#4-1-View的onMeasure" class="headerlink" title="4.1 View的onMeasure"></a>4.1 View的onMeasure</h4><pre><code class="java">protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),                         getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));}</code></pre><p>这里是用的<code>getDefaultSize()</code>方法来获取最终的子View的宽高，并用<code>setMeasuredDimension()</code>设置到自己的属性（稍后父View就可以获取到子View给自己测量的大小了）。</p><p><code>getDefaultSize</code>的两个参数一个是获取建议的最小宽度，一个是父View给的测量说明书。</p><pre><code class="java">protected int getSuggestedMinimumWidth() {    return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth());}</code></pre><p>看下<code>getDefaultSize()</code>方法</p><pre><code class="java">public static int getDefaultSize(int size, int measureSpec) {    int result = size;    int specMode = MeasureSpec.getMode(measureSpec);    int specSize = MeasureSpec.getSize(measureSpec);    switch (specMode) {    case MeasureSpec.UNSPECIFIED:        result = size;        break;    case MeasureSpec.AT_MOST:    case MeasureSpec.EXACTLY:        result = specSize;        break;    }    return result;}</code></pre><p>可以看到，如果父View给的测量模式是<code>UNSPECIFIED</code>，那就用<code>getSuggestedMinimumWidth</code>返回的大小。如果父View给的测量模式是<code>AT_MOST</code>或者<code>EXACTLY</code>，那就直接用父View给我们生成的大小。</p><p>这里要牵扯到一个自定义View的技巧：自定义View要重写onMeasure()方法来处理<code>AT_MOST</code>的测量模式。</p><p>从前面创建<code>MeasureSpec</code>知道，当子View用了<code>wrap_content</code>的时候，父View就会给你生成<code>AT_MOST</code>的测量模式，但因为<code>AT_MOST</code>测量模式下也是用的父View返回的尺寸，这时父View返回的尺寸是父View剩下的尺寸。他的意思是：这些尺寸给你，但是这是你能使用的最大的尺寸，不要超过这个尺寸就行。</p><p>一般来说我们会在自定义View中重写并判断<code>AT_MOST</code>时，返回一个默认的值。</p><p>比如这样：</p><pre><code class="java">override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {    super.onMeasure(widthMeasureSpec, heightMeasureSpec)    //默认尺寸，写死或者根据业务逻辑计算得到    val defaultWidth = 50    val defaultHeight = 100    //取出父View给的测量模式    val widthSpecMode = MeasureSpec.getMode(widthMeasureSpec)    val heightSpecMode = MeasureSpec.getMode(heightMeasureSpec)    //取出父View给的测量尺寸    val widthSpecSize = MeasureSpec.getSize(widthMeasureSpec)    val heightSpecSize = MeasureSpec.getSize(heightMeasureSpec)    //最终测量尺寸    val finalWidth = if (widthSpecMode == MeasureSpec.AT_MOST) defaultWidth else widthSpecSize    val finalHeight = if (heightSpecMode == MeasureSpec.AT_MOST) defaultHeight else heightSpecSize    //set    setMeasuredDimension(finalWidth,finalHeight)}</code></pre><p>这种是手动计算的，还有一种是借助View自带的<code>resolve()</code>方法来去计算的。</p><pre><code class="java">override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {    super.onMeasure(widthMeasureSpec, heightMeasureSpec)        //默认尺寸        val defaultWidth = 50        val defaultHeight = 100        //最终测量尺寸（注意，也计算了padding）        val finalWidth = resolveSize(defaultWidth + paddingLeft + paddingRight, widthMeasureSpec)        val finalHeight = resolveSize(defaultHeight + paddingTop + paddingBottom, heightMeasureSpec)        //设置        setMeasuredDimension(finalWidth, finalHeight)}</code></pre><p><code>resolveSize()</code>方法内部有更精细的判断：</p><pre><code class="java">public static int resolveSizeAndState(int size, int measureSpec, int childMeasuredState) {    final int specMode = MeasureSpec.getMode(measureSpec);    final int specSize = MeasureSpec.getSize(measureSpec);    final int result;    switch (specMode) {        case MeasureSpec.AT_MOST:            if (specSize &lt; size) {                result = specSize | MEASURED_STATE_TOO_SMALL;            } else {                result = size;            }            break;        case MeasureSpec.EXACTLY:            result = specSize;            break;        case MeasureSpec.UNSPECIFIED:        default:            result = size;    }    return result | (childMeasuredState &amp; MEASURED_STATE_MASK);}</code></pre><p>View对MeasureSpec是使用方，非创建方。</p><p>因此我们可以直接按照<code>MeasureSpec</code>的字面意思来直接理解：</p><p><code>SpecSize</code>就是你父View给我指定的测量的大小。那么我拿到了这个大小我要怎么用呢？看你给我生成的测量模式<code>SpecMode</code>，如果是<code>EXACTLY</code>，那父View的意思就是直接让我用这个size作为最终我的测量大小就行了。如果是<code>AT_MOST</code>，父View传递给我的消息是，这个size不是让你作为最终的size的，我只是把我剩下的尺寸给你了，你不要超过这个尺寸即可。</p><h4 id="4-2-FrameLayout的onMeasure"><a href="#4-2-FrameLayout的onMeasure" class="headerlink" title="4.2 FrameLayout的onMeasure"></a>4.2 FrameLayout的onMeasure</h4><p>实际上我们想看的是ViewGroup在onMeasure中是如何使用MeasureSpec的，但是ViewGroup没有重写，直接沿用改的View的，因此找了个简单的FrameLayout的来看看。</p><pre><code class="java">@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {    int count = getChildCount();    final boolean measureMatchParentChildren =        MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||        MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;    mMatchParentChildren.clear();    int maxHeight = 0;    int maxWidth = 0;    int childState = 0;    //遍历子View    for (int i = 0; i &lt; count; i++) {        final View child = getChildAt(i);        if (mMeasureAllChildren || child.getVisibility() != GONE) {            measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0);            final LayoutParams lp = (LayoutParams) child.getLayoutParams();            //取到所有子View中尺寸最大的那个尺寸            maxWidth = Math.max(maxWidth,                                child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);            maxHeight = Math.max(maxHeight,                                 child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);            childState = combineMeasuredStates(childState, child.getMeasuredState());            if (measureMatchParentChildren) {                if (lp.width == LayoutParams.MATCH_PARENT ||                    lp.height == LayoutParams.MATCH_PARENT) {                    mMatchParentChildren.add(child);                }            }        }    }    // 计算FrameLayout自身的padding    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();    // 再次检查 minimum height and width    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());    // Check against our foreground&#39;s minimum height and width    final Drawable drawable = getForeground();    if (drawable != null) {        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());    }    //调用resolveSizeAndState()方法去获取最终测量值    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),                         resolveSizeAndState(maxHeight, heightMeasureSpec,                                             childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));    count = mMatchParentChildren.size();    if (count &gt; 1) {        for (int i = 0; i &lt; count; i++) {            final View child = mMatchParentChildren.get(i);            final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();            final int childWidthMeasureSpec;            if (lp.width == LayoutParams.MATCH_PARENT) {                final int width = Math.max(0, getMeasuredWidth()                                           - getPaddingLeftWithForeground() - getPaddingRightWithForeground()                                           - lp.leftMargin - lp.rightMargin);                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(                    width, MeasureSpec.EXACTLY);            } else {                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,                                                            getPaddingLeftWithForeground() + getPaddingRightWithForeground() +                                                            lp.leftMargin + lp.rightMargin,                                                            lp.width);            }            final int childHeightMeasureSpec;            if (lp.height == LayoutParams.MATCH_PARENT) {                final int height = Math.max(0, getMeasuredHeight()                                            - getPaddingTopWithForeground() - getPaddingBottomWithForeground()                                            - lp.topMargin - lp.bottomMargin);                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(                    height, MeasureSpec.EXACTLY);            } else {                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,                                                             getPaddingTopWithForeground() + getPaddingBottomWithForeground() +                                                             lp.topMargin + lp.bottomMargin,                                                             lp.height);            }            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);        }    }}</code></pre><p>ViewGroup在对自己测量的时候，也是调用的<code>resolveSizeAndState</code>这个方法来计算出最终的测量值的。</p><h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5 总结"></a>5 总结</h3><p>对于<code>MeasureSpec</code>创建者ViewGroup， 根据子View的LayoutParams的width和heigth和自己的MeasureSpec来为子View创建出MeasureSpec。传递给子View，并让子View根据该MeasureSpec设置对应的测量宽高，然后父View再拿到子View测量宽高，将上述动作遍历所有子View后，再对自己进行测量，设置自己的宽高。</p><p>对于<code>MeasureSpec</code>使用者View，根据父View传递进来个MeasureSpec，结合自身逻辑，计算出自己的宽高。</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>子View设置尺寸大于父View时会超过父View大小吗</title>
    <link href="/2020/05/28/View/%E5%AD%90View%E8%AE%BE%E7%BD%AE%E5%B0%BA%E5%AF%B8%E5%A4%A7%E4%BA%8E%E7%88%B6View%E6%97%B6%E4%BC%9A%E8%B6%85%E8%BF%87%E7%88%B6View%E5%A4%A7%E5%B0%8F%E5%90%97/"/>
    <url>/2020/05/28/View/%E5%AD%90View%E8%AE%BE%E7%BD%AE%E5%B0%BA%E5%AF%B8%E5%A4%A7%E4%BA%8E%E7%88%B6View%E6%97%B6%E4%BC%9A%E8%B6%85%E8%BF%87%E7%88%B6View%E5%A4%A7%E5%B0%8F%E5%90%97/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>浅谈LayoutParams</title>
    <link href="/2020/05/26/View/LayoutInflater%E5%AF%B9View%E7%9A%84LayoutParams%E7%9A%84%E5%BD%B1%E5%93%8D/"/>
    <url>/2020/05/26/View/LayoutInflater%E5%AF%B9View%E7%9A%84LayoutParams%E7%9A%84%E5%BD%B1%E5%93%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="0-概述"><a href="#0-概述" class="headerlink" title="0 概述"></a>0 概述</h3><p><code>LayoutInflater</code>在Android开发中有大量的使用场景，例如：</p><ol><li>Activity和Dialog的setContentView方法内部用LayoutInflater从xml文件中加载出View对象。</li><li>Fragment中用LayoutInflater创建一个View返回给Fragment。</li><li>RecylerView的每一个Item对应的ViewHolder在创建的时候，需要先用LayoutInflater创建出对应的Item的View。</li><li>其他的，我们自己创建View的场景，比如自定义View等。</li></ol><p>那么你是否了解LayoutInflater在创建View的时候，是如何处理View的属性吗？</p><h3 id="1-源码"><a href="#1-源码" class="headerlink" title="1 源码"></a>1 源码</h3><pre><code class="java">public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {    final Resources res = getContext().getResources();    if (DEBUG) {        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;              + Integer.toHexString(resource) + &quot;)&quot;);    }    View view = tryInflatePrecompiled(resource, res, root, attachToRoot);    if (view != null) {        return view;    }    //根据R.layout.xxx的资源Id，创建出可以读取xml文件的解析器parser    XmlResourceParser parser = res.getLayout(resource);    try {        return inflate(parser, root, attachToRoot);    } finally {        parser.close();    }}</code></pre><pre><code class="java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {    synchronized (mConstructorArgs) {        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);        final Context inflaterContext = mContext;        //通过parser构造了AttributeSet对象，后者就是View的构造函数中返回的第二个参数，在自定义View时，我们通过他来        //找到我们在xml中给View定义的所有属性，例如宽高，visibility，padding，和其他自定义属性。        final AttributeSet attrs = Xml.asAttributeSet(parser);        Context lastContext = (Context) mConstructorArgs[0];        mConstructorArgs[0] = inflaterContext;        View result = root;        try {            advanceToRootNode(parser);            final String name = parser.getName();            if (DEBUG) {                System.out.println(&quot;**************************&quot;);                System.out.println(&quot;Creating root view: &quot;                        + name);                System.out.println(&quot;**************************&quot;);            }            if (TAG_MERGE.equals(name)) {                if (root == null || !attachToRoot) {                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;                            + &quot;ViewGroup root and attachToRoot=true&quot;);                }                rInflate(parser, root, inflaterContext, attrs, false);            } else {                // Temp is the root view that was found in the xml                final View temp = createViewFromTag(root, name, inflaterContext, attrs);                ViewGroup.LayoutParams params = null;                if (root != null) {                    if (DEBUG) {                        System.out.println(&quot;Creating params from root: &quot; +                                root);                    }                    // Create layout params that match root, if supplied                    params = root.generateLayoutParams(attrs);                    if (!attachToRoot) {                        // Set the layout params for temp if we are not                        // attaching. (If we are, we use addView, below)                        temp.setLayoutParams(params);                    }                }                if (DEBUG) {                    System.out.println(&quot;-----&gt; start inflating children&quot;);                }                // Inflate all children under temp against its context.                rInflateChildren(parser, temp, attrs, true);                if (DEBUG) {                    System.out.println(&quot;-----&gt; done inflating children&quot;);                }                // We are supposed to attach all the views we found (int temp)                // to root. Do that now.                if (root != null &amp;&amp; attachToRoot) {                    root.addView(temp, params);                }                // Decide whether to return the root that was passed in or the                // top view found in xml.                if (root == null || !attachToRoot) {                    result = temp;                }            }        } catch (XmlPullParserException e) {            final InflateException ie = new InflateException(e.getMessage(), e);            ie.setStackTrace(EMPTY_STACK_TRACE);            throw ie;        } catch (Exception e) {            final InflateException ie = new InflateException(                    getParserStateDescription(inflaterContext, attrs)                    + &quot;: &quot; + e.getMessage(), e);            ie.setStackTrace(EMPTY_STACK_TRACE);            throw ie;        } finally {            // Don&#39;t retain static reference on context.            mConstructorArgs[0] = lastContext;            mConstructorArgs[1] = null;            Trace.traceEnd(Trace.TRACE_TAG_VIEW);        }        return result;    }}</code></pre><p>这里注意一点：AttributeSet对象是从XmlPullParser中构造来的，这个AttributeSet就是View类的构造函数的第二个参数。包含所有在xml中定义的View的属性。</p><h4 id="1-1-从xml中解析并用反射实例化View"><a href="#1-1-从xml中解析并用反射实例化View" class="headerlink" title="1.1 从xml中解析并用反射实例化View"></a>1.1 从xml中解析并用反射实例化View</h4><pre><code class="java">public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {    //...    // Temp is the root view that was found in the xml    final View temp = createViewFromTag(root, name, inflaterContext, attrs);    //...}</code></pre><p>注意这里将atrrs传递，传递到通过attrs创建，并返回了一个View temp。</p><pre><code class="java">//Creates a view from a tag name using the supplied attribute set.View createViewFromTag(View parent, String name, Context context, AttributeSet attrs,                       boolean ignoreThemeAttr) {    if (name.equals(&quot;view&quot;)) {        name = attrs.getAttributeValue(null, &quot;class&quot;);    }    // Apply a theme wrapper, if allowed and one is specified.    if (!ignoreThemeAttr) {        //提取theme，也是使用的TypeArray来提取的。        final TypedArray ta = context.obtainStyledAttributes(attrs, ATTRS_THEME);        final int themeResId = ta.getResourceId(0, 0);        if (themeResId != 0) {            context = new ContextThemeWrapper(context, themeResId);        }        ta.recycle();    }    try {        //给LayoutInflater创建View提供一个Hook，待会分析        View view = tryCreateView(parent, name, context, attrs);        if (view == null) {            final Object lastContext = mConstructorArgs[0];            mConstructorArgs[0] = context;            try {                if (-1 == name.indexOf(&#39;.&#39;)) {                    //创建android源码中的View，即那些在xml中不需要包名就可以定义并使用的View。                    view = onCreateView(context, parent, name, attrs);                } else {                    //创建非android源码中的View，如自定义View或者第三方库的View。                    view = createView(context, name, null, attrs);                }            } finally {                mConstructorArgs[0] = lastContext;            }        }        return view;    } catch (InflateException e) {        throw e;    } catch (ClassNotFoundException e) {        final InflateException ie = new InflateException(            getParserStateDescription(context, attrs)            + &quot;: Error inflating class &quot; + name, e);        ie.setStackTrace(EMPTY_STACK_TRACE);        throw ie;    } catch (Exception e) {        final InflateException ie = new InflateException(            getParserStateDescription(context, attrs)            + &quot;: Error inflating class &quot; + name, e);        ie.setStackTrace(EMPTY_STACK_TRACE);        throw ie;    }}</code></pre><p>可以看到创建View的两个语句：</p><p>通过这个if的判断，我们大致可以猜到这个是用来判断加载的是源码View还是非源码的View。</p><pre><code class="java">if (-1 == name.indexOf(&#39;.&#39;)) {    //创建android源码中的View，即那些在xml中不需要包名就可以定义并使用的View。    view = onCreateView(context, parent, name, attrs);} else {    //创建非android源码中的View，如自定义View或者第三方库的View。    view = createView(context, name, null, attrs);}</code></pre><p>这两个方法内部都调用的是一个方法，我们看下两个方法是如何调用的，第一个：</p><pre><code class="java">public View onCreateView(@NonNull Context viewContext, @Nullable View parent,        @NonNull String name, @Nullable AttributeSet attrs)        throws ClassNotFoundException {    return onCreateView(parent, name, attrs);}//-----往下调用protected View onCreateView(View parent, String name, AttributeSet attrs)        throws ClassNotFoundException {    return onCreateView(name, attrs);}//-----往下调用protected View onCreateView(String name, AttributeSet attrs)        throws ClassNotFoundException {    //注意这里，将参数为String prefix的位置赋值成了：android.view，即为源码的view拼接上前缀。为的是后续能    //正确通过反射调用到该View类的构造方法。需要全路径名。    return createView(name, &quot;android.view.&quot;, attrs);}//-----往下调用public final View createView(String name, String prefix, AttributeSet attrs)        throws ClassNotFoundException, InflateException {    Context context = (Context) mConstructorArgs[0];    if (context == null) {        context = mContext;    }    return createView(context, name, prefix, attrs);}</code></pre><p>第二个方法的内部调用和第一个方法的内部调用，最终都调用到了方法：</p><pre><code class="java">public final View createView(@NonNull Context viewContext, @NonNull String name,                             @Nullable String prefix, @Nullable AttributeSet attrs)    throws ClassNotFoundException, InflateException {    Objects.requireNonNull(viewContext);    Objects.requireNonNull(name);    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);    if (constructor != null &amp;&amp; !verifyClassLoader(constructor)) {        constructor = null;        sConstructorMap.remove(name);    }    Class&lt;? extends View&gt; clazz = null;    try {        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);        if (constructor == null) {            // Class not found in the cache, see if it&#39;s real, and try to add it            clazz = Class.forName(prefix != null ? (prefix + name) : name, false,                                  mContext.getClassLoader()).asSubclass(View.class);            if (mFilter != null &amp;&amp; clazz != null) {                boolean allowed = mFilter.onLoadClass(clazz);                if (!allowed) {                    failNotAllowed(name, prefix, viewContext, attrs);                }            }            constructor = clazz.getConstructor(mConstructorSignature);            constructor.setAccessible(true);            sConstructorMap.put(name, constructor);        } else {            // If we have a filter, apply it to cached constructor            if (mFilter != null) {                // Have we seen this name before?                Boolean allowedState = mFilterMap.get(name);                if (allowedState == null) {                    // New class -- remember whether it is allowed                    clazz = Class.forName(prefix != null ? (prefix + name) : name, false,                                          mContext.getClassLoader()).asSubclass(View.class);                    boolean allowed = clazz != null &amp;&amp; mFilter.onLoadClass(clazz);                    mFilterMap.put(name, allowed);                    if (!allowed) {                        failNotAllowed(name, prefix, viewContext, attrs);                    }                } else if (allowedState.equals(Boolean.FALSE)) {                    failNotAllowed(name, prefix, viewContext, attrs);                }            }        }        //上面的代码做的事情是：判空和对反射构造器做缓存，方便下次再使用。        //主要看下面调用的方法：        //为View类的反射方法赋值参数，这里可以看到赋值了两个参数：Context和AttributeSet        Object lastContext = mConstructorArgs[0];        mConstructorArgs[0] = viewContext;        Object[] args = mConstructorArgs;        args[1] = attrs;        try {            //传入参数，调用反射并创建View对象            final View view = constructor.newInstance(args);            if (view instanceof ViewStub) {                // Use the same context when inflating ViewStub later.                final ViewStub viewStub = (ViewStub) view;                viewStub.setLayoutInflater(cloneInContext((Context) args[0]));            }            return view;        } finally {            mConstructorArgs[0] = lastContext;        }        //后续为异常处理    } catch (NoSuchMethodException e) {        final InflateException ie = new InflateException(            getParserStateDescription(viewContext, attrs)            + &quot;: Error inflating class &quot; + (prefix != null ? (prefix + name) : name), e);        ie.setStackTrace(EMPTY_STACK_TRACE);        throw ie;    } catch (ClassCastException e) {        // If loaded class is not a View subclass        final InflateException ie = new InflateException(            getParserStateDescription(viewContext, attrs)            + &quot;: Class is not a View &quot; + (prefix != null ? (prefix + name) : name), e);        ie.setStackTrace(EMPTY_STACK_TRACE);        throw ie;    } catch (ClassNotFoundException e) {        // If loadClass fails, we should propagate the exception.        throw e;    } catch (Exception e) {        final InflateException ie = new InflateException(            getParserStateDescription(viewContext, attrs) + &quot;: Error inflating class &quot;            + (clazz == null ? &quot;&lt;unknown&gt;&quot; : clazz.getName()), e);        ie.setStackTrace(EMPTY_STACK_TRACE);        throw ie;    } finally {        Trace.traceEnd(Trace.TRACE_TAG_VIEW);    }}</code></pre><p>上述源码看50~70行的部分。</p><p>可以看到，通过反射，带上Context和AttributeSet参数，创建了View对象并返回。这里的AttributeSet对象则是LayoutInflater.inflate方法中通过xml解析器创建的。</p><p>因此一个View从xml文件解析并生成View对象到这里就结束了。</p><p>至于后面的View添加到ViewTree，View对提取AttributeSet中的属性（即xml中定义的属性），并根据业务逻辑重写自定义View三大方法，则是自定义View的内容，在此不做拓展。</p><h4 id="1-2-由父View创建子View的LayoutParams"><a href="#1-2-由父View创建子View的LayoutParams" class="headerlink" title="1.2 由父View创建子View的LayoutParams"></a>1.2 由父View创建子View的LayoutParams</h4><p>子View在xml中定义自己的View的属性。<br>在LayoutInflator中，子View的属性被从xml中读取到内存中存为key-value。<br>父View根据子view的key-value属性决定所有的子View的LayoutParams的生成规则。<br>例如必要的宽和高，以及其他该ViewGroup支持的自定义的属性。</p><h3 id="2-举例：RecyclerView中的ViewHolder"><a href="#2-举例：RecyclerView中的ViewHolder" class="headerlink" title="2 举例：RecyclerView中的ViewHolder"></a>2 举例：RecyclerView中的ViewHolder</h3><p>现在来分析在RecyclerView中调用LayoutInflater创建Item View的场景。</p><h4 id="2-1-LinearLayout"><a href="#2-1-LinearLayout" class="headerlink" title="2.1 LinearLayout"></a>2.1 LinearLayout</h4><p>默认的LayoutParams？</p><h4 id="2-2-GridLayout"><a href="#2-2-GridLayout" class="headerlink" title="2.2 GridLayout"></a>2.2 GridLayout</h4><p>默认的LayoutParams？</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>结论：</p><p>图：</p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gradle的properties文件</title>
    <link href="/2020/05/11/Gradle/gradle%E7%9A%84properties%E6%96%87%E4%BB%B6/"/>
    <url>/2020/05/11/Gradle/gradle%E7%9A%84properties%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>我们知道在gradle中可以用 <code>gradle.properties</code>文件来设置属性。一般.properties文件的位置是定义在和<code>build.gradle</code>和<code>settings.gradle</code>同级的目录下。</p><h3 id="1-简单使用"><a href="#1-简单使用" class="headerlink" title="1 简单使用"></a>1 简单使用</h3><p>在<code>gradle.properties</code>中定义一个属性是这样的：</p><pre><code class="groovy">PRO_A=12</code></pre><p>然后在构建脚本里就可以用到这个属性了：</p><pre><code class="groovy">task A(){    doLast{        println(PRO_A)    }}</code></pre><h3 id="2-和ext属性的关系"><a href="#2-和ext属性的关系" class="headerlink" title="2 和ext属性的关系"></a>2 和ext属性的关系</h3><p>首先确定的是，<code>gradle.properties</code>中定义的属性是属定义他的gradle项目的<code>project</code>对象的属性的。</p><p>其次，在gradle文档中，没有说明（或者是我没找到）<code>gradle.properties</code>中的属性在是保存在<code>Project</code>对象的哪个位置的。</p><p>我个人猜测有两种可能：</p><ol><li>通过<code>project.ext</code>属性，保存在这里面。</li><li>直接通过扩展<code>project</code>属性的方式，给<code>project</code>拓展属性。</li></ol><p>这里倾向于前者，因为第二种给<code>project</code>拓展属性的编程方式，通常用来写gradle plugin。</p><h4 id="通过测试验证猜想："><a href="#通过测试验证猜想：" class="headerlink" title="通过测试验证猜想："></a>通过测试验证猜想：</h4><p>测试方法：定义一个属性，然后打印当前项目的ext属性中的所有的属性。从打印结果中就能看到<code>gradle.preperties</code>文件中的属性是否在ext中了。</p><p>定义属性</p><p><code>gradle.properties</code>文件：</p><pre><code class="groovy">PRO_A=I AM PROPERTY A !</code></pre><p><code>build.gradle</code>文件中写一个task测试</p><pre><code class="groovy">task A() {    doLast {        println(PRO_A)        rootProject.extensions.extraProperties.getProperties().forEach { String key, Object value -&gt;            println(&quot;key=$key,value=$value&quot;)        }    }}</code></pre><p>命令行执行：</p><pre><code class="groovy">▶ gradle A&gt; Task :sub:AI AM PROPERTY A !key=PRO_A,value=I AM PROPERTY A !key=kotlin.code.style,value=official</code></pre><p>将<code>Project</code>的ext属性输出的结果中包含了此前定义的属性，说明<code>gradle.properties</code>中的属性会保存在ext变量中。</p><h3 id="3-Project对象的属性的读取顺序和优先级"><a href="#3-Project对象的属性的读取顺序和优先级" class="headerlink" title="3 Project对象的属性的读取顺序和优先级"></a>3 Project对象的属性的读取顺序和优先级</h3><p>分割线中内容全部来自<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project.properties" target="_blank" rel="noopener">gradle文档：Proejct</a></p><hr><p>A project has 5 property ‘scopes’, which it searches for properties. You can access these properties by name in your build file, or by calling the project’s <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:property(java.lang.String)" target="_blank" rel="noopener"><code>Project.property(java.lang.String)</code></a> method. The scopes are:</p><ul><li>The <code>Project</code> object itself. This scope includes any property getters and setters declared by the <code>Project</code> implementation class. For example, <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:rootProject" target="_blank" rel="noopener"><code>Project.getRootProject()</code></a> is accessible as the <code>rootProject</code> property. The properties of this scope are readable or writable depending on the presence of the corresponding getter or setter method.</li><li>The <em>extra</em> properties of the project. Each project maintains a map of extra properties, which can contain any arbitrary name -&gt; value pair. Once defined, the properties of this scope are readable and writable. See <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project.extraproperties" target="_blank" rel="noopener">extra properties</a> for more details.</li><li>The <em>extensions</em> added to the project by the plugins. Each extension is available as a read-only property with the same name as the extension.</li><li>The <em>convention</em> properties added to the project by the plugins. A plugin can add properties and methods to a project through the project’s <a href="https://docs.gradle.org/current/javadoc/org/gradle/api/plugins/Convention.html" target="_blank" rel="noopener"><code>Convention</code></a> object. The properties of this scope may be readable or writable, depending on the convention objects.</li><li>The tasks of the project. A task is accessible by using its name as a property name. The properties of this scope are read-only. For example, a task called <code>compile</code> is accessible as the <code>compile</code> property.</li><li>The extra properties and convention properties are inherited from the project’s parent, recursively up to the root project. The properties of this scope are read-only.</li></ul><p>When reading a property, the project searches the above scopes in order, and returns the value from the first scope it finds the property in. If not found, an exception is thrown. See <a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:property(java.lang.String)" target="_blank" rel="noopener"><code>Project.property(java.lang.String)</code></a> for more details.</p><p>When writing a property, the project searches the above scopes in order, and sets the property in the first scope it finds the property in. If not found, an exception is thrown. See [<code>Project.setProperty(java.lang.String, java.lang.Object)</code>](<a href="https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:setProperty" target="_blank" rel="noopener">https://docs.gradle.org/current/dsl/org.gradle.api.Project.html#org.gradle.api.Project:setProperty</a>(java.lang.String, java.lang.Object)) for more details.</p><hr><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><ol><li><code>gradle.properties</code>文件中定义的属性在gradle脚本执行时保存在<code>project.ext</code>属性中。</li><li>gradle脚本读写属性是有顺序的，他会从5个区域里读写，先读到哪个就先用哪个，读取的优先级为：<ol><li>project本身的属性。</li><li>project的extra（即project.ext）属性中的map中保存的键值对。</li><li>被gradle plugin添加的属性，即project.extensions属性。</li><li>被gradle plugin添加的convention属性。（没用过也没了解过这个属性）</li><li>project中的task的名字，也作为project的属性。</li><li>project从他的父project继承下来的ext和convention属性，会一直递归到rootProject。</li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Gradle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android调试ViewTree工具.md</title>
    <link href="/2020/05/05/%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/Android%E8%B0%83%E8%AF%95View%E5%B7%A5%E5%85%B7-md/"/>
    <url>/2020/05/05/%E4%B8%AA%E4%BA%BA%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/Android%E8%B0%83%E8%AF%95View%E5%B7%A5%E5%85%B7-md/</url>
    
    <content type="html"><![CDATA[<h3 id="AndroidStudio自带的LayoutInspector"><a href="#AndroidStudio自带的LayoutInspector" class="headerlink" title="AndroidStudio自带的LayoutInspector"></a>AndroidStudio自带的LayoutInspector</h3><p>在Android开发的时候，我们在调试复杂的UI界面上的问题的时候，有时希望借助AndroidStudio自带的调试工具：LayoutInspector来查看当前界面的View Tree。</p><p><img src="https://s1.ax1x.com/2020/05/05/YiUNAH.png" srcset="/img/loading.gif" alt="YiUNAH.png"></p><p>没有遇到问题的话，他能出现这样的调试效果：</p><p><a href="https://imgchr.com/i/YiUDjf" target="_blank" rel="noopener"><img src="https://s1.ax1x.com/2020/05/05/YiUDjf.png" srcset="/img/loading.gif" alt="YiUDjf.png"></a></p><h3 id="调试UI遇到的问题"><a href="#调试UI遇到的问题" class="headerlink" title="调试UI遇到的问题"></a>调试UI遇到的问题</h3><p>但是，当你的Activity的界面非常复杂，例如存在大量的View，存在视频，存在View动画等情况。这时这个调试工具就不生效了。</p><p>这时会遇到：</p><p><img src="https://s1.ax1x.com/2020/05/05/YiGoRK.png" srcset="/img/loading.gif" alt=""></p><p>Error obtaining view hierarchy : There was a timeout error capturing the layout data from the devices.</p><p>The device may be too slow , the captured view may be too complex, or the view may contain animations.</p><p>Please retry with a simplified view and ensure the device is responsive.</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>去代码里找答案，去代码里找线索，并在关键的代码行中添加调试日志，通过日志来调试和解决问题。</li><li>用别的View tree调试工具。</li></ol><h3 id="FastViewTree"><a href="#FastViewTree" class="headerlink" title="FastViewTree"></a>FastViewTree</h3><p>用上述的第一种方式，去代码里加调试日志或者阅读代码能不能解决问题？能。但是很耗时。比如有一种情况是：你去调试或者接管他人写的代码中出现的问题，或者是你自己写的比较久远的问题，去阅读代码来模拟想象出UI表现，是要花比较长的时间的。</p><p>我没有找到已经发出来的其他合适的调试工具能够满足我的需要：打印view tree，打印每个view的可见度和宽高。</p><p>因此我自己写了一个满足上述需求的调试工具：<a href="https://github.com/HWilliamgo/FastViewTree" target="_blank" rel="noopener">FastViewTree</a></p><p>代码是用kotlin写的，只有一个文件，非常简单。不过这个工具很实用。欢迎大家提意见和start 。</p>]]></content>
    
    
    <categories>
      
      <category>个人开源项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>开源</tag>
      
      <tag>调试工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android视图调试技巧</title>
    <link href="/2020/04/14/View/Android%E8%A7%86%E5%9B%BE%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <url>/2020/04/14/View/Android%E8%A7%86%E5%9B%BE%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="1-追踪某个View的方法调用。"><a href="#1-追踪某个View的方法调用。" class="headerlink" title="1. 追踪某个View的方法调用。"></a>1. 追踪某个View的方法调用。</h3><p>如果某个View的尺寸错乱，有可能是这个View的关于设置尺寸的某个方法在某个你没有找到的地方被调用了。</p><p>例如<code>setLayoutParams()</code>方法被意外地调用了。</p><p>如何找出调用堆栈？</p><p>需要重写<code>setLayoutParams()</code>方法，然后筛选传递进来的错误的参数，然后在重写了的方法中加个断点，然后开启debug，就能找出调用处了。</p><p>对于别的方法，例如<code>setVisibility()</code>。都采用类似的方式，就可以马上排查出错误的地方的堆栈从而解决问题。</p><h3 id="通过view-tree来排查问题。"><a href="#通过view-tree来排查问题。" class="headerlink" title="通过view tree来排查问题。"></a>通过view tree来排查问题。</h3>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo搭建博客并将简书文章迁移</title>
    <link href="/2020/03/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%B0%86%E7%AE%80%E4%B9%A6%E6%96%87%E7%AB%A0%E8%BF%81%E7%A7%BB/"/>
    <url>/2020/03/29/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B9%B6%E5%B0%86%E7%AE%80%E4%B9%A6%E6%96%87%E7%AB%A0%E8%BF%81%E7%A7%BB/</url>
    
    <content type="html"><![CDATA[<p>在经过多次的考虑后，我还是打算将所有的博客的数据由自己维护。因此找了一种比较简单的方式：hexo + github pages</p><h3 id="迁移博客的原因"><a href="#迁移博客的原因" class="headerlink" title="迁移博客的原因"></a>迁移博客的原因</h3><ol><li>简书的博客没有文章的导航栏，我每次用Markdown写文章发布后，简书不会自带文章大纲，无法检索。</li><li>简书的曾经被叫停过一次，在那之后，简书的访问速度变慢了，我担心后面简书会挂掉，我的文章拿不出来。</li><li>简书的文章类型繁多，不是技术型的平台。当然我也看了其他很优秀的技术型平台，例如掘金和语雀。但是掘金不支持文章导出，语雀导出的文章貌似只有他们自家的语雀平台能够二次使用，不是Markdown类型的。因此放弃在第三方平台写博客了。</li><li>自己搭建博客，自己选主题和功能，自己保存数据，一劳永逸。</li></ol><h3 id="迁移博客的过程"><a href="#迁移博客的过程" class="headerlink" title="迁移博客的过程"></a>迁移博客的过程</h3><ol><li>参考<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a>，从0到1，并没有什么难度。</li><li>选主题：<a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="noopener">fluid</a></li><li>上线博客</li><li>迁移文章（这是最麻烦最重要的一步）</li></ol><p>这里打算就第四点，迁移文章，说一说我遇到的问题：</p><h4 id="1-文章根据目录分类"><a href="#1-文章根据目录分类" class="headerlink" title="1. 文章根据目录分类"></a>1. 文章根据目录分类</h4><p>首先，简书的文章下载下来是按照目录来划分分类的。而Hexo是不支持目录划分分类的，hexo文章的分类只能在对应文章的front-matter里面标记上这篇文章的category是什么才行。</p><p>所幸有这么一个插件能解决这个问题：<a href="https://github.com/xu-song/hexo-auto-category" target="_blank" rel="noopener">hexo-auto-category</a></p><h4 id="2-文章没有生产日期"><a href="#2-文章没有生产日期" class="headerlink" title="2. 文章没有生产日期"></a>2. 文章没有生产日期</h4><p>简书的文章下载下来的时候，除了文章标题和内容外，没有附带任何元数据。例如文章的创建日期、观看数、点赞数。</p><p>文章的观看数和点赞数这个东西，在hexo里面我不太清楚如何去发挥作用，能带走的就只有文章的创建日期了。不过创建日期他也没有给你，但是没有文章创建日期的话，所有的文章都会按照创建日期来显示，这显然很不合理。</p><p>因此我想到用JSoup去爬取简书的数据，看看能不能把我对应的文章的日期爬下来。</p><h4 id="3-给每篇文章附上front-matter"><a href="#3-给每篇文章附上front-matter" class="headerlink" title="3. 给每篇文章附上front-matter"></a>3. 给每篇文章附上front-matter</h4><p>日期爬下来之后，还要给每篇文章附上<a href="https://hexo.io/zh-cn/docs/front-matter" target="_blank" rel="noopener">front-matter</a>。</p><p>我有200多篇博客，不可能我自己一篇一篇手动去搞，因此还得写个脚本，往文章顶部插入front-matter。</p><p>脚本不难，用Kotlin写的，难的是使用JSoup和调试的过程。代码如下：</p><pre><code class="kotlin">import org.json.JSONArrayimport org.json.JSONObjectimport org.jsoup.Jsoupimport java.io.Fileimport java.io.FileReaderimport java.io.RandomAccessFileimport java.lang.RuntimeException/** * author: hwj * description: */fun main() {    val allEssay = takeTimeFromJianShuByJSoup()    addHeadForMD(allEssay)}fun takeTimeFromJianShuByJSoup(): AllEssay {    //https://www.jianshu.com/nb/16737585?order_by=added_at&amp;page=2    val categoryIdPairList = getCategoryAndId()    //请求每一个分类下的每一篇文章的 标题和时间，并绑定。    val allEssay = AllEssay()    categoryIdPairList.forEach {        val categoryId = it.id        val categoryName = it.name        //page 从1开始计数,遍历当前category下的所有的文章        var currentPage = 1        var tmpList = parseByJsoup(categoryId, currentPage, categoryName)        while (tmpList.isNotEmpty()) {            currentPage++            tmpList.forEach { essay -&gt;                allEssay.put(categoryName, essay)            }            tmpList = parseByJsoup(categoryId, currentPage, categoryName)        }    }    return allEssay}fun parseByJsoup(id: String, page: Int, categoryName: String): List&lt;Essay&gt; {    println(&quot;======类别：$categoryName&quot;)    val result: MutableList&lt;Essay&gt; = ArrayList()    val url = &quot;https://www.jianshu.com/nb&quot;    val finalUrl = &quot;$url/$id?order_by=added_at&amp;page=$page&quot;    val document = Jsoup.connect(finalUrl).get()    document.getElementsByTag(&quot;li&quot;).forEach { li -&gt;        val div = li.getElementsByTag(&quot;div&quot;)        div.forEach { eachDiv -&gt;            if (eachDiv.attr(&quot;class&quot;).trim() == &quot;content&quot;) {                val title = eachDiv.getElementsByTag(&quot;a&quot;).first().text()                var time = eachDiv                    .getElementsByTag(&quot;div&quot;).first()                    .getElementsByTag(&quot;span&quot;).filter {                        it.attr(&quot;class&quot;).trim() == &quot;time&quot;                    }.first().attr(&quot;data-shared-at&quot;)                time = timeFormatConvert(time)                println(&quot;标题：$title 创建日期：$time&quot;)                result.add(Essay(title, time))            }        }    }    return result}fun getCategoryAndId(): List&lt;CategoryIdPair&gt; {    val jsonFilePath = &quot;/Users/HWilliam/IdeaProjects/test/src/main/kotlin/category.json&quot;    val rootJson = JSONObject(File(jsonFilePath).readText())    val arrays = rootJson.getJSONArray(&quot;notebooks&quot;)    //&lt;id,CategoryName&gt;    val list: MutableList&lt;CategoryIdPair&gt; = ArrayList()    for (i in 0 until arrays.length()) {        val id = arrays.getJSONObject(i).getInt(&quot;id&quot;).toString()        val name = arrays.getJSONObject(i).getString(&quot;name&quot;)        list.add(CategoryIdPair(id, name))    }    return list}fun timeFormatConvert(i: String): String {    val input = i.replace(&quot;-&quot;, &quot;/&quot;)    val date = input.split(&quot;T&quot;)[0]    val time = input.split(&quot;T&quot;)[1].split(&quot;+&quot;).first()    return &quot;$date $time&quot;}fun addHeadForMD(allEssay: AllEssay) {    val essayParentDir = &quot;/Users/HWilliam/IdeaProjects/test/src/main/kotlin/_posts&quot;    val essayParentDirFile = File(essayParentDir)    essayParentDirFile.listFiles()?.forEach {        //it --&gt; 目录文件        println(it.name)        it.listFiles()?.forEach { oneMDFile -&gt;            //文件名字            val realFileNameOfMD = oneMDFile.name            val fileNameWithoutMD = realFileNameOfMD.substringBefore(&quot;.&quot;)            val tmpFileNameOfFinalMDFile = realFileNameOfMD + &quot;tmp&quot;            val date = allEssay.findTime(it.name, fileNameWithoutMD)            val headerToAppend = &quot;---\ntitle: ${fileNameWithoutMD}\ndate: $date\n---\n\n&quot;            val resultFile = File(it, tmpFileNameOfFinalMDFile)            val randomAccessFileOfResult = RandomAccessFile(resultFile, &quot;rw&quot;)            //写header            randomAccessFileOfResult.write(headerToAppend.toByteArray())            //将所有原文件的内容追加进去            val randomAccessFileOfTarget = RandomAccessFile(oneMDFile, &quot;rw&quot;)            val buffer: ByteArray = ByteArray(10240)            while (randomAccessFileOfTarget.read(buffer) != -1) {                randomAccessFileOfResult.write(buffer)            }            randomAccessFileOfResult.close()            randomAccessFileOfTarget.close()            oneMDFile.delete()            resultFile.renameTo(oneMDFile)        }    }}class CategoryIdPair(val id: String, val name: String)class Essay(val title: String, val time: String)class AllEssay() {    // &lt;Category , essayList&gt;    val map: HashMap&lt;String, MutableList&lt;Essay&gt;&gt; = HashMap()    fun put(category: String, essay: Essay) {        if (!map.containsKey(category)) {            map.put(category, ArrayList())        }        map.get(category)?.add(essay)    }    fun findTime(category: String, essayName: String): String {        var failEssayName = &quot;&quot;        map.get(category)?.forEach {            if (it.title == essayName) {                return it.time            } else {                val tmpTitle = it.title                val replaceEnd = tmpTitle                    .replace(&quot;.&quot;, &quot;-&quot;)                    .replace(&quot;?&quot;, &quot;-&quot;)                    .replace(&quot;？&quot;, &quot;-&quot;)                    .replace(&quot;/&quot;, &quot;-&quot;)                    .replace(&quot;。&quot;, &quot;-&quot;)                    .replace(&quot; &quot;, &quot;-&quot;)                if (replaceEnd == essayName) {                    return it.time                } else {//                    println(&quot;文章无时间：$category -&gt; $essayName ， 真实name=${it.title}&quot;)                }            }        }//        throw RuntimeException(&quot;没有找到时间 $category, $essayName&quot;)        println(&quot;文章无时间：$category -&gt; $essayName ， 真实name=${failEssayName}&quot;)        return &quot;&quot;    }}</code></pre><h4 id="4-给博客选定一些图片和样式，以及集成评论功能。"><a href="#4-给博客选定一些图片和样式，以及集成评论功能。" class="headerlink" title="4. 给博客选定一些图片和样式，以及集成评论功能。"></a>4. 给博客选定一些图片和样式，以及集成评论功能。</h4><h3 id="迁移博客的结果"><a href="#迁移博客的结果" class="headerlink" title="迁移博客的结果"></a>迁移博客的结果</h3><p>博客地址：<a href="https://hwilliamgo.github.io/" target="_blank" rel="noopener">https://hwilliamgo.github.io/</a></p><p>迁移博客的工作告一段落，剩下的是为博客添加一些个性化的样式之类的。</p><p>此外，由于github访问速度过慢的原因，在考虑是否将博客托管到国内的平台，例如gitee pages。不过这是后话了。</p>]]></content>
    
    
    <categories>
      
      <category>搭建博客相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ffmpeg常用命令</title>
    <link href="/2020/03/21/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2020/03/21/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/ffmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>用<url>来表示视频文件的地址。</p><hr><h3 id="查看关键帧数据："><a href="#查看关键帧数据：" class="headerlink" title="查看关键帧数据："></a>查看关键帧数据：</h3><pre><code class="bash">ffprobe -show_frames -select_streams v:0 -print_format csv &lt;url&gt; | grep &quot;,I,&quot;</code></pre><h3 id="查看流信息："><a href="#查看流信息：" class="headerlink" title="查看流信息："></a>查看流信息：</h3><pre><code class="bash">ffprobe -v quiet -print_format json -show_format -show_streams &lt;url&gt;</code></pre><h3 id="查看分辨率："><a href="#查看分辨率：" class="headerlink" title="查看分辨率："></a>查看分辨率：</h3><pre><code class="bash">ffprobe -v debug -select_streams v -skip_frame nokey -count_frames &lt;url&gt; 2&gt;&amp;1|grep Reinit</code></pre><h3 id="查看每一帧的音频数据："><a href="#查看每一帧的音频数据：" class="headerlink" title="查看每一帧的音频数据："></a>查看每一帧的音频数据：</h3><pre><code class="bash">ffprobe -show_frames -select_streams a -print_format csv &lt;url&gt;</code></pre><h3 id="提取视频的h264码流"><a href="#提取视频的h264码流" class="headerlink" title="提取视频的h264码流"></a>提取视频的h264码流</h3><pre><code class="bash">ffmpeg -i &lt;url&gt; -codec copy -f h264 video.h264</code></pre><h3 id="压缩视频"><a href="#压缩视频" class="headerlink" title="压缩视频"></a>压缩视频</h3><h4 id="1-通过指定视频码率，如400kb-s"><a href="#1-通过指定视频码率，如400kb-s" class="headerlink" title="1. 通过指定视频码率，如400kb/s"></a>1. 通过指定视频码率，如400kb/s</h4><p>如果想要压缩出的视频达到一个指定的文件大小，那么需要进行一些计算。</p><p>视频文件的大小(MB)=视频码率(kb/s) * 视频时长(s) / 8(bit)/1024</p><p>反向推一下就知道要设置多少的视频输出码率了。</p><pre><code class="bash">ffmpeg -i &lt;url&gt; -b:v 400k output.mp4</code></pre><h3 id="查看拉流ip地址"><a href="#查看拉流ip地址" class="headerlink" title="查看拉流ip地址"></a>查看拉流ip地址</h3><pre><code class="shell">ffmpeg -v debug|verbose -i url</code></pre><p>或</p><pre><code class="shell">ffplay -v debug|verbose url</code></pre><p> 这里的<code>-v</code>表示的其实是<code>-loglevel</code>的意思，用<code>-loglevel</code>代替也可以。</p><p>其中，debug会将所有的日志都输出。</p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>理解ijkplayer（六）Vout、Aout、FFPipeLine</title>
    <link href="/2020/03/21/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E5%85%AD%EF%BC%89Vout%E3%80%81Aout%E3%80%81FFPipeLine/"/>
    <url>/2020/03/21/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E5%85%AD%EF%BC%89Vout%E3%80%81Aout%E3%80%81FFPipeLine/</url>
    
    <content type="html"><![CDATA[<pre><code class="c">// ijkmedia/ijkplayer/ff_ffplay_def.htypedef struct FFPlayer {        //...    SDL_Aout *aout;    SDL_Vout *vout;    struct IJKFF_Pipeline *pipeline;    struct IJKFF_Pipenode *node_vdec;      //...}FFPlayer;</code></pre><p>这篇文章的内容：</p><p>分析<code>FFPlayer</code>结构体中的<code>SDL_Aout</code>、<code>SDL_Vout</code>、<code>IJKFF_Pipeline</code>和<code>IJKFF_Pipenode</code>的作用</p><p>此外，这四个结构体，我认为是为了实现多态，详见IBM教程：<a href="https://www.ibm.com/developerworks/cn/linux/l-cn-cpolym/index.html" target="_blank" rel="noopener">技巧：用 C 语言实现程序的多态性</a></p><p>而这里面还有用到<code>SDL_Vout_Opaque</code>这类的opaque单词的结构体和指针，这是为了实现封装和对外隐藏细节。</p><p>不得不说，ijkplayer用c语言也很好地体现了面向对象的思想。</p><h3 id="SDL-Vout"><a href="#SDL-Vout" class="headerlink" title="SDL_Vout"></a>SDL_Vout</h3><h4 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1. 结构体"></a>1. 结构体</h4><h5 id="1-1-SDL-Vout"><a href="#1-1-SDL-Vout" class="headerlink" title="1.1 SDL_Vout"></a>1.1 SDL_Vout</h5><pre><code class="c">//    ijkmedia/ijksdl/ijksdl_vout.hstruct SDL_Vout {    SDL_mutex *mutex;    SDL_Class       *opaque_class;    SDL_Vout_Opaque *opaque;    //创建图层，即SDL_VoutOverlay    SDL_VoutOverlay *(*create_overlay)(int width, int height, int frame_format, SDL_Vout *vout);    //释放    void (*free_l)(SDL_Vout *vout);    //展示图层    int (*display_overlay)(SDL_Vout *vout, SDL_VoutOverlay *overlay);    //图层格式    Uint32 overlay_format;};</code></pre><h5 id="1-2-SDL-Vout-Opaque"><a href="#1-2-SDL-Vout-Opaque" class="headerlink" title="1.2 SDL_Vout_Opaque"></a>1.2 SDL_Vout_Opaque</h5><p>opaque类似于Java中的内部类，用来向调用者屏蔽该类的内部逻辑</p><p>看下这个<code>SDL_Vout_Opaque</code>的定义：</p><p>用<code>typedef</code>定义了一个抽象，那么他的实现在哪里？</p><pre><code class="c">//    ijkmedia/ijksdl/ijksdl_vout.h//这里引用的是ffmepg后缀的这个头文件，因此用的是软件的方式去创建的SDL_VoutOverlay_Opaque#include &quot;ffmpeg/ijksdl_inc_ffmpeg.h&quot;//...typedef struct SDL_Vout_Opaque SDL_Vout_Opaque;//...</code></pre><p>他的实现在两处定义了，分别在硬解和软解的时候使用</p><pre><code class="c">//    硬解//    ijkmedia/ijksdl/android/ijksdl_vout_overlay_android_mediacodec.ctypedef struct SDL_VoutOverlay_Opaque {    SDL_mutex *mutex;    SDL_Vout                   *vout;    SDL_AMediaCodec            *acodec;    SDL_AMediaCodecBufferProxy *buffer_proxy;    Uint16 pitches[AV_NUM_DATA_POINTERS];    Uint8 *pixels[AV_NUM_DATA_POINTERS];} SDL_VoutOverlay_Opaque;</code></pre><pre><code class="c">// 软解//    ijkmedia/ijksdl/ffmpeg/ijksdl_vout_overlay_ffmpeg.cstruct SDL_VoutOverlay_Opaque {    SDL_mutex *mutex;    AVFrame *managed_frame;    AVBufferRef *frame_buffer;    int planes;    AVFrame *linked_frame;    Uint16 pitches[AV_NUM_DATA_POINTERS];    Uint8 *pixels[AV_NUM_DATA_POINTERS];    int no_neon_warned;    struct SwsContext *img_convert_ctx;    int sws_flags;};</code></pre><p>而实际上硬解的那个是不会使用的，为什么？因为定义<code>SDL_VoutOverlay_Opaque</code>引用的头文件是<code>ffmpeg/ijksdl_inc_ffmpeg.h</code></p><h5 id="1-3-SDL-Class"><a href="#1-3-SDL-Class" class="headerlink" title="1.3 SDL_Class"></a>1.3 SDL_Class</h5><p>暂时也不清楚这个是做什么的，只保存了一个字符串而已。</p><pre><code class="c">typedef struct SDL_Class {    const char *name;} SDL_Class;</code></pre><h5 id="1-4-SDL-VoutOverlay"><a href="#1-4-SDL-VoutOverlay" class="headerlink" title="1.4 SDL_VoutOverlay"></a>1.4 SDL_VoutOverlay</h5><pre><code class="c">struct SDL_VoutOverlay {    int w; /**&lt; Read-only */    int h; /**&lt; Read-only */    Uint32 format; /**&lt; Read-only */    int planes; /**&lt; Read-only */    Uint16 *pitches; /**&lt; in bytes, Read-only */    Uint8 **pixels; /**&lt; Read-write */    int is_private;    int sar_num;    int sar_den;    SDL_Class               *opaque_class;    SDL_VoutOverlay_Opaque  *opaque;    void    (*free_l)(SDL_VoutOverlay *overlay);    int     (*lock)(SDL_VoutOverlay *overlay);    int     (*unlock)(SDL_VoutOverlay *overlay);    void    (*unref)(SDL_VoutOverlay *overlay);    int     (*func_fill_frame)(SDL_VoutOverlay *overlay, const AVFrame *frame);};</code></pre><h5 id="1-5-SDL-VoutOverlay-Opaque"><a href="#1-5-SDL-VoutOverlay-Opaque" class="headerlink" title="1.5 SDL_VoutOverlay_Opaque"></a>1.5 SDL_VoutOverlay_Opaque</h5><pre><code class="c">#include &quot;ffmpeg/ijksdl_inc_ffmpeg.h&quot;typedef struct SDL_VoutOverlay_Opaque SDL_VoutOverlay_Opaque;</code></pre><p>软解：</p><pre><code class="c">//    ijkmedia/ijksdl/ffmpeg/ijksdl_vout_overlay_ffmpeg.cstruct SDL_VoutOverlay_Opaque {    SDL_mutex *mutex;    AVFrame *managed_frame;    AVBufferRef *frame_buffer;    int planes;    AVFrame *linked_frame;    Uint16 pitches[AV_NUM_DATA_POINTERS];    Uint8 *pixels[AV_NUM_DATA_POINTERS];    int no_neon_warned;    struct SwsContext *img_convert_ctx;    int sws_flags;};</code></pre><p>硬解：</p><pre><code class="c">typedef struct SDL_VoutOverlay_Opaque {    SDL_mutex *mutex;    SDL_Vout                   *vout;    SDL_AMediaCodec            *acodec;    SDL_AMediaCodecBufferProxy *buffer_proxy;    Uint16 pitches[AV_NUM_DATA_POINTERS];    Uint8 *pixels[AV_NUM_DATA_POINTERS];} SDL_VoutOverlay_Opaque;</code></pre><p>同样的，这里是用的软解。</p><h4 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h4><h4 id="3-使用"><a href="#3-使用" class="headerlink" title="3. 使用"></a>3. 使用</h4><pre><code class="c">IjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*)){    //创建IjkMediaPlayer    IjkMediaPlayer *mp = ijkmp_create(msg_loop);    if (!mp)        goto fail;    //创建视频输出设备，会根据根据硬解还是软件，硬解用MediaCodec创建，软解用FFmpeg创建mp-&gt;ffplayer-&gt;vout = SDL_VoutAndroid_CreateForAndroidSurface();    if (!mp-&gt;ffplayer-&gt;vout)        goto fail;    //创建管道    mp-&gt;ffplayer-&gt;pipeline = ffpipeline_create_from_android(mp-&gt;ffplayer);    if (!mp-&gt;ffplayer-&gt;pipeline)        goto fail;    //将创建的视频输出设备vout，赋值到ffplayer-&gt;pipeline中    ffpipeline_set_vout(mp-&gt;ffplayer-&gt;pipeline, mp-&gt;ffplayer-&gt;vout);    return mp;fail:    ijkmp_dec_ref_p(&amp;mp);    return NULL;}</code></pre><p><code>mp-&gt;ffplayer-&gt;vout = SDL_VoutAndroid_CreateForAndroidSurface();</code></p><pre><code class="c">SDL_Vout *SDL_VoutAndroid_CreateForAndroidSurface(){    return SDL_VoutAndroid_CreateForANativeWindow();}</code></pre><pre><code class="c">SDL_Vout *SDL_VoutAndroid_CreateForANativeWindow(){    //创建SDL_Vout    SDL_Vout *vout = SDL_Vout_CreateInternal(sizeof(SDL_Vout_Opaque));    if (!vout)        return NULL;    SDL_Vout_Opaque *opaque = vout-&gt;opaque;    opaque-&gt;native_window = NULL;    if (ISDL_Array__init(&amp;opaque-&gt;overlay_manager, 32))        goto fail;    if (ISDL_Array__init(&amp;opaque-&gt;overlay_pool, 32))        goto fail;    //创建egl    opaque-&gt;egl = IJK_EGL_create();    if (!opaque-&gt;egl)        goto fail;    //为vout的函数赋值    vout-&gt;opaque_class    = &amp;g_nativewindow_class;    vout-&gt;create_overlay  = func_create_overlay;    vout-&gt;free_l          = func_free_l;    vout-&gt;display_overlay = func_display_overlay;    return vout;fail:    func_free_l(vout);    return NULL;}</code></pre><pre><code class="c">inline static SDL_Vout *SDL_Vout_CreateInternal(size_t opaque_size){    //分配Vout内存    SDL_Vout *vout = (SDL_Vout*) calloc(1, sizeof(SDL_Vout));    if (!vout)        return NULL;    //分配Opaue内存    vout-&gt;opaque = calloc(1, opaque_size);    if (!vout-&gt;opaque) {        free(vout);        return NULL;    }    //创建互斥锁    vout-&gt;mutex = SDL_CreateMutex();    if (vout-&gt;mutex == NULL) {        free(vout-&gt;opaque);        free(vout);        return NULL;    }    return vout;}</code></pre><p>接下来一一看下vout的3个函数在这里被赋值的函数</p><pre><code class="c">vout-&gt;create_overlay  = func_create_overlay;vout-&gt;free_l          = func_free_l;vout-&gt;display_overlay = func_display_overlay;</code></pre><pre><code class="c">static SDL_VoutOverlay *func_create_overlay(int width, int height, int frame_format, SDL_Vout *vout){    SDL_LockMutex(vout-&gt;mutex);      //创建SDL_VoutOverlay    SDL_VoutOverlay *overlay = func_create_overlay_l(width, height, frame_format, vout);    SDL_UnlockMutex(vout-&gt;mutex);    return overlay;}</code></pre><pre><code class="c">static SDL_VoutOverlay *func_create_overlay_l(int width, int height, int frame_format, SDL_Vout *vout){    switch (frame_format) {    case IJK_AV_PIX_FMT__ANDROID_MEDIACODEC:        //如果帧的格式是IJK_AV_PIX_FMT__ANDROID_MEDIACODEC，就用硬解创建        return SDL_VoutAMediaCodec_CreateOverlay(width, height, vout);    default:                //否则用软解创建        return SDL_VoutFFmpeg_CreateOverlay(width, height, frame_format, vout);    }}</code></pre><h3 id="SDL-Aout"><a href="#SDL-Aout" class="headerlink" title="SDL_Aout"></a>SDL_Aout</h3><h4 id="1-结构体-1"><a href="#1-结构体-1" class="headerlink" title="1. 结构体"></a>1. 结构体</h4><pre><code class="c">typedef struct SDL_Aout SDL_Aout;struct SDL_Aout {    SDL_mutex *mutex;    double     minimal_latency_seconds;    SDL_Class       *opaque_class;    SDL_Aout_Opaque *opaque;    void (*free_l)(SDL_Aout *vout);    int (*open_audio)(SDL_Aout *aout, const SDL_AudioSpec *desired, SDL_AudioSpec *obtained);    void (*pause_audio)(SDL_Aout *aout, int pause_on);    void (*flush_audio)(SDL_Aout *aout);    void (*set_volume)(SDL_Aout *aout, float left, float right);    void (*close_audio)(SDL_Aout *aout);    double (*func_get_latency_seconds)(SDL_Aout *aout);    void   (*func_set_default_latency_seconds)(SDL_Aout *aout, double latency);    // optional    void   (*func_set_playback_rate)(SDL_Aout *aout, float playbackRate);    void   (*func_set_playback_volume)(SDL_Aout *aout, float playbackVolume);    int    (*func_get_audio_persecond_callbacks)(SDL_Aout *aout);    // Android only    int    (*func_get_audio_session_id)(SDL_Aout *aout);};</code></pre><h4 id="2-初始化-1"><a href="#2-初始化-1" class="headerlink" title="2. 初始化"></a>2. 初始化</h4><p>在<code>ffp_preapare_async_l()函数中</code></p><pre><code class="c">int ffp_prepare_async_l(FFPlayer *ffp, const char *file_name){    assert(ffp);    assert(!ffp-&gt;is);    assert(file_name);    //针对rtmp和rtsp协议，移除选项”timeout“    if (av_stristart(file_name, &quot;rtmp&quot;, NULL) ||        av_stristart(file_name, &quot;rtsp&quot;, NULL)) {        // There is total different meaning for &#39;timeout&#39; option in rtmp        av_log(ffp, AV_LOG_WARNING, &quot;remove &#39;timeout&#39; option for rtmp.\n&quot;);        av_dict_set(&amp;ffp-&gt;format_opts, &quot;timeout&quot;, NULL, 0);    }    /* there is a length limit in avformat */    if (strlen(file_name) + 1 &gt; 1024) {        av_log(ffp, AV_LOG_ERROR, &quot;%s too long url\n&quot;, __func__);        if (avio_find_protocol_name(&quot;ijklongurl:&quot;)) {            av_dict_set(&amp;ffp-&gt;format_opts, &quot;ijklongurl-url&quot;, file_name, 0);            file_name = &quot;ijklongurl:&quot;;        }    }    //打印版本信息    av_log(NULL, AV_LOG_INFO, &quot;===== versions =====\n&quot;);    ffp_show_version_str(ffp, &quot;ijkplayer&quot;,      ijk_version_info());    ffp_show_version_str(ffp, &quot;FFmpeg&quot;,         av_version_info());    ffp_show_version_int(ffp, &quot;libavutil&quot;,      avutil_version());    ffp_show_version_int(ffp, &quot;libavcodec&quot;,     avcodec_version());    ffp_show_version_int(ffp, &quot;libavformat&quot;,    avformat_version());    ffp_show_version_int(ffp, &quot;libswscale&quot;,     swscale_version());    ffp_show_version_int(ffp, &quot;libswresample&quot;,  swresample_version());    av_log(NULL, AV_LOG_INFO, &quot;===== options =====\n&quot;);    ffp_show_dict(ffp, &quot;player-opts&quot;, ffp-&gt;player_opts);    ffp_show_dict(ffp, &quot;format-opts&quot;, ffp-&gt;format_opts);    ffp_show_dict(ffp, &quot;codec-opts &quot;, ffp-&gt;codec_opts);    ffp_show_dict(ffp, &quot;sws-opts   &quot;, ffp-&gt;sws_dict);    ffp_show_dict(ffp, &quot;swr-opts   &quot;, ffp-&gt;swr_opts);    av_log(NULL, AV_LOG_INFO, &quot;===================\n&quot;);    //设置播放器选项    av_opt_set_dict(ffp, &amp;ffp-&gt;player_opts);    //如果ffplayer-&gt;aout==null，那么久打开音频输出设备。前面的初始化代码是没有为这个赋值过的，所以第一次调用肯定会返回true.    if (!ffp-&gt;aout) {        ffp-&gt;aout = ffpipeline_open_audio_output(ffp-&gt;pipeline, ffp);        if (!ffp-&gt;aout)            return -1;    }#if CONFIG_AVFILTER    if (ffp-&gt;vfilter0) {        GROW_ARRAY(ffp-&gt;vfilters_list, ffp-&gt;nb_vfilters);        ffp-&gt;vfilters_list[ffp-&gt;nb_vfilters - 1] = ffp-&gt;vfilter0;    }#endif    VideoState *is = stream_open(ffp, file_name, NULL);    if (!is) {        av_log(NULL, AV_LOG_WARNING, &quot;ffp_prepare_async_l: stream_open failed OOM&quot;);        return EIJK_OUT_OF_MEMORY;    }    ffp-&gt;is = is;    ffp-&gt;input_filename = av_strdup(file_name);    return 0;}</code></pre><p>即这句：</p><pre><code class="c">//如果ffplayer-&gt;aout==null，那么久打开音频输出设备。前面的初始化代码是没有为这个赋值过的，所以第一次调用肯定会返回true.    if (!ffp-&gt;aout) {        ffp-&gt;aout = ffpipeline_open_audio_output(ffp-&gt;pipeline, ffp);        if (!ffp-&gt;aout)            return -1;    }</code></pre><pre><code class="c">SDL_Aout *ffpipeline_open_audio_output(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    //借助pipeline的方法    return pipeline-&gt;func_open_audio_output(pipeline, ffp);}</code></pre><p>这个地方要使用<code>IJKFF_Pipeline</code>的方法，而<code>IJKFF_Pipeline</code>是在创建播放器的时候创建的。</p><pre><code class="c">static SDL_Aout *func_open_audio_output(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    SDL_Aout *aout = NULL;    if (ffp-&gt;opensles) {        aout = SDL_AoutAndroid_CreateForOpenSLES();    } else {          //一般不会用opensles，都是默认用的android的AudioTrack来创建Aout        aout = SDL_AoutAndroid_CreateForAudioTrack();    }    if (aout)        SDL_AoutSetStereoVolume(aout, pipeline-&gt;opaque-&gt;left_volume, pipeline-&gt;opaque-&gt;right_volume);    return aout;}</code></pre><pre><code class="c">SDL_Aout *SDL_AoutAndroid_CreateForAudioTrack(){    SDL_Aout *aout = SDL_Aout_CreateInternal(sizeof(SDL_Aout_Opaque));    if (!aout)        return NULL;    SDL_Aout_Opaque *opaque = aout-&gt;opaque;    opaque-&gt;wakeup_cond  = SDL_CreateCond();    opaque-&gt;wakeup_mutex = SDL_CreateMutex();    opaque-&gt;speed        = 1.0f;    aout-&gt;opaque_class = &amp;g_audiotrack_class;    aout-&gt;free_l       = aout_free_l;    aout-&gt;open_audio   = aout_open_audio;    aout-&gt;pause_audio  = aout_pause_audio;    aout-&gt;flush_audio  = aout_flush_audio;    aout-&gt;set_volume   = aout_set_volume;    aout-&gt;close_audio  = aout_close_audio;    aout-&gt;func_get_audio_session_id = aout_get_audio_session_id;    aout-&gt;func_set_playback_rate    = func_set_playback_rate;    return aout;}</code></pre><p>那么这里看一下这个<code>aoujt-&gt;open_audio</code>函数：</p><pre><code class="c">static int aout_open_audio(SDL_Aout *aout, const SDL_AudioSpec *desired, SDL_AudioSpec *obtained){    // SDL_Aout_Opaque *opaque = aout-&gt;opaque;    JNIEnv *env = NULL;    if (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) {        ALOGE(&quot;aout_open_audio: AttachCurrentThread: failed&quot;);        return -1;    }    return aout_open_audio_n(env, aout, desired, obtained);}</code></pre><pre><code class="c">static int aout_open_audio_n(JNIEnv *env, SDL_Aout *aout, const SDL_AudioSpec *desired, SDL_AudioSpec *obtained){    assert(desired);    SDL_Aout_Opaque *opaque = aout-&gt;opaque;    opaque-&gt;spec = *desired;    opaque-&gt;atrack = SDL_Android_AudioTrack_new_from_sdl_spec(env, desired);    if (!opaque-&gt;atrack) {        ALOGE(&quot;aout_open_audio_n: failed to new AudioTrcak()&quot;);        return -1;    }    opaque-&gt;buffer_size = SDL_Android_AudioTrack_get_min_buffer_size(opaque-&gt;atrack);    if (opaque-&gt;buffer_size &lt;= 0) {        ALOGE(&quot;aout_open_audio_n: failed to getMinBufferSize()&quot;);        SDL_Android_AudioTrack_free(env, opaque-&gt;atrack);        opaque-&gt;atrack = NULL;        return -1;    }    opaque-&gt;buffer = malloc(opaque-&gt;buffer_size);    if (!opaque-&gt;buffer) {        ALOGE(&quot;aout_open_audio_n: failed to allocate buffer&quot;);        SDL_Android_AudioTrack_free(env, opaque-&gt;atrack);        opaque-&gt;atrack = NULL;        return -1;    }    if (obtained) {        SDL_Android_AudioTrack_get_target_spec(opaque-&gt;atrack, obtained);        SDLTRACE(&quot;audio target format fmt:0x%x, channel:0x%x&quot;, (int)obtained-&gt;format, (int)obtained-&gt;channels);    }    opaque-&gt;audio_session_id = SDL_Android_AudioTrack_getAudioSessionId(env, opaque-&gt;atrack);    ALOGI(&quot;audio_session_id = %d\n&quot;, opaque-&gt;audio_session_id);    opaque-&gt;pause_on = 1;    opaque-&gt;abort_request = 0;    //创建音频输出线程    opaque-&gt;audio_tid = SDL_CreateThreadEx(&amp;opaque-&gt;_audio_tid, aout_thread, aout, &quot;ff_aout_android&quot;);    if (!opaque-&gt;audio_tid) {        ALOGE(&quot;aout_open_audio_n: failed to create audio thread&quot;);        SDL_Android_AudioTrack_free(env, opaque-&gt;atrack);        opaque-&gt;atrack = NULL;        return -1;    }    return 0;}</code></pre><p>那么这里看下这个音频输出线程做了什么：</p><pre><code class="c">static int aout_thread(void *arg){    SDL_Aout *aout = arg;    // SDL_Aout_Opaque *opaque = aout-&gt;opaque;    JNIEnv *env = NULL;    if (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) {        ALOGE(&quot;aout_thread: SDL_AndroidJni_SetupEnv: failed&quot;);        return -1;    }    return aout_thread_n(env, aout);}</code></pre><pre><code class="c">static int aout_thread_n(JNIEnv *env, SDL_Aout *aout){    SDL_Aout_Opaque *opaque = aout-&gt;opaque;    SDL_Android_AudioTrack *atrack = opaque-&gt;atrack;    SDL_AudioCallback audio_cblk = opaque-&gt;spec.callback;    void *userdata = opaque-&gt;spec.userdata;    uint8_t *buffer = opaque-&gt;buffer;    int copy_size = 256;    assert(atrack);    assert(buffer);    SDL_SetThreadPriority(SDL_THREAD_PRIORITY_HIGH);    if (!opaque-&gt;abort_request &amp;&amp; !opaque-&gt;pause_on)        SDL_Android_AudioTrack_play(env, atrack);    //只要没有中断请求，就无限循环    while (!opaque-&gt;abort_request) {        SDL_LockMutex(opaque-&gt;wakeup_mutex);        if (!opaque-&gt;abort_request &amp;&amp; opaque-&gt;pause_on) {            //暂停            SDL_Android_AudioTrack_pause(env, atrack);            while (!opaque-&gt;abort_request &amp;&amp; opaque-&gt;pause_on) {                SDL_CondWaitTimeout(opaque-&gt;wakeup_cond, opaque-&gt;wakeup_mutex, 1000);            }            if (!opaque-&gt;abort_request &amp;&amp; !opaque-&gt;pause_on) {                if (opaque-&gt;need_flush) {                    opaque-&gt;need_flush = 0;                    //flush                    SDL_Android_AudioTrack_flush(env, atrack);                }                //播放                SDL_Android_AudioTrack_play(env, atrack);            }        }        if (opaque-&gt;need_flush) {            opaque-&gt;need_flush = 0;            SDL_Android_AudioTrack_flush(env, atrack);        }        if (opaque-&gt;need_set_volume) {            opaque-&gt;need_set_volume = 0;            SDL_Android_AudioTrack_set_volume(env, atrack, opaque-&gt;left_volume, opaque-&gt;right_volume);        }        if (opaque-&gt;speed_changed) {            opaque-&gt;speed_changed = 0;            SDL_Android_AudioTrack_setSpeed(env, atrack, opaque-&gt;speed);        }        SDL_UnlockMutex(opaque-&gt;wakeup_mutex);        audio_cblk(userdata, buffer, copy_size);        if (opaque-&gt;need_flush) {            SDL_Android_AudioTrack_flush(env, atrack);            opaque-&gt;need_flush = false;        }        if (opaque-&gt;need_flush) {            opaque-&gt;need_flush = 0;            SDL_Android_AudioTrack_flush(env, atrack);        } else {            int written = SDL_Android_AudioTrack_write(env, atrack, buffer, copy_size);            if (written != copy_size) {                ALOGW(&quot;AudioTrack: not all data copied %d/%d&quot;, (int)written, (int)copy_size);            }        }        // TODO: 1 if callback return -1 or 0    }    SDL_Android_AudioTrack_free(env, atrack);    return 0;}</code></pre><p>这里看下这个播放是在干嘛：</p><pre><code class="c">void SDL_Android_AudioTrack_play(JNIEnv *env, SDL_Android_AudioTrack *atrack){    SDLTRACE(&quot;%s&quot;, __func__);    J4AC_AudioTrack__play__catchAll(env, atrack-&gt;thiz);}</code></pre><pre><code class="c">// ijkmedia/ijkj4a/j4a/class/android/media/AudioTrack.h#define J4AC_AudioTrack__play__catchAll J4AC_android_media_AudioTrack__play__catchAll</code></pre><pre><code class="c">void J4AC_android_media_AudioTrack__play__catchAll(JNIEnv *env, jobject thiz){    J4AC_android_media_AudioTrack__play(env, thiz);    J4A_ExceptionCheck__catchAll(env);}</code></pre><pre><code class="c">void J4AC_android_media_AudioTrack__play(JNIEnv *env, jobject thiz){          //调用了jni方法，即通过c去调用java里的方法了。    (*env)-&gt;CallVoidMethod(env, thiz, class_J4AC_android_media_AudioTrack.method_play);}</code></pre><p>而这个<code>class_J4AC_android_media_AudioTrack.method_play</code>是：</p><pre><code class="c">//    ijkmedia/ijkj4a/j4a/class/android/media/AudioTrack.cint J4A_loadClass__J4AC_android_media_AudioTrack(JNIEnv *env){    //...    class_id = class_J4AC_android_media_AudioTrack.id;    name     = &quot;play&quot;;    sign     = &quot;()V&quot;;    class_J4AC_android_media_AudioTrack.method_play = J4A_GetMethodID__catchAll(env, class_id, name, sign);    //...}</code></pre><p>那么的确是调用的java层的<code>AudioTrack#play()</code></p><h4 id="3-使用-1"><a href="#3-使用-1" class="headerlink" title="3. 使用"></a>3. 使用</h4><pre><code class="c">switch (avctx-&gt;codec_type) {  case AVMEDIA_TYPE_AUDIO:        //audio_open里面会去调用到AudioTrack.java # play()      if ((ret = audio_open(ffp, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; 0)        //decoder初始化      decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread);      //decoder启动，启动audio_thread线程      if ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, ffp, &quot;ff_audio_dec&quot;)) &lt; 0)}</code></pre><h3 id="IJKFF-Pipeline"><a href="#IJKFF-Pipeline" class="headerlink" title="IJKFF_Pipeline"></a>IJKFF_Pipeline</h3><h4 id="1-结构体-2"><a href="#1-结构体-2" class="headerlink" title="1. 结构体"></a>1. 结构体</h4><h5 id="1-1-IJKFF-Pipeline"><a href="#1-1-IJKFF-Pipeline" class="headerlink" title="1.1 IJKFF_Pipeline"></a>1.1 IJKFF_Pipeline</h5><pre><code class="c">typedef struct IJKFF_Pipeline IJKFF_Pipeline;struct IJKFF_Pipeline {    SDL_Class             *opaque_class;    IJKFF_Pipeline_Opaque *opaque;        //销毁    void            (*func_destroy)             (IJKFF_Pipeline *pipeline);      //打开视频解码器    IJKFF_Pipenode *(*func_open_video_decoder)  (IJKFF_Pipeline *pipeline, FFPlayer *ffp);      //打开音频解码器    SDL_Aout       *(*func_open_audio_output)   (IJKFF_Pipeline *pipeline, FFPlayer *ffp);      //初始化视频解码器    IJKFF_Pipenode *(*func_init_video_decoder)  (IJKFF_Pipeline *pipeline, FFPlayer *ffp);      //配置视频解码器    int           (*func_config_video_decoder)  (IJKFF_Pipeline *pipeline, FFPlayer *ffp);};</code></pre><h5 id="1-2-IJKFF-Pipeline-Opaque"><a href="#1-2-IJKFF-Pipeline-Opaque" class="headerlink" title="1.2 IJKFF_Pipeline_Opaque"></a>1.2 IJKFF_Pipeline_Opaque</h5><pre><code class="c">typedef struct IJKFF_Pipeline_Opaque {    FFPlayer      *ffp;    SDL_mutex     *surface_mutex;    jobject        jsurface;    volatile bool  is_surface_need_reconfigure;    bool         (*mediacodec_select_callback)(void *opaque, ijkmp_mediacodecinfo_context *mcc);    void          *mediacodec_select_callback_opaque;    SDL_Vout      *weak_vout;    float          left_volume;    float          right_volume;} IJKFF_Pipeline_Opaque;</code></pre><h4 id="2-初始化-2"><a href="#2-初始化-2" class="headerlink" title="2. 初始化"></a>2. 初始化</h4><pre><code class="c">IjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*)){        //...    mp-&gt;ffplayer-&gt;pipeline = ffpipeline_create_from_android(mp-&gt;ffplayer);    //...}</code></pre><pre><code class="c">IJKFF_Pipeline *ffpipeline_create_from_android(FFPlayer *ffp){    ALOGD(&quot;ffpipeline_create_from_android()\n&quot;);    //分配内存    IJKFF_Pipeline *pipeline = ffpipeline_alloc(&amp;g_pipeline_class, sizeof(IJKFF_Pipeline_Opaque));    if (!pipeline)        return pipeline;    //初始化opaque    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    opaque-&gt;ffp                   = ffp;    opaque-&gt;surface_mutex         = SDL_CreateMutex();    opaque-&gt;left_volume           = 1.0f;    opaque-&gt;right_volume          = 1.0f;    if (!opaque-&gt;surface_mutex) {        ALOGE(&quot;ffpipeline-android:create SDL_CreateMutex failed\n&quot;);        goto fail;    }    //初始化pipeline中的每个函数    pipeline-&gt;func_destroy              = func_destroy;    pipeline-&gt;func_open_video_decoder   = func_open_video_decoder;    pipeline-&gt;func_open_audio_output    = func_open_audio_output;    pipeline-&gt;func_init_video_decoder   = func_init_video_decoder;    pipeline-&gt;func_config_video_decoder = func_config_video_decoder;    return pipeline;fail:    ffpipeline_free_p(&amp;pipeline);    return NULL;}</code></pre><p>一个一个来看一下pipeline中的函数的作用：</p><h5 id="2-1-func-destroy"><a href="#2-1-func-destroy" class="headerlink" title="2.1 func_destroy()"></a>2.1 func_destroy()</h5><pre><code class="c">static void func_destroy(IJKFF_Pipeline *pipeline){    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    JNIEnv *env = NULL;    SDL_DestroyMutexP(&amp;opaque-&gt;surface_mutex);    if (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) {        ALOGE(&quot;amediacodec-pipeline:destroy: SetupThreadEnv failed\n&quot;);        goto fail;    }    //变量并释放IJKFF_Pipeline_Opaque.jsurface    SDL_JNI_DeleteGlobalRefP(env, &amp;opaque-&gt;jsurface);fail:    return;}</code></pre><pre><code class="c">//用env指针变量，删除obj_ptr的jni全局引用void SDL_JNI_DeleteGlobalRefP(JNIEnv *env, jobject *obj_ptr){    if (!obj_ptr || !*obj_ptr)        return;        //jni方法，删除全局引用    (*env)-&gt;DeleteGlobalRef(env, *obj_ptr);    *obj_ptr = NULL;}</code></pre><h5 id="2-2-func-open-video-decoder"><a href="#2-2-func-open-video-decoder" class="headerlink" title="2.2 func_open_video_decoder()"></a>2.2 func_open_video_decoder()</h5><pre><code class="c">static IJKFF_Pipenode *func_open_video_decoder(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    IJKFF_Pipenode        *node = NULL;    if (ffp-&gt;mediacodec_all_videos || ffp-&gt;mediacodec_avc || ffp-&gt;mediacodec_hevc || ffp-&gt;mediacodec_mpeg2)        //从硬解中创建解码器        node = ffpipenode_create_video_decoder_from_android_mediacodec(ffp, pipeline, opaque-&gt;weak_vout);    if (!node) {        //从ffplay中创建解码器，即ffmpeg的解码器        node = ffpipenode_create_video_decoder_from_ffplay(ffp);    }    return node;}</code></pre><p>这里很有意思，创建解码器，而返回的对象是<code>IJKFF_Pipenode</code>，这是否说明<code>IJKFF_Pipenode</code>就是一个解码器的抽象？</p><h5 id="2-3-func-open-audio-output"><a href="#2-3-func-open-audio-output" class="headerlink" title="2.3 func_open_audio_output"></a>2.3 func_open_audio_output</h5><pre><code class="c">static SDL_Aout *func_open_audio_output(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    SDL_Aout *aout = NULL;    if (ffp-&gt;opensles) {        aout = SDL_AoutAndroid_CreateForOpenSLES();    } else {          //一般不会用opensles，都是默认用的android的AudioTrack来创建Aout        aout = SDL_AoutAndroid_CreateForAudioTrack();    }    if (aout)        SDL_AoutSetStereoVolume(aout, pipeline-&gt;opaque-&gt;left_volume, pipeline-&gt;opaque-&gt;right_volume);    return aout;}</code></pre><pre><code class="c">SDL_Aout *SDL_AoutAndroid_CreateForAudioTrack(){      //在这里创建并分配了SDL_Aout结构体    SDL_Aout *aout = SDL_Aout_CreateInternal(sizeof(SDL_Aout_Opaque));    if (!aout)        return NULL;    SDL_Aout_Opaque *opaque = aout-&gt;opaque;    opaque-&gt;wakeup_cond  = SDL_CreateCond();    opaque-&gt;wakeup_mutex = SDL_CreateMutex();    opaque-&gt;speed        = 1.0f;    aout-&gt;opaque_class = &amp;g_audiotrack_class;    aout-&gt;free_l       = aout_free_l;    aout-&gt;open_audio   = aout_open_audio;    aout-&gt;pause_audio  = aout_pause_audio;    aout-&gt;flush_audio  = aout_flush_audio;    aout-&gt;set_volume   = aout_set_volume;    aout-&gt;close_audio  = aout_close_audio;    aout-&gt;func_get_audio_session_id = aout_get_audio_session_id;    aout-&gt;func_set_playback_rate    = func_set_playback_rate;    return aout;}</code></pre><h5 id="2-4-func-init-video-decoder"><a href="#2-4-func-init-video-decoder" class="headerlink" title="2.4 func_init_video_decoder"></a>2.4 func_init_video_decoder</h5><pre><code class="c">static IJKFF_Pipenode *func_init_video_decoder(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    IJKFF_Pipenode        *node = NULL;    if (ffp-&gt;mediacodec_all_videos || ffp-&gt;mediacodec_avc || ffp-&gt;mediacodec_hevc || ffp-&gt;mediacodec_mpeg2)          //如果是硬解，则要再初始化一下，如果是ffmpeg的软解，就不需要了。        node = ffpipenode_init_decoder_from_android_mediacodec(ffp, pipeline, opaque-&gt;weak_vout);    return node;}</code></pre><h5 id="2-5-func-config-video-decoder"><a href="#2-5-func-config-video-decoder" class="headerlink" title="2.5 func_config_video_decoder"></a>2.5 func_config_video_decoder</h5><pre><code class="c">static int func_config_video_decoder(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    int                       ret = NULL;    if (ffp-&gt;node_vdec) {        ret = ffpipenode_config_from_android_mediacodec(ffp, pipeline, opaque-&gt;weak_vout, ffp-&gt;node_vdec);    }    return ret;}</code></pre><h4 id="3-使用-2"><a href="#3-使用-2" class="headerlink" title="3. 使用"></a>3. 使用</h4><p>视频解码线程开始之前，用<code>ffpipeline_open_video_decoder</code>创建一个解码器。</p><pre><code class="c">static int stream_component_open(FFPlayer *ffp, int stream_index){  //...  case AVMEDIA_TYPE_VIDEO:      //decoder初始化        decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);    ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);      //解码器开始    if ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, ffp, &quot;ff_video_dec&quot;)) &lt; 0)        goto out;  //...}</code></pre><h3 id="IJKFF-Pipenode"><a href="#IJKFF-Pipenode" class="headerlink" title="IJKFF_Pipenode"></a>IJKFF_Pipenode</h3><p>这个称为管道节点结构体包含的<code>func_run_sync()</code>函数是用来运行解码线程的。因此该结构体对底层ffmpeg来说，也是底层ffmpeg的一层抽象了。</p><h4 id="1-结构体-3"><a href="#1-结构体-3" class="headerlink" title="1. 结构体"></a>1. 结构体</h4><pre><code class="c">typedef struct IJKFF_Pipenode IJKFF_Pipenode;struct IJKFF_Pipenode {    SDL_mutex *mutex;    void *opaque;    void (*func_destroy) (IJKFF_Pipenode *node);    int  (*func_run_sync)(IJKFF_Pipenode *node);    int  (*func_flush)   (IJKFF_Pipenode *node); // optional};</code></pre><h4 id="2-初始化-3"><a href="#2-初始化-3" class="headerlink" title="2. 初始化"></a>2. 初始化</h4><pre><code class="c">IJKFF_Pipenode *ffpipenode_create_video_decoder_from_ffplay(FFPlayer *ffp){    //分配IJKFF_Pipenode的内存    IJKFF_Pipenode *node = ffpipenode_alloc(sizeof(IJKFF_Pipenode_Opaque));    if (!node)        return node;    IJKFF_Pipenode_Opaque *opaque = node-&gt;opaque;    opaque-&gt;ffp         = ffp;        //为node的函数赋值    node-&gt;func_destroy  = func_destroy;    node-&gt;func_run_sync = func_run_sync;    ffp_set_video_codec_info(ffp, AVCODEC_MODULE_NAME, avcodec_get_name(ffp-&gt;is-&gt;viddec.avctx-&gt;codec_id));    ffp-&gt;stat.vdec_type = FFP_PROPV_DECODER_AVCODEC;    return node;}</code></pre><pre><code class="c">static void func_destroy(IJKFF_Pipenode *node){    // do nothing}static int func_run_sync(IJKFF_Pipenode *node){    IJKFF_Pipenode_Opaque *opaque = node-&gt;opaque;    return ffp_video_thread(opaque-&gt;ffp);}</code></pre><pre><code class="c">int ffp_video_thread(FFPlayer *ffp){    return ffplay_video_thread(ffp);}</code></pre><pre><code class="c">static int ffplay_video_thread(void *arg){    FFPlayer *ffp = arg;    VideoState *is = ffp-&gt;is;    AVFrame *frame = av_frame_alloc();    double pts;    double duration;    int ret;    AVRational tb = is-&gt;video_st-&gt;time_base;    AVRational frame_rate = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, NULL);    int64_t dst_pts = -1;    int64_t last_dst_pts = -1;    int retry_convert_image = 0;    int convert_frame_count = 0;    ffp_notify_msg2(ffp, FFP_MSG_VIDEO_ROTATION_CHANGED, ffp_get_video_rotate_degrees(ffp));    if (!frame) {        return AVERROR(ENOMEM);    }    for (;;) {          //获取解码后的数据AVFrame数据        ret = get_video_frame(ffp, frame);        if (ret &lt; 0)            goto the_end;        if (!ret)            continue;        if (ffp-&gt;get_frame_mode) {            if (!ffp-&gt;get_img_info || ffp-&gt;get_img_info-&gt;count &lt;= 0) {                av_frame_unref(frame);                continue;            }            last_dst_pts = dst_pts;            if (dst_pts &lt; 0) {                dst_pts = ffp-&gt;get_img_info-&gt;start_time;            } else {                dst_pts += (ffp-&gt;get_img_info-&gt;end_time - ffp-&gt;get_img_info-&gt;start_time) / (ffp-&gt;get_img_info-&gt;num - 1);            }            pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);            pts = pts * 1000;            if (pts &gt;= dst_pts) {                while (retry_convert_image &lt;= MAX_RETRY_CONVERT_IMAGE) {                    ret = convert_image(ffp, frame, (int64_t)pts, frame-&gt;width, frame-&gt;height);                    if (!ret) {                        convert_frame_count++;                        break;                    }                    retry_convert_image++;                    av_log(NULL, AV_LOG_ERROR, &quot;convert image error retry_convert_image = %d\n&quot;, retry_convert_image);                }                retry_convert_image = 0;                if (ret || ffp-&gt;get_img_info-&gt;count &lt;= 0) {                    if (ret) {                        av_log(NULL, AV_LOG_ERROR, &quot;convert image abort ret = %d\n&quot;, ret);                        ffp_notify_msg3(ffp, FFP_MSG_GET_IMG_STATE, 0, ret);                    } else {                        av_log(NULL, AV_LOG_INFO, &quot;convert image complete convert_frame_count = %d\n&quot;, convert_frame_count);                    }                    goto the_end;                }            } else {                dst_pts = last_dst_pts;            }            av_frame_unref(frame);            continue;        }            duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational){frame_rate.den, frame_rate.num}) : 0);            pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);                  //将frame数据进入到picture_queue。即渲染队列            ret = queue_picture(ffp, frame, pts, duration, frame-&gt;pkt_pos, is-&gt;viddec.pkt_serial);            av_frame_unref(frame);        if (ret &lt; 0)            goto the_end;    } the_end:    av_log(NULL, AV_LOG_INFO, &quot;convert image convert_frame_count = %d\n&quot;, convert_frame_count);    av_frame_free(&amp;frame);    return 0;}</code></pre><h4 id="3-使用-3"><a href="#3-使用-3" class="headerlink" title="3. 使用"></a>3. 使用</h4><p>主要就是他的<code>func_run_sync()</code>方法被用来解码视频帧并入队渲染队列。这个操作发生在：</p><pre><code class="c">static int video_thread(void *arg){    FFPlayer *ffp = (FFPlayer *)arg;    int       ret = 0;        //如果node_vdec不为null。    if (ffp-&gt;node_vdec) {          //解码操作        ret = ffpipenode_run_sync(ffp-&gt;node_vdec);    }    return ret;}</code></pre><p> 那么我们来看一下解码的时候他的逻辑：</p><pre><code class="c">//    ijkmedia/ijkplayer/pipeline/ffpipenode_ffplay_vdec.cstatic int func_run_sync(IJKFF_Pipenode *node){    IJKFF_Pipenode_Opaque *opaque = node-&gt;opaque;    return ffp_video_thread(opaque-&gt;ffp);}</code></pre><pre><code class="c">//    ijkmedia/ijkplayer/ff_ffplay.cint ffp_video_thread(FFPlayer *ffp){    return ffplay_video_thread(ffp);}</code></pre><pre><code>    = func_destroy;pipeline-&gt;func_open_video_decoder   = func_open_video_decoder;pipeline-&gt;func_open_audio_output    = func_open_audio_output;pipeline-&gt;func_init_video_decoder   = func_init_video_decoder;pipeline-&gt;func_config_video_decoder = func_config_video_decoder;return pipeline;</code></pre><p>fail:<br>    ffpipeline_free_p(&amp;pipeline);<br>    return NULL;<br>}</p><pre><code>一个一个来看一下pipeline中的函数的作用：##### 2.1 func_destroy()``` cstatic void func_destroy(IJKFF_Pipeline *pipeline){    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    JNIEnv *env = NULL;    SDL_DestroyMutexP(&amp;opaque-&gt;surface_mutex);    if (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) {        ALOGE(&quot;amediacodec-pipeline:destroy: SetupThreadEnv failed\n&quot;);        goto fail;    }    //变量并释放IJKFF_Pipeline_Opaque.jsurface    SDL_JNI_DeleteGlobalRefP(env, &amp;opaque-&gt;jsurface);fail:    return;}</code></pre><pre><code class="c">//用env指针变量，删除obj_ptr的jni全局引用void SDL_JNI_DeleteGlobalRefP(JNIEnv *env, jobject *obj_ptr){    if (!obj_ptr || !*obj_ptr)        return;        //jni方法，删除全局引用    (*env)-&gt;DeleteGlobalRef(env, *obj_ptr);    *obj_ptr = NULL;}</code></pre><h5 id="2-2-func-open-video-decoder-1"><a href="#2-2-func-open-video-decoder-1" class="headerlink" title="2.2 func_open_video_decoder()"></a>2.2 func_open_video_decoder()</h5><pre><code class="c">static IJKFF_Pipenode *func_open_video_decoder(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    IJKFF_Pipenode        *node = NULL;    if (ffp-&gt;mediacodec_all_videos || ffp-&gt;mediacodec_avc || ffp-&gt;mediacodec_hevc || ffp-&gt;mediacodec_mpeg2)        //从硬解中创建解码器        node = ffpipenode_create_video_decoder_from_android_mediacodec(ffp, pipeline, opaque-&gt;weak_vout);    if (!node) {        //从ffplay中创建解码器，即ffmpeg的解码器        node = ffpipenode_create_video_decoder_from_ffplay(ffp);    }    return node;}</code></pre><p>这里很有意思，创建解码器，而返回的对象是<code>IJKFF_Pipenode</code>，这是否说明<code>IJKFF_Pipenode</code>就是一个解码器的抽象？</p><h5 id="2-3-func-open-audio-output-1"><a href="#2-3-func-open-audio-output-1" class="headerlink" title="2.3 func_open_audio_output"></a>2.3 func_open_audio_output</h5><pre><code class="c">static SDL_Aout *func_open_audio_output(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    SDL_Aout *aout = NULL;    if (ffp-&gt;opensles) {        aout = SDL_AoutAndroid_CreateForOpenSLES();    } else {          //一般不会用opensles，都是默认用的android的AudioTrack来创建Aout        aout = SDL_AoutAndroid_CreateForAudioTrack();    }    if (aout)        SDL_AoutSetStereoVolume(aout, pipeline-&gt;opaque-&gt;left_volume, pipeline-&gt;opaque-&gt;right_volume);    return aout;}</code></pre><pre><code class="c">SDL_Aout *SDL_AoutAndroid_CreateForAudioTrack(){      //在这里创建并分配了SDL_Aout结构体    SDL_Aout *aout = SDL_Aout_CreateInternal(sizeof(SDL_Aout_Opaque));    if (!aout)        return NULL;    SDL_Aout_Opaque *opaque = aout-&gt;opaque;    opaque-&gt;wakeup_cond  = SDL_CreateCond();    opaque-&gt;wakeup_mutex = SDL_CreateMutex();    opaque-&gt;speed        = 1.0f;    aout-&gt;opaque_class = &amp;g_audiotrack_class;    aout-&gt;free_l       = aout_free_l;    aout-&gt;open_audio   = aout_open_audio;    aout-&gt;pause_audio  = aout_pause_audio;    aout-&gt;flush_audio  = aout_flush_audio;    aout-&gt;set_volume   = aout_set_volume;    aout-&gt;close_audio  = aout_close_audio;    aout-&gt;func_get_audio_session_id = aout_get_audio_session_id;    aout-&gt;func_set_playback_rate    = func_set_playback_rate;    return aout;}</code></pre><h5 id="2-4-func-init-video-decoder-1"><a href="#2-4-func-init-video-decoder-1" class="headerlink" title="2.4 func_init_video_decoder"></a>2.4 func_init_video_decoder</h5><pre><code class="c">static IJKFF_Pipenode *func_init_video_decoder(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    IJKFF_Pipenode        *node = NULL;    if (ffp-&gt;mediacodec_all_videos || ffp-&gt;mediacodec_avc || ffp-&gt;mediacodec_hevc || ffp-&gt;mediacodec_mpeg2)          //如果是硬解，则要再初始化一下，如果是ffmpeg的软解，就不需要了。        node = ffpipenode_init_decoder_from_android_mediacodec(ffp, pipeline, opaque-&gt;weak_vout);    return node;}</code></pre><h5 id="2-5-func-config-video-decoder-1"><a href="#2-5-func-config-video-decoder-1" class="headerlink" title="2.5 func_config_video_decoder"></a>2.5 func_config_video_decoder</h5><pre><code class="c">static int func_config_video_decoder(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    int                       ret = NULL;    if (ffp-&gt;node_vdec) {        ret = ffpipenode_config_from_android_mediacodec(ffp, pipeline, opaque-&gt;weak_vout, ffp-&gt;node_vdec);    }    return ret;}</code></pre><h4 id="3-使用-4"><a href="#3-使用-4" class="headerlink" title="3. 使用"></a>3. 使用</h4><p>视频解码线程开始之前，用<code>ffpipeline_open_video_decoder</code>创建一个解码器。</p><pre><code class="c">static int stream_component_open(FFPlayer *ffp, int stream_index){  //...  case AVMEDIA_TYPE_VIDEO:      //decoder初始化        decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);    ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);      //解码器开始    if ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, ffp, &quot;ff_video_dec&quot;)) &lt; 0)        goto out;  //...}</code></pre><h3 id="IJKFF-Pipenode-1"><a href="#IJKFF-Pipenode-1" class="headerlink" title="IJKFF_Pipenode"></a>IJKFF_Pipenode</h3><p>这个称为管道节点结构体包含的<code>func_run_sync()</code>函数是用来运行解码线程的。因此该结构体对底层ffmpeg来说，也是底层ffmpeg的一层抽象了。</p><h4 id="1-结构体-4"><a href="#1-结构体-4" class="headerlink" title="1. 结构体"></a>1. 结构体</h4><pre><code class="c">typedef struct IJKFF_Pipenode IJKFF_Pipenode;struct IJKFF_Pipenode {    SDL_mutex *mutex;    void *opaque;    void (*func_destroy) (IJKFF_Pipenode *node);    int  (*func_run_sync)(IJKFF_Pipenode *node);    int  (*func_flush)   (IJKFF_Pipenode *node); // optional};</code></pre><h4 id="2-初始化-4"><a href="#2-初始化-4" class="headerlink" title="2. 初始化"></a>2. 初始化</h4><pre><code class="c">IJKFF_Pipenode *ffpipenode_create_video_decoder_from_ffplay(FFPlayer *ffp){    //分配IJKFF_Pipenode的内存    IJKFF_Pipenode *node = ffpipenode_alloc(sizeof(IJKFF_Pipenode_Opaque));    if (!node)        return node;    IJKFF_Pipenode_Opaque *opaque = node-&gt;opaque;    opaque-&gt;ffp         = ffp;        //为node的函数赋值    node-&gt;func_destroy  = func_destroy;    node-&gt;func_run_sync = func_run_sync;    ffp_set_video_codec_info(ffp, AVCODEC_MODULE_NAME, avcodec_get_name(ffp-&gt;is-&gt;viddec.avctx-&gt;codec_id));    ffp-&gt;stat.vdec_type = FFP_PROPV_DECODER_AVCODEC;    return node;}</code></pre><pre><code class="c">static void func_destroy(IJKFF_Pipenode *node){    // do nothing}static int func_run_sync(IJKFF_Pipenode *node){    IJKFF_Pipenode_Opaque *opaque = node-&gt;opaque;    return ffp_video_thread(opaque-&gt;ffp);}</code></pre><pre><code class="c">int ffp_video_thread(FFPlayer *ffp){    return ffplay_video_thread(ffp);}</code></pre><p>``` c<br>static int ffplay_video_thread(void *arg)<br>{<br>    FFPlayer *ffp = arg;<br>    VideoState *is = ffp-&gt;is;<br>    AVFrame *frame = av_frame_alloc();<br>    double pts;<br>    double duration;<br>    int ret;<br>    AVRational tb = is-&gt;video_st-&gt;time_base;<br>    AVRational frame_rate = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, NULL);<br>    int64_t dst_pts = -1;<br>    int64_t last_dst_pts = -1;<br>    int retry_convert_image = 0;<br>    int convert_frame_count = 0;</p><pre><code>ffp_notify_msg2(ffp, FFP_MSG_VIDEO_ROTATION_CHANGED, ffp_get_video_rotate_degrees(ffp));if (!frame) {    return AVERROR(ENOMEM);}for (;;) {      //获取解码后的数据AVFrame数据    ret = get_video_frame(ffp, frame);    if (ret &lt; 0)        goto the_end;    if (!ret)        continue;    if (ffp-&gt;get_frame_mode) {        if (!ffp-&gt;get_img_info || ffp-&gt;get_img_info-&gt;count &lt;= 0) {            av_frame_unref(frame);            continue;        }        last_dst_pts = dst_pts;        if (dst_pts &lt; 0) {            dst_pts = ffp-&gt;get_img_info-&gt;start_time;        } else {            dst_pts += (ffp-&gt;get_img_info-&gt;end_time - ffp-&gt;get_img_info-&gt;start_time) / (ffp-&gt;get_img_info-&gt;num - 1);        }        pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);        pts = pts * 1000;        if (pts &gt;= dst_pts) {            while (retry_convert_image &lt;= MAX_RETRY_CONVERT_IMAGE) {                ret = convert_image(ffp, frame, (int64_t)pts, frame-&gt;width, frame-&gt;height);                if (!ret) {                    convert_frame_count++;                    break;                }                retry_convert_image++;                av_log(NULL, AV_L</code></pre>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac-10-15-AndroidStudio-JNI调试出错</title>
    <link href="/2020/03/07/ndk/Mac-10-15-AndroidStudio-JNI%E8%B0%83%E8%AF%95%E5%87%BA%E9%94%99/"/>
    <url>/2020/03/07/ndk/Mac-10-15-AndroidStudio-JNI%E8%B0%83%E8%AF%95%E5%87%BA%E9%94%99/</url>
    
    <content type="html"><![CDATA[<p>mac升级到10.15后，进行Jni代码调试的时候报错：</p><pre><code>com.intellij.execution.ExecutionFinishedException: Execution finishedProcess finished with exit code 0</code></pre><p>clean、invalidate cache and restart都没用，最后将host重新配置一下，就能够进行jni调试了：</p><pre><code>127.0.0.1 localhost</code></pre><p>thanks ：<a href="http://pollux.cc/2019/12/01/2019-12-01%20%E6%89%8B%E6%9C%BA%E5%92%8CAS%E4%B8%ADdebug%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/#%E4%B8%80%E3%80%81%E5%9C%A8AS%E4%B8%AD%E5%B0%9D%E8%AF%95%E8%B0%83%E8%AF%95native%E4%BB%A3%E7%A0%81%EF%BC%8C%E6%8A%A5%E9%94%99" target="_blank" rel="noopener">手机和AS中debug环境配置问题小记</a><br></p>]]></content>
    
    
    <categories>
      
      <category>ndk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android-cmake使用外部动态共享库</title>
    <link href="/2020/02/07/ndk/Android-cmake%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8A%A8%E6%80%81%E5%85%B1%E4%BA%AB%E5%BA%93/"/>
    <url>/2020/02/07/ndk/Android-cmake%E4%BD%BF%E7%94%A8%E5%A4%96%E9%83%A8%E5%8A%A8%E6%80%81%E5%85%B1%E4%BA%AB%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p><strong>官方文档分享：</strong></p><p>CMake的基本用法参考Android官方文档上的CMake教程：</p><p><a href="https://developer.android.com/studio/projects/configure-cmake" target="_blank" rel="noopener">https://developer.android.com/studio/projects/configure-cmake</a></p><p>他的内容有：</p><ol><li>创建CMake脚本</li><li>使用NDK中的静态库和动态共享库</li><li>添加其他已经编译过得动态共享库</li><li>如何进行多CMake project的开发</li></ol><hr><p>本篇文章</p><p>本篇文章主要是分析如何使用第三方的so库进行c层的开发。</p><p>与官方文档不同的是，官方文档在连接第三方动态共享库的时候，用法是：</p><pre><code class="cmake"># 添加共享库imported-libadd_library( imported-lib             SHARED             IMPORTED )# 设置共享库的路径set_target_properties( # Specifies the target library.            imported-lib            # Specifies the parameter you want to define.            PROPERTIES IMPORTED_LOCATION            # Provides the path to the library you want to import.            imported-lib/src/${ANDROID_ABI}/libimported-lib.so )# 设置头文件的路径include_directories( imported-lib/include/ )# 将第三方共享库库和你自己编译出来的共享库连接target_link_libraries( native-lib imported-lib ${log-lib} )</code></pre><p> 而我这里用的是：</p><pre><code class="cmake">link_directories()</code></pre><p>下面看下代码：</p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="1-项目目录"><a href="#1-项目目录" class="headerlink" title="1 项目目录"></a>1 项目目录</h3><pre><code>▶ tree -L 5.├── build.gradle├── consumer-rules.pro├── ffmpegprebuild.iml├── libs│   └── armeabi-v7a│       ├── libavcodec.so│       ├── libavfilter.so│       ├── libavformat.so│       ├── libavutil.so│       ├── libswresample.so│       └── libswscale.so└── src    ├── main    │   ├── AndroidManifest.xml    │   ├── cpp    │   │   ├── CMakeLists.txt    │   │   ├── ff.c    │   │   └── include    │   │       ├── libavcodec    │   │       ├── libavfilter    │   │       ├── libavformat    │   │       ├── libavutil    │   │       ├── libswresample    │   │       └── libswscale    │   ├── java    │   │   └── com    │   │       └── hwilliamgo    │   └── res    │       ├── drawable    │       └── values    │           └── strings.xml</code></pre><p>我这里是使用我提前编译好的<code>armveabi-v7a</code>架构下的ffmpeg的动态共享库。并将头文件放在了<code>/cpp/include</code>目录下。</p><p>而<code>cpp/ff.c</code>作为源文件。</p><p>我的目标是：在ff.c中使用ffmpeg提供的api，提供到java层去调用。</p><p><code>ff.c</code> ==&gt;</p><pre><code class="c">#include &lt;stdio.h&gt;#include &lt;jni.h&gt;#include &lt;malloc.h&gt;#include &lt;android/log.h&gt;#include &quot;libavformat/avformat.h&quot;JNIEXPORT jint JNICALLJava_com_hwilliamgo_ffmpegprebuild_FFMpegUtils_getVersion(JNIEnv *env, jclass clazz) {    return avformat_version();}</code></pre><h3 id="2-如何编写CMakeLists-txt"><a href="#2-如何编写CMakeLists-txt" class="headerlink" title="2 如何编写CMakeLists.txt"></a>2 如何编写CMakeLists.txt</h3><pre><code class="cmake">cmake_minimum_required(VERSION 3.4.1)# 查找目录下的所有源文件# 并将名称保存到 DIR_SRCS 变量aux_source_directory(. DIR_SRCS)# 找到NDK提供的共享库log，并保存在变量log-lib中find_library(        log-lib        log)# 指定头文件的目录include_directories(./include)# 指定第三方动态共享库的目录link_directories(../../.././libs/${ANDROID_ABI}/)# 指定将${DIR_SRCS}目录下的源码文件编译成共享库，名字为：ffadd_library(         ff        SHARED        ${DIR_SRCS})# 指定将将第三方共享库库和你自己编译出来的共享库连接target_link_libraries(        ff        ${log-lib}        avformat        )</code></pre><h3 id="3-遇到的问题"><a href="#3-遇到的问题" class="headerlink" title="3 遇到的问题"></a>3 遇到的问题</h3><p>这里要确保一件事情：</p><p><code>link_directories()</code>指令要放在<code>add_library</code>指令之前。也就是设置第三方库的路径要放在前面。</p><p>否则会遇到找不到共享库的问题：</p><pre><code>FAILURE: Build failed with an exception.* What went wrong:Execution failed for task &#39;:ffmpegprebuild:externalNativeBuildDebug&#39;.&gt; Build command failed.  Error while executing process /Users/HWilliam/Library/Android/sdk/cmake/3.10.2.4988404/bin/ninja with arguments {-C /Users/HWilliam/AllProject/AndroidStudioProjects/windowsProject/JNILearnCMake/ffmpegprebuild/.cxx/cmake/debug/armeabi-v7a ff}  ninja: Entering directory `/Users/HWilliam/AllProject/AndroidStudioProjects/windowsProject/JNILearnCMake/ffmpegprebuild/.cxx/cmake/debug/armeabi-v7a&#39;  [1/2] Building C object CMakeFiles/ff.dir/ff.c.o  [2/2] Linking C shared library /Users/HWilliam/AllProject/AndroidStudioProjects/windowsProject/JNILearnCMake/ffmpegprebuild/build/intermediates/cmake/debug/obj/armeabi-v7a/libff.so  FAILED: /Users/HWilliam/AllProject/AndroidStudioProjects/windowsProject/JNILearnCMake/ffmpegprebuild/build/intermediates/cmake/debug/obj/armeabi-v7a/libff.so   : &amp;&amp; /Users/HWilliam/ndk/android-ndk-r20/toolchains/llvm/prebuilt/darwin-x86_64/bin/clang --target=armv7-none-linux-androideabi16 --gcc-toolchain=/Users/HWilliam/ndk/android-ndk-r20/toolchains/llvm/prebuilt/darwin-x86_64 --sysroot=/Users/HWilliam/ndk/android-ndk-r20/toolchains/llvm/prebuilt/darwin-x86_64/sysroot -fPIC -g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -fno-addrsig -march=armv7-a -mthumb -Wa,--noexecstack -Wformat -Werror=format-security  -O0 -fno-limit-debug-info  -Wl,--exclude-libs,libgcc.a -Wl,--exclude-libs,libatomic.a -static-libstdc++ -Wl,--build-id -Wl,--warn-shared-textrel -Wl,--fatal-warnings -Wl,--exclude-libs,libunwind.a -Wl,--no-undefined -Qunused-arguments -Wl,-z,noexecstack -shared -Wl,-soname,libff.so -o /Users/HWilliam/AllProject/AndroidStudioProjects/windowsProject/JNILearnCMake/ffmpegprebuild/build/intermediates/cmake/debug/obj/armeabi-v7a/libff.so CMakeFiles/ff.dir/ff.c.o  -llog -lavformat -latomic -lm &amp;&amp; :  /Users/HWilliam/ndk/android-ndk-r20/toolchains/llvm/prebuilt/darwin-x86_64/lib/gcc/arm-linux-androideabi/4.9.x/../../../../arm-linux-androideabi/bin/ld: error: cannot find -lavformat  /Users/HWilliam/AllProject/AndroidStudioProjects/windowsProject/JNILearnCMake/ffmpegprebuild/src/main/cpp/ff.c:10: error: undefined reference to &#39;avformat_version&#39;  clang: error: linker command failed with exit code 1 (use -v to see invocation)  ninja: build stopped: subcommand failed.</code></pre><p>浓缩一下：<code>error: cannot find -lavformat</code></p><p>还有就是，cmake官方不建议我们使用<code>link_directories()</code>命令：</p><p><a href="https://cmake.org/cmake/help/v3.4/command/link_directories.html" target="_blank" rel="noopener">https://cmake.org/cmake/help/v3.4/command/link_directories.html</a></p><p>该命令的文档：</p><p><strong>link_directories</strong></p><p>Specify directories in which the linker will look for libraries.</p><pre><code>link_directories(directory1 directory2 ...)</code></pre><p>Specify the paths in which the linker should search for libraries. The command will apply only to targets created after it is called. Relative paths given to this command are interpreted as relative to the current source directory, see <a href="https://cmake.org/cmake/help/v3.4/policy/CMP0015.html#policy:CMP0015" target="_blank" rel="noopener"><code>CMP0015</code></a>.</p><p>Note that this command is rarely necessary. Library locations returned by <a href="https://cmake.org/cmake/help/v3.4/command/find_package.html#command:find_package" target="_blank" rel="noopener"><code>find_package()</code></a> and <a href="https://cmake.org/cmake/help/v3.4/command/find_library.html#command:find_library" target="_blank" rel="noopener"><code>find_library()</code></a> are absolute paths. Pass these absolute library file paths directly to the <a href="https://cmake.org/cmake/help/v3.4/command/target_link_libraries.html#command:target_link_libraries" target="_blank" rel="noopener"><code>target_link_libraries()</code></a> command. CMake will ensure the linker finds them.</p><p>并且android官方也是使用的<code>find_library()</code>命令的。所以最好还是用<code>find_library()</code>命令。<br></p>]]></content>
    
    
    <categories>
      
      <category>ndk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RxJava1源码分析</title>
    <link href="/2020/01/26/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/RxJava1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2020/01/26/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/RxJava1%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>我对于RxJava的异常处理和上抛方式有一些不解，而上网查找的文章都是RxJava的一些用于处理异常的操作符，所以只能自己去源码里面找答案了。</p><p>虽然RxJava1已经过时了，但是鉴于RxJava1的源码会比RxJava2的简洁一些，因此易于分析。所以我在这里对RxJava1的源码进行分析。</p><h3 id="1-构造Observable"><a href="#1-构造Observable" class="headerlink" title="1 构造Observable"></a>1 构造Observable</h3><h4 id="1-1-create方式"><a href="#1-1-create方式" class="headerlink" title="1.1 create方式"></a>1.1 create方式</h4><pre><code class="java">Observable.create&lt;String&gt; { it: Subscriber&lt;in String&gt; -&gt;    //上游发射数据    it.onNext(&quot;123&quot;)    it.onCompleted()}.subscribe { it: String -&gt;    //下游处理数据    LogUtils.d(it)}</code></pre><p>这里看两个方法：create和subscribe</p><h5 id="1-1-1-create"><a href="#1-1-1-create" class="headerlink" title="1.1.1 create"></a>1.1.1 create</h5><p>create方法需要<code>OnSubscribe</code>接口作为参数，然后再返回一个<code>Observable</code>类型的对象（这个对象待会再调用<code>subscribe()</code>方法启动数据的发射）。</p><pre><code class="java">public final static &lt;T&gt; Observable&lt;T&gt; create(OnSubscribe&lt;T&gt; f) {    return new Observable&lt;T&gt;(hook.onCreate(f));}</code></pre><p>那么首先看：<code>hook.onCreate(f)</code>，根据注释，这是一个有<strong>装饰者模式</strong>味道的的钩子方法。</p><pre><code class="java">public abstract class RxJavaObservableExecutionHook {     /**     * Invoked during the construction by {@link Observable#create(OnSubscribe)}     * &lt;p&gt;     * This can be used to decorate or replace the &lt;code&gt;onSubscribe&lt;/code&gt; function or just perform extra     * logging, metrics and other such things and pass-thru the function.     *      * @param f     *            original {@link OnSubscribe}&lt;{@code T}&gt; to be executed     * @return {@link OnSubscribe}&lt;{@code T}&gt; function that can be modified, decorated, replaced or just     *         returned as a pass-thru     */    public &lt;T&gt; OnSubscribe&lt;T&gt; onCreate(OnSubscribe&lt;T&gt; f) {        return f;    }}</code></pre><p>默认情况下，传进来什么就返回什么，即没有加任何的装饰的逻辑。</p><p>Observable的构造函数：将<code>OnSubscribe</code>保存了起来。</p><pre><code class="java">public class Observable&lt;T&gt; {    final OnSubscribe&lt;T&gt; onSubscribe;    /**     * Creates an Observable with a Function to execute when it is subscribed to.     * &lt;p&gt;     * &lt;em&gt;Note:&lt;/em&gt; Use {@link #create(OnSubscribe)} to create an Observable, instead of this constructor,     * unless you specifically have a need for inheritance.     *      * @param f     *            {@link OnSubscribe} to be executed when {@link #subscribe(Subscriber)} is called     */    protected Observable(OnSubscribe&lt;T&gt; f) {        this.onSubscribe = f;    }}</code></pre><h5 id="1-1-2-subscribe"><a href="#1-1-2-subscribe" class="headerlink" title="1.1.2 subscribe"></a>1.1.2 subscribe</h5><pre><code class="java">public final Subscription subscribe(final Action1&lt;? super T&gt; onNext) {    if (onNext == null) {        throw new IllegalArgumentException(&quot;onNext can not be null&quot;);    }    //构造一个Subscriber，衔接onNext的方法，并调用subscribe方法返回Subscription    return subscribe(new Subscriber&lt;T&gt;() {        @Override        public final void onCompleted() {            // do nothing        }        @Override        public final void onError(Throwable e) {            throw new OnErrorNotImplementedException(e);        }        @Override        public final void onNext(T args) {            onNext.call(args);        }    });}</code></pre><p>返回的是<code>Subscription</code>，和RxJava2中的<code>Disposable</code>是一个东西：用来取消订阅</p><pre><code class="java">public interface Subscription {    void unsubscribe();    boolean isUnsubscribed();}</code></pre><p>接着看</p><pre><code class="java">public final Subscription subscribe(Subscriber&lt;? super T&gt; subscriber) {    //调用了静态方法：    return Observable.subscribe(subscriber, this);}</code></pre><pre><code class="java">private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {     // validate and proceed    if (subscriber == null) {        throw new IllegalArgumentException(&quot;observer can not be null&quot;);    }    if (observable.onSubscribe == null) {        throw new IllegalStateException(&quot;onSubscribe function can not be null.&quot;);        /*         * the subscribe function can also be overridden but generally that&#39;s not the appropriate approach         * so I won&#39;t mention that in the exception         */    }    // new Subscriber so onStart it    subscriber.onStart();    /*     * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on &quot;Guideline 6.4: Protect calls     * to user code from within an Observer&quot;     */    // if not already wrapped    if (!(subscriber instanceof SafeSubscriber)) {        // assign to `observer` so we return the protected version        subscriber = new SafeSubscriber&lt;T&gt;(subscriber);    }    // The code below is exactly the same an unsafeSubscribe but not used because it would add a sigificent depth to alreay huge call stacks.    try {        // allow the hook to intercept and/or decorate        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);        return hook.onSubscribeReturn(subscriber);    } catch (Throwable e) {        // special handling for certain Throwable/Error/Exception types        Exceptions.throwIfFatal(e);        // if an unhandled error occurs executing the onSubscribe we will propagate it        try {            subscriber.onError(hook.onSubscribeError(e));        } catch (OnErrorNotImplementedException e2) {            // special handling when onError is not implemented ... we just rethrow            throw e2;        } catch (Throwable e2) {            // if this happens it means the onError itself failed (perhaps an invalid function implementation)            // so we are unable to propagate the error correctly and will just throw            RuntimeException r = new RuntimeException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);            // TODO could the hook be the cause of the error in the on error handling.            hook.onSubscribeError(r);            // TODO why aren&#39;t we throwing the hook&#39;s return value.            throw r;        }        return Subscriptions.unsubscribed();    }}</code></pre><p>对这个<code>subsribe()</code>方法做的事情做一个总结：</p><ol><li>对参数进行验证，保证Not null</li><li>调用subscriber.onStart();</li><li>将<code>Subscriber</code>封装成<code>SafeSubscriber</code>，用装饰者模式包装了一层，在这一层加了一些额外的逻辑，但是不影响主要逻辑的执行，所以这一层的逻辑我们稍后再分析。</li><li>调用<code>OnSubsribe</code>接口的<code>call</code>方法。并捕捉异常，关于异常捕捉，稍后再分析</li></ol><p>而由于调用到第四点的<code>call</code>方法，call方法就是create方法的参数传递进去的代码块：</p><pre><code class="java">Observable.create&lt;String&gt; { it: Subscriber&lt;in String&gt; -&gt;    //上游发射数据    it.onNext(&quot;123&quot;)    it.onCompleted()}.subscribe { it: String -&gt;    //下游处理数据    LogUtils.d(it)}</code></pre><p>因此我们调用onNext传递的数据就能够在下游被处理到了。</p><h4 id="1-2-just方式"><a href="#1-2-just方式" class="headerlink" title="1.2 just方式"></a>1.2 just方式</h4><pre><code class="java">Observable.just(&quot;2&quot;)    .doOnNext {        LogUtils.d(it)    }    .subscribe {        val s: String? = null        s!!        s.toString()    }</code></pre><p>当调用<code>just</code>方法的时候，就不需要在上游手动调用<code>onNext</code>了，那么一定是<code>RxJava</code>的内部调用了<code>onNext</code>，来看下吧。</p><pre><code class="java">public final static &lt;T&gt; Observable&lt;T&gt; just(final T value) {    return ScalarSynchronousObservable.create(value);}</code></pre><p>返回了一个<code>ScalarSynchronousObservable</code>的create方法：</p><pre><code class="java">public final class ScalarSynchronousObservable&lt;T&gt; extends Observable&lt;T&gt; {    public static final &lt;T&gt; ScalarSynchronousObservable&lt;T&gt; create(T t) {        return new ScalarSynchronousObservable&lt;T&gt;(t);    }    private final T t;    protected ScalarSynchronousObservable(final T t) {        super(new OnSubscribe&lt;T&gt;() {            @Override            public void call(Subscriber&lt;? super T&gt; s) {                /*                 *  We don&#39;t check isUnsubscribed as it is a significant performance impact in the fast-path use cases.                 *  See PerfBaseline tests and https://github.com/ReactiveX/RxJava/issues/1383 for more information.                 *  The assumption here is that when asking for a single item we should emit it and not concern ourselves with                  *  being unsubscribed already. If the Subscriber unsubscribes at 0, they shouldn&#39;t have subscribed, or it will                  *  filter it out (such as take(0)). This prevents us from paying the price on every subscription.                  */                s.onNext(t);                s.onCompleted();            }        });        this.t = t;    }    //...}</code></pre><p><code>ScalarSynchronousObservable</code>的构造方法中传入的<code>OnSubscribe</code>的实现中，已经调用了<code>onNext</code>和<code>onCompleted</code>了。</p><h3 id="2-SafeSubscriber"><a href="#2-SafeSubscriber" class="headerlink" title="2 SafeSubscriber"></a>2 SafeSubscriber</h3><p>事件监听就是选择性地重写三个方法：</p><p><code>void onNext(T t);</code>，<code>void onError(Throwable e);</code>，<code>void onCompleted();</code>。</p><p>而这三个方法的关系，例如onError和onCompleted有调用互斥性等，都借由<code>SafeSubscriber</code>类实现：</p><pre><code class="java">private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) {        //...        if (!(subscriber instanceof SafeSubscriber)) {            // assign to `observer` so we return the protected version            subscriber = new SafeSubscriber&lt;T&gt;(subscriber);        }        //...    }</code></pre><pre><code class="java">public class SafeSubscriber&lt;T&gt; extends Subscriber&lt;T&gt; {    private final Subscriber&lt;? super T&gt; actual;    //事件流是否结束    boolean done = false;    //用装饰者模式，封装真正的Subscriber在actual变量中    public SafeSubscriber(Subscriber&lt;? super T&gt; actual) {        super(actual);        this.actual = actual;    }    @Override    public void onCompleted() {        //如果事件流没有结束        if (!done) {            done = true;            //将onCompleted用try catch            try {                actual.onCompleted();            } catch (Throwable e) {                //抛出致命异常                Exceptions.throwIfFatal(e);                //调用内部_onError                _onError(e);            } finally {                unsubscribe();            }        }    }    @Override    public void onError(Throwable e) {        //抛出致命异常        Exceptions.throwIfFatal(e);        if (!done) {            done = true;            //调用内部_onError            _onError(e);        }    }    @Override    public void onNext(T args) {        try {            if (!done) {                actual.onNext(args);            }        } catch (Throwable e) {            //抛出致命异常            Exceptions.throwIfFatal(e);            //回调到onError            onError(e);        }    }    //有两处会调用这里，1. onCompleted。2. onError    protected void _onError(Throwable e) {        try {            //首先调用RxJavaPlugins中的错误统一处理            RxJavaPlugins.getInstance().getErrorHandler().handleError(e);        } catch (Throwable pluginException) {            //捕捉RxJavaPlugins中的错误，并打印出来。            handlePluginException(pluginException);        }        try {            //调用真正的actual的onError            actual.onError(e);        } catch (Throwable e2) {            //补货onError中的异常            if (e2 instanceof OnErrorNotImplementedException) {                //如果异常是OnErrorNotImplementedException                //unsubscribe                try {                    unsubscribe();                } catch (Throwable unsubscribeException) {                    try {                        RxJavaPlugins.getInstance().getErrorHandler().handleError(unsubscribeException);                    } catch (Throwable pluginException) {                        handlePluginException(pluginException);                    }                    throw new RuntimeException(&quot;Observer.onError not implemented and error while unsubscribing.&quot;, new CompositeException(Arrays.asList(e, unsubscribeException)));                }                //将异常抛出                throw (OnErrorNotImplementedException) e2;            } else {                //否则，还是进行错误统一处理                try {                    RxJavaPlugins.getInstance().getErrorHandler().handleError(e2);                } catch (Throwable pluginException) {                    handlePluginException(pluginException);                }                //unsubscirbe                try {                    unsubscribe();                } catch (Throwable unsubscribeException) {                    try {                        RxJavaPlugins.getInstance().getErrorHandler().handleError(unsubscribeException);                    } catch (Throwable pluginException) {                        handlePluginException(pluginException);                    }                    throw new OnErrorFailedException(&quot;Error occurred when trying to propagate error to Observer.onError and during unsubscription.&quot;, new CompositeException(Arrays.asList(e, e2, unsubscribeException)));                }                //再将异常抛出                throw new OnErrorFailedException(&quot;Error occurred when trying to propagate error to Observer.onError&quot;, new CompositeException(Arrays.asList(e, e2)));            }        }        //unsubscribe        try {            unsubscribe();        } catch (RuntimeException unsubscribeException) {            try {                RxJavaPlugins.getInstance().getErrorHandler().handleError(unsubscribeException);            } catch (Throwable pluginException) {                handlePluginException(pluginException);            }            throw new OnErrorFailedException(unsubscribeException);        }    }    private void handlePluginException(Throwable pluginException) {        System.err.println(&quot;RxJavaErrorHandler threw an Exception. It shouldn&#39;t. =&gt; &quot; + pluginException.getMessage());        pluginException.printStackTrace();    }    public Subscriber&lt;? super T&gt; getActual() {        return actual;    }}</code></pre><h3 id="3-RxJava如何处理异常，如何上抛异常"><a href="#3-RxJava如何处理异常，如何上抛异常" class="headerlink" title="3 RxJava如何处理异常，如何上抛异常"></a>3 RxJava如何处理异常，如何上抛异常</h3><p>上文的对<code>SafeSubscriber</code>的分析可以看出RxJava对处理数据下游异常的方式：</p><ol><li>转到onError将异常抛出。</li><li>如果onError未实现，那么直接将异常抛出。</li><li>如果onError实现了，但是onError中又有异常，那么RxJava又会将异常抛出。</li></ol><p>那么如果在数据的上游，即数据发射处就发生异常了，要如何处理呢：</p><p>在Observable的构造类的函数中，最终会调用到：</p><pre><code class="java">private static &lt;T&gt; Subscription subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable) { // validate and proceed    if (subscriber == null) {        throw new IllegalArgumentException(&quot;observer can not be null&quot;);    }    if (observable.onSubscribe == null) {        throw new IllegalStateException(&quot;onSubscribe function can not be null.&quot;);        /*         * the subscribe function can also be overridden but generally that&#39;s not the appropriate approach         * so I won&#39;t mention that in the exception         */    }    // new Subscriber so onStart it    subscriber.onStart();    /*     * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on &quot;Guideline 6.4: Protect calls     * to user code from within an Observer&quot;     */    // if not already wrapped    if (!(subscriber instanceof SafeSubscriber)) {        // assign to `observer` so we return the protected version        subscriber = new SafeSubscriber&lt;T&gt;(subscriber);    }    // The code below is exactly the same an unsafeSubscribe but not used because it would add a sigificent depth to alreay huge call stacks.    try {        // allow the hook to intercept and/or decorate        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);        return hook.onSubscribeReturn(subscriber);    } catch (Throwable e) {        // special handling for certain Throwable/Error/Exception types        Exceptions.throwIfFatal(e);        // if an unhandled error occurs executing the onSubscribe we will propagate it        try {            subscriber.onError(hook.onSubscribeError(e));        } catch (OnErrorNotImplementedException e2) {            // special handling when onError is not implemented ... we just rethrow            throw e2;        } catch (Throwable e2) {            // if this happens it means the onError itself failed (perhaps an invalid function implementation)            // so we are unable to propagate the error correctly and will just throw            RuntimeException r = new RuntimeException(&quot;Error occurred attempting to subscribe [&quot; + e.getMessage() + &quot;] and then again while trying to pass to onError.&quot;, e2);            // TODO could the hook be the cause of the error in the on error handling.            hook.onSubscribeError(r);            // TODO why aren&#39;t we throwing the hook&#39;s return value.            throw r;        }        return Subscriptions.unsubscribed();    }}</code></pre><p>看一下上述的这段代码：</p><pre><code class="java">try {    //将call的调用用try catch保护起来    hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);    return hook.onSubscribeReturn(subscriber);} catch (Throwable e) {    //抛出致命异常    Exceptions.throwIfFatal(e);    try {        //调用给onError        subscriber.onError(hook.onSubscribeError(e));    } catch (OnErrorNotImplementedException e2) {        throw e2;    } catch (Throwable e2) {        RuntimeException r = new RuntimeException(&quot;Error occurred attempting to subscrib        hook.onSubscribeError(r);        throw r;    }    //unsubscribe    return Subscriptions.unsubscribed();}</code></pre><p>可以看到：数据发射处也有异常处理：交给观察者的onError处理，然后处理逻辑就又转交给观察了。</p><h3 id="4-为什么能够用操作符追加代码逻辑"><a href="#4-为什么能够用操作符追加代码逻辑" class="headerlink" title="4 为什么能够用操作符追加代码逻辑"></a>4 为什么能够用操作符追加代码逻辑</h3><h4 id="4-1-图和大致流程分析"><a href="#4-1-图和大致流程分析" class="headerlink" title="4.1 图和大致流程分析"></a>4.1 图和大致流程分析</h4><p>在进行代码分析之前，先看下这个大致的调用流程图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-d519af5b25e37b39.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>这幅图表现出来的几个点：</p><ol><li>在使用RxJava写调用链代码的时候，<code>onNext</code>等代码块是从上往下执行的，但是每当往调用链上拼接一个RxJava的处理方法例如：<code>doOnNext</code>或者<code>map</code>的时候，都会生成一个新的<code>Subscriber</code>，而当调用最底部的<code>subscribe()</code>方法的时候，调用链上每一个<code>Subscriber</code>中的<code>OnSubscribe.call()</code>方法实际上是从下往上调用的。</li><li>在图中，<code>Observable3</code>是最终的观察者创建的对象。当调用subscribe方法的时候，由<code>Observable.subscribe()</code>的源码开始，要调用<code>Observable2</code>的<code>call_2()</code>方法，而<code>call_2()</code>方法的逻辑要参考<code>Observable#lift()</code>方法的逻辑，他会将<code>Observable2</code>的<code>onNext()</code>等代码块保存并拼接在<code>Observable3</code>的<code>onNext</code>之前。然后又调用<code>Observable1</code>的<code>call_1()</code>方法…一直这么重复着往上调用各个链上的call方法。最后，调用到顶部的数据发起处的函数：<code>Observable.create</code>，他的<code>call()</code>方法使我们写好的：<code>it.onNext(&quot;123&quot;)...</code>（或者Observable.just等构造方法，里面内定了如何调用onNext方法来发射数据）。此时，顶部开始发射数据。此时，遇到他的观察者：<code>Observable1</code>的<code>onNext()</code>，那么执行内部的逻辑，并调用了<code>Observable2</code>的<code>onNext()</code>，然后执行后者内部的逻辑，然后又调用<code>Observable3</code>的…，就这样把数据不断地往调用链下部调用，最终到达底部的观察者的代码块。</li><li>大的逻辑是：从上往下增加每一个操作符，就会构造一个<code>Subscriber</code>，然后在最后调用<code>subscribe()</code>方法的时候，递归上去一个一个地调用call方法，最终到顶部的<code>onNext</code>，再递归下来，一个一个地调用开发者调用每个操作符时加入的逻辑。</li></ol><p>那么先来从简单的开始看好了：</p><pre><code class="java">Observable.create&lt;String&gt; { it: Subscriber&lt;in String&gt; -&gt;    it.onNext(&quot;123&quot;)    it.onCompleted()}.subscribe { it: String -&gt;    LogUtils.d(it)}</code></pre><p>这种类型的流程上面已经分析过了，非常简单，就是在subscribe()方法调用的时候，调用call方法里面的:</p><pre><code class="java">    it.onNext(&quot;123&quot;)    it.onCompleted()</code></pre><p>然后自然地数据就发送到了下游了。</p><p>上述是没有添加任何操作符的情况，那么如果添加操作符了呢？例如添加一个<code>doOnNext()</code></p><pre><code class="java">Observable    .create&lt;String&gt; { it: Subscriber&lt;in String&gt; -&gt;        it.onNext(&quot;123&quot;)        it.onCompleted()    }    .doOnNext {        LogUtils.d(&quot;doOnNext=$it&quot;)    }    .subscribe { it: String -&gt;        LogUtils.d(it)    }</code></pre><p>这里我们看一下doOnNext中的代码块是如何追加到调用链上的。</p><p>看实现：</p><pre><code class="java">public final Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext) {    Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {        @Override        public final void onCompleted() {        }        @Override        public final void onError(Throwable e) {        }        @Override        public final void onNext(T args) {            onNext.call(args);        }    };    //上述代码是将onNext封装到了一个Observer里面。    return lift(new OperatorDoOnEach&lt;T&gt;(observer));}</code></pre><p>这个封装过的observer，作为<code>OperatorDoOnEach</code>类的构造器的参数被传递进去，然后又作为<code>lift()</code>方法被调用，并返回一个<code>Observable</code>类型。（是的，因为这个操作符是可以直接调用subscribe()的）</p><h4 id="4-2-OperatorDoOnEach类型"><a href="#4-2-OperatorDoOnEach类型" class="headerlink" title="4.2 OperatorDoOnEach类型"></a>4.2 OperatorDoOnEach类型</h4><pre><code class="java">public class OperatorDoOnEach&lt;T&gt; implements Operator&lt;T, T&gt;</code></pre><p>他的父类型是Operator：</p><pre><code class="java">/** * Operator function for lifting into an Observable. */public interface Operator&lt;R, T&gt; extends Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt; {    // cover for generics insanity}</code></pre><p>Operator实现了Func1接口：</p><pre><code class="java">public interface Func1&lt;T, R&gt; extends Function {    R call(T t);}</code></pre><p>Func1接口的作用是：转化</p><p>调用call方法的时候：输入T，返回R。</p><p>那么Operator的作用也可以说是：转化。但是他是Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt;，因此他的转化是：输入一个观察者T，返回另一个观察者R。</p><p>那么我们也可以说Operator的作用是：给原有的观察者添加额外的逻辑。</p><p>那么说具体点：客户端的调用是：</p><pre><code class="java">Operator concreteOperator ;SubscriberB = concreteOperator.call(SubscriberA);</code></pre><p>即获取到Operator接口，然后调用call方法，进行转换。</p><p>而<code>doOnNext()</code>方法用的是<code>OperatorDoOnEach</code>：</p><pre><code class="java">public class OperatorDoOnEach&lt;T&gt; implements Operator&lt;T, T&gt; {    private final Observer&lt;? super T&gt; doOnEachObserver;    //构造方法中，保存了一个观察者，称为doOnEachObserver    public OperatorDoOnEach(Observer&lt;? super T&gt; doOnEachObserver) {        this.doOnEachObserver = doOnEachObserver;    }    //调用call方法，开始转换。call方法返回的新的观察者的每个实现，都是在参数observer的方法之前    //拼接上构造函数的doOnEachObserver的对应的方法。    @Override    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; observer) {        //传入的是observer        return new Subscriber&lt;T&gt;(observer) {            private boolean done = false;            @Override            public void onCompleted() {                if (done) {                    return;                }                //先调用doOnEachObserver.onCompleted()                try {                    doOnEachObserver.onCompleted();                } catch (Throwable e) {                    onError(e);                    return;                }                // Set `done` here so that the error in `doOnEachObserver.onCompleted()` can be noticed by observer                done = true;                //再调用observer.onCompleted()                observer.onCompleted();            }            @Override            public void onError(Throwable e) {                // need to throwIfFatal since we swallow errors after terminated                Exceptions.throwIfFatal(e);                if (done) {                    return;                }                done = true;                //先调用doOnEachObserver.onError                try {                    doOnEachObserver.onError(e);                } catch (Throwable e2) {                    observer.onError(e2);                    return;                }                //再调用observer.onError                observer.onError(e);            }            @Override            public void onNext(T value) {                if (done) {                    return;                }                //先调用doOnEachObserver.onNext                try {                    doOnEachObserver.onNext(value);                } catch (Throwable e) {                    onError(OnErrorThrowable.addValueAsLastCause(e, value));                    return;                }                //再调用observer.onNext                observer.onNext(value);            }        };    }}</code></pre><p>分析完了OperatorDoOnEach的具体实现，接下来要看下他的call方法是如何被调用的：</p><h4 id="4-3-lift-方法"><a href="#4-3-lift-方法" class="headerlink" title="4.3 lift()方法"></a>4.3 lift()方法</h4><p>接着看下<code>doOnNext()</code></p><pre><code class="java">public final Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext) {    Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {        @Override        public final void onCompleted() {        }        @Override        public final void onError(Throwable e) {        }        @Override        public final void onNext(T args) {            onNext.call(args);        }    };    //上述代码是将onNext封装到了一个Observer里面。    return lift(new OperatorDoOnEach&lt;T&gt;(observer));}</code></pre><pre><code class="java">public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) {    return new Observable&lt;R&gt;(new OnSubscribe&lt;R&gt;() {        //这个call会被上层调用        @Override        public void call(Subscriber&lt;? super R&gt; o) {            //这个o是上游调用这个return new Observable返回的观察者中的OnSubscribe的call方法传递下来的            //观察者，在本例中，由于onNext之前就是Observable.create，因此o中的call方法就是：            //    {            //        it.onNext(&quot;123&quot;);            //        it.onCompleted();            //    }            try {                //调用call，将o转换成st。                //st中的call方法的逻辑参照着OperatorDoOnEach的逻辑就是：将operator的调用逻辑追加在o的调用逻辑之前。                Subscriber&lt;? super T&gt; st = hook.onLift(operator).call(o);                try {                    // new Subscriber created and being subscribed with so &#39;onStart&#39; it                    st.onStart();                    //继续调用call方法                    onSubscribe.call(st);                } catch (Throwable e) {                    // localized capture of errors rather than it skipping all operators                     // and ending up in the try/catch of the subscribe method which then                    // prevents onErrorResumeNext and other similar approaches to error handling                    if (e instanceof OnErrorNotImplementedException) {                        throw (OnErrorNotImplementedException) e;                    }                    st.onError(e);                }            } catch (Throwable e) {                if (e instanceof OnErrorNotImplementedException) {                    throw (OnErrorNotImplementedException) e;                }                // if the lift function failed all we can do is pass the error to the final Subscriber                // as we don&#39;t have the operator available to us                o.onError(e);            }        }    });}</code></pre><p>注意，onLift方法是一个全局钩子。</p><pre><code class="java">public &lt;T, R&gt; Operator&lt;? extends R, ? super T&gt; onLift(final Operator&lt;? extends R, ? super T&gt; lift) {    //默认实现是啥都不处理直接返回。    return lift;}</code></pre><h3 id="5-常用操作符源码分析"><a href="#5-常用操作符源码分析" class="headerlink" title="5 常用操作符源码分析"></a>5 常用操作符源码分析</h3><h4 id="5-1-filter"><a href="#5-1-filter" class="headerlink" title="5.1 filter"></a>5.1 filter</h4><p>过滤</p><pre><code class="java">public final Observable&lt;T&gt; filter(Func1&lt;? super T, Boolean&gt; predicate) {    //调用lift    return lift(new OperatorFilter&lt;T&gt;(predicate));}</code></pre><pre><code class="java">public final class OperatorFilter&lt;T&gt; implements Operator&lt;T, T&gt; {    private final Func1&lt;? super T, Boolean&gt; predicate;    public OperatorFilter(Func1&lt;? super T, Boolean&gt; predicate) {        this.predicate = predicate;    }    @Override    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; child) {        return new Subscriber&lt;T&gt;(child) {            @Override            public void onCompleted() {                child.onCompleted();            }            @Override            public void onError(Throwable e) {                child.onError(e);            }            @Override            public void onNext(T t) {                try {                    //如果call方法返回true，才继续将数据向下传递                    if (predicate.call(t)) {                        child.onNext(t);                    } else {                        // TODO consider a more complicated version that batches these                        request(1);                    }                } catch (Throwable e) {                    child.onError(OnErrorThrowable.addValueAsLastCause(e, t));                }            }        };    }}</code></pre><h4 id="5-2-map"><a href="#5-2-map" class="headerlink" title="5.2 map"></a>5.2 map</h4><p>映射</p><pre><code class="java">public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) {    return lift(new OperatorMap&lt;T, R&gt;(func));}</code></pre><pre><code class="java">public final class OperatorMap&lt;T, R&gt; implements Operator&lt;R, T&gt; {    private final Func1&lt;? super T, ? extends R&gt; transformer;    public OperatorMap(Func1&lt;? super T, ? extends R&gt; transformer) {        this.transformer = transformer;    }    @Override    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super R&gt; o) {        return new Subscriber&lt;T&gt;(o) {            @Override            public void onCompleted() {                o.onCompleted();            }            @Override            public void onError(Throwable e) {                o.onError(e);            }            @Override            public void onNext(T t) {                try {                    //transformer就是映射，映射后的数据将继续向下游发射。                    o.onNext(transformer.call(t));                } catch (Throwable e) {                    Exceptions.throwIfFatal(e);                    onError(OnErrorThrowable.addValueAsLastCause(e, t));                }            }        };    }}</code></pre><p>}<br>    .doOnNext {<br>        LogUtils.d(“doOnNext=$it”)<br>    }<br>    .subscribe { it: String -&gt;<br>        LogUtils.d(it)<br>    }</p><pre><code>这里我们看一下doOnNext中的代码块是如何追加到调用链上的。看实现：``` javapublic final Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext) {    Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {        @Override        public final void onCompleted() {        }        @Override        public final void onError(Throwable e) {        }        @Override        public final void onNext(T args) {            onNext.call(args);        }    };    //上述代码是将onNext封装到了一个Observer里面。    return lift(new OperatorDoOnEach&lt;T&gt;(observer));}</code></pre><p>这个封装过的observer，作为<code>OperatorDoOnEach</code>类的构造器的参数被传递进去，然后又作为<code>lift()</code>方法被调用，并返回一个<code>Observable</code>类型。（是的，因为这个操作符是可以直接调用subscribe()的）</p><h4 id="4-2-OperatorDoOnEach类型-1"><a href="#4-2-OperatorDoOnEach类型-1" class="headerlink" title="4.2 OperatorDoOnEach类型"></a>4.2 OperatorDoOnEach类型</h4><pre><code class="java">public class OperatorDoOnEach&lt;T&gt; implements Operator&lt;T, T&gt;</code></pre><p>他的父类型是Operator：</p><pre><code class="java">/** * Operator function for lifting into an Observable. */public interface Operator&lt;R, T&gt; extends Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt; {    // cover for generics insanity}</code></pre><p>Operator实现了Func1接口：</p><pre><code class="java">public interface Func1&lt;T, R&gt; extends Function {    R call(T t);}</code></pre><p>Func1接口的作用是：转化</p><p>调用call方法的时候：输入T，返回R。</p><p>那么Operator的作用也可以说是：转化。但是他是Func1&lt;Subscriber&lt;? super R&gt;, Subscriber&lt;? super T&gt;&gt;，因此他的转化是：输入一个观察者T，返回另一个观察者R。</p><p>那么我们也可以说Operator的作用是：给原有的观察者添加额外的逻辑。</p><p>那么说具体点：客户端的调用是：</p><pre><code class="java">Operator concreteOperator ;SubscriberB = concreteOperator.call(SubscriberA);</code></pre><p>即获取到Operator接口，然后调用call方法，进行转换。</p><p>而<code>doOnNext()</code>方法用的是<code>OperatorDoOnEach</code>：</p><pre><code class="java">public class OperatorDoOnEach&lt;T&gt; implements Operator&lt;T, T&gt; {    private final Observer&lt;? super T&gt; doOnEachObserver;    //构造方法中，保存了一个观察者，称为doOnEachObserver    public OperatorDoOnEach(Observer&lt;? super T&gt; doOnEachObserver) {        this.doOnEachObserver = doOnEachObserver;    }    //调用call方法，开始转换。call方法返回的新的观察者的每个实现，都是在参数observer的方法之前    //拼接上构造函数的doOnEachObserver的对应的方法。    @Override    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; observer) {        //传入的是observer        return new Subscriber&lt;T&gt;(observer) {            private boolean done = false;            @Override            public void onCompleted() {                if (done) {                    return;                }                //先调用doOnEachObserver.onCompleted()                try {                    doOnEachObserver.onCompleted();                } catch (Throwable e) {                    onError(e);                    return;                }                // Set `done` here so that the error in `doOnEachObserver.onCompleted()` can be noticed by observer                done = true;                //再调用observer.onCompleted()                observer.onCompleted();            }            @Override            public void onError(Throwable e) {                // need to throwIfFatal since we swallow errors after terminated                Exceptions.throwIfFatal(e);                if (done) {                    return;                }                done = true;                //先调用doOnEachObserver.onError                try {                    doOnEachObserver.onError(e);                } catch (Throwable e2) {                    observer.onError(e2);                    return;                }                //再调用observer.onError                observer.onError(e);            }            @Override            public void onNext(T value) {                if (done) {                    return;                }                //先调用doOnEachObserver.onNext                try {                    doOnEachObserver.onNext(value);                } catch (Throwable e) {                    onError(OnErrorThrowable.addValueAsLastCause(e, value));                    return;                }                //再调用observer.onNext                observer.onNext(value);            }        };    }}</code></pre><p>分析完了OperatorDoOnEach的具体实现，接下来要看下他的call方法是如何被调用的：</p><h4 id="4-3-lift-方法-1"><a href="#4-3-lift-方法-1" class="headerlink" title="4.3 lift()方法"></a>4.3 lift()方法</h4><p>接着看下<code>doOnNext()</code></p><pre><code class="java">public final Observable&lt;T&gt; doOnNext(final Action1&lt;? super T&gt; onNext) {    Observer&lt;T&gt; observer = new Observer&lt;T&gt;() {        @Override        public final void onCompleted() {        }        @Override        public final void onError(Throwable e) {        }        @Override        public final void onNext(T args) {            onNext.call(args);        }    };    //上述代码是将onNext封装到了一个Observer里面。    return lift(new OperatorDoOnEach&lt;T&gt;(observer));}</code></pre><pre><code class="java">public final &lt;R&gt; Observable&lt;R&gt; lift(final Operator&lt;? extends R, ? super T&gt; operator) {    return new Observable&lt;R&gt;(new OnSubscribe&lt;R&gt;() {        //这个call会被上层调用        @Override        public void call(Subscriber&lt;? super R&gt; o) {            //这个o是上游调用这个return new Observable返回的观察者中的OnSubscribe的call方法传递下来的            //观察者，在本例中，由于onNext之前就是Observable.create，因此o中的call方法就是：            //    {            //        it.onNext(&quot;123&quot;);            //        it.onCompleted();            //    }            try {                //调用call，将o转换成st。                //st中的call方法的逻辑参照着OperatorDoOnEach的逻辑就是：将operator的调用逻辑追加在o的调用逻辑之前。                Subscriber&lt;? super T&gt; st = hook.onLift(operator).call(o);                try {                    // new Subscriber created and being subscribed with so &#39;onStart&#39; it                    st.onStart();                    //继续调用call方法                    onSubscribe.call(st);                } catch (Throwable e) {                    // localized capture of errors rather than it skipping all operators                     // and ending up in the try/catch of the subscribe method which then                    // prevents onErrorResumeNext and other similar approaches to error handling                    if (e instanceof OnErrorNotImplementedException) {                        throw (OnErrorNotImplementedException) e;                    }                    st.onError(e);                }            } catch (Throwable e) {                if (e instanceof OnErrorNotImplementedException) {                    throw (OnErrorNotImplementedException) e;                }                // if the lift function failed all we can do is pass the error to the final Subscriber                // as we don&#39;t have the operator available to us                o.onError(e);            }        }    });}</code></pre><p>注意，onLift方法是一个全局钩子。</p><pre><code class="java">public &lt;T, R&gt; Operator&lt;? extends R, ? super T&gt; onLift(final Operator&lt;? extends R, ? super T&gt; lift) {    //默认实现是啥都不处理直接返回。    return lift;}</code></pre><h3 id="5-常用操作符源码分析-1"><a href="#5-常用操作符源码分析-1" class="headerlink" title="5 常用操作符源码分析"></a>5 常用操作符源码分析</h3><h4 id="5-1-filter-1"><a href="#5-1-filter-1" class="headerlink" title="5.1 filter"></a>5.1 filter</h4><p>过滤</p><pre><code class="java">public final Observable&lt;T&gt; filter(Func1&lt;? super T, Boolean&gt; predicate) {    //调用lift    return lift(new OperatorFilter&lt;T&gt;(predicate));}</code></pre><pre><code class="java">public final class OperatorFilter&lt;T&gt; implements Operator&lt;T, T&gt; {    private final Func1&lt;? super T, Boolean&gt; predicate;    public OperatorFilter(Func1&lt;? super T, Boolean&gt; predicate) {        this.predicate = predicate;    }    @Override    public Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super T&gt; child) {        return new Subscriber&lt;T&gt;(child) {            @Override            public void onCompleted() {                child.onCompleted();            }            @Override            public void onError(Throwable e) {                child.onError(e);            }            @Override            public void onNext(T t) {                try {                    //如果call方法返回true，才继续将数据向下传递                    if (predicate.call(t)) {                        child.onNext(t);                    } else {                        // TODO consider a more complicated version that batches these                        request(1);                    }                } catch (Throwable e) {                    child.onError(OnErrorThrowable.addValueAsLastCause(e, t));                }            }        };    }}</code></pre><h4 id="5-2-map-1"><a href="#5-2-map-1" class="headerlink" title="5.2 map"></a>5.2 map</h4><p>映射</p><pre><code class="java">public final &lt;R&gt; Observable&lt;R&gt; map(Func1&lt;? super T, ? extends R&gt; func) {    return lift(new OperatorMap&lt;T, R&gt;(func));}</code></pre><p>``` java<br>public final class OperatorMap&lt;T, R&gt; implements Operator&lt;R, T&gt; {</p><pre><code>private final Func1&lt;? super T, ? extends R&gt; transformer;public OperatorMap(Func1&lt;? super T, ? extends R&gt; transformer) {    this.transformer = transformer;}@Overridepublic Subscriber&lt;? super T&gt; call(final Subscriber&lt;? super R&gt; o) {    return new Subscriber&lt;T&gt;(o) {        @Override        public void onCompleted() {            o.onCompleted();        }        @Override        public void onError(Throwable e) {            o.onError(e);        }        @Override        public void onNext(T t) {            try {                //transformer就是映射，映</code></pre>]]></content>
    
    
    <categories>
      
      <category>第三方库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Throwable的使用</title>
    <link href="/2020/01/09/Java/Throwable%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2020/01/09/Java/Throwable%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-取出Throwable的堆栈信息"><a href="#1-取出Throwable的堆栈信息" class="headerlink" title="1 取出Throwable的堆栈信息"></a>1 取出Throwable的堆栈信息</h2><p>使用Throwable一个很大的好处在于，他能保存他被实例化的方法的堆栈信息，通过方法：</p><pre><code class="java">Throwable#printStackTrace()</code></pre><p>可以将他和他的cause Throwable和他的cause的cause…( 递归 ) 的堆栈信息都打印出来。</p><p>而例如我们要将一个Throwable对象的堆栈信息不仅仅是输出到控制台，还要保存到本地日志或者发送到服务器呢？那么就要将Throwable的堆栈信息提取出来。</p><p>令人开心的是，<code>android.util.Log</code>类提供了这么一个工具方法：</p><pre><code class="java">/** * Handy function to get a loggable stack trace from a Throwable * @param tr An exception to log */public static String getStackTraceString(Throwable tr) {    if (tr == null) {        return &quot;&quot;;    }    // This is to reduce the amount of log spew that apps do in the non-error    // condition of the network being unavailable.    Throwable t = tr;    while (t != null) {        if (t instanceof UnknownHostException) {            return &quot;&quot;;        }        t = t.getCause();    }    StringWriter sw = new StringWriter();    PrintWriter pw = new PrintWriter(sw);    tr.printStackTrace(pw);    pw.flush();    return sw.toString();}</code></pre><p>通过该方法，可以直接把<code>Throwable</code>对象的堆栈信息都拿出来了。</p><h2 id="2-该如何构造一个Throwable"><a href="#2-该如何构造一个Throwable" class="headerlink" title="2 该如何构造一个Throwable"></a>2 该如何构造一个Throwable</h2><pre><code class="java">public Throwable() {    fillInStackTrace();}public Throwable(String message) {    fillInStackTrace();    detailMessage = message;}public Throwable(String message, Throwable cause) {    fillInStackTrace();    detailMessage = message;    this.cause = cause;}public Throwable(Throwable cause) {    fillInStackTrace();    detailMessage = (cause==null ? null : cause.toString());    this.cause = cause;}</code></pre><p>他有4个构造方法。每个构造方法都会调用<code>fillInStackTrace()</code>来记录当前的堆栈信息。</p><p>只有两个参数可选：String类型的message，和他的cause Throwable。</p><p>那么现在来看一下这两个变量对Throwable有什么用，以及对我们来说有什么意义。</p><p>先说结论：<code>detailMessage</code>和<code>cause</code>变量在调用<code>printStackTrace()</code>的时候都会被打印出来。</p><p>看下<code>printStackTrace()</code></p><pre><code class="java">private void printStackTrace(PrintStreamOrWriter s) {    // Guard against malicious overrides of Throwable.equals by    // using a Set with identity equality semantics.    Set&lt;Throwable&gt; dejaVu =        Collections.newSetFromMap(new IdentityHashMap&lt;Throwable, Boolean&gt;());    dejaVu.add(this);    synchronized (s.lock()) {        // Print our stack trace        //打印toString()        s.println(this);        //打印详细的堆栈信息        StackTraceElement[] trace = getOurStackTrace();        for (StackTraceElement traceElement : trace)            s.println(&quot;\tat &quot; + traceElement);        // Print suppressed exceptions, if any        for (Throwable se : getSuppressed())            se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION, &quot;\t&quot;, dejaVu);        // Print cause, if any        //打印cause        Throwable ourCause = getCause();        if (ourCause != null)            ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, &quot;&quot;, dejaVu);    }}</code></pre><p>看下<code>toString</code>是如何包含<code>message</code>进来的：</p><pre><code class="java">public String toString() {    String s = getClass().getName();    String message = getLocalizedMessage();    return (message != null) ? (s + &quot;: &quot; + message) : s;}public String getLocalizedMessage() {    return getMessage();}public String getMessage() {    return detailMessage;}</code></pre><p>看下打印cause:</p><pre><code class="java">public synchronized Throwable getCause() {    return (cause==this ? null : cause);}private void printEnclosedStackTrace(PrintStreamOrWriter s,                                     StackTraceElement[] enclosingTrace,                                     String caption,                                     String prefix,                                     Set&lt;Throwable&gt; dejaVu) {    if (dejaVu.contains(this)) {        s.println(&quot;\t[CIRCULAR REFERENCE:&quot; + this + &quot;]&quot;);    } else {        dejaVu.add(this);        // Compute number of frames in common between this and enclosing trace        StackTraceElement[] trace = getOurStackTrace();        int m = trace.length - 1;        int n = enclosingTrace.length - 1;        while (m &gt;= 0 &amp;&amp; n &gt;=0 &amp;&amp; trace[m].equals(enclosingTrace[n])) {            m--; n--;        }        int framesInCommon = trace.length - 1 - m;        // Print our stack trace        s.println(prefix + caption + this);        for (int i = 0; i &lt;= m; i++)            s.println(prefix + &quot;\tat &quot; + trace[i]);        if (framesInCommon != 0)            s.println(prefix + &quot;\t... &quot; + framesInCommon + &quot; more&quot;);        // Print suppressed exceptions, if any        for (Throwable se : getSuppressed())            se.printEnclosedStackTrace(s, trace, SUPPRESSED_CAPTION,                                       prefix +&quot;\t&quot;, dejaVu);        // Print cause, if any        //又调用了getCause()，在这里实际上是一个递归。直到找到最根源的那个cause才会停止。        Throwable ourCause = getCause();        if (ourCause != null)            ourCause.printEnclosedStackTrace(s, trace, CAUSE_CAPTION, prefix, dejaVu);    }}</code></pre><p>可以发现，<code>printEnclosedStackTrace()</code>方法中又调用了<code>getCause()</code>和<code>printEnclosedStackTrace()</code>，那么其实就是一个递归，直到递归到最根源的那个cause。</p><p>那么当我们要构造一个<code>Throwable</code>对象的时候，如果上下文中有一个关联的<code>Throwable</code>，那么把他作为cause参数来构造新的<code>Throwable</code>对象，这样能更好地记录问题真正的原因。</p><p></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>理解ijkplayer（五）解码、播放</title>
    <link href="/2019/12/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E4%BA%94%EF%BC%89%E8%A7%A3%E7%A0%81%E3%80%81%E6%92%AD%E6%94%BE/"/>
    <url>/2019/12/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E4%BA%94%EF%BC%89%E8%A7%A3%E7%A0%81%E3%80%81%E6%92%AD%E6%94%BE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p><p>我是一名打算走音视频路线的android开发者。以此系列文章开始，记录我的音视频开发学习之路</p><p>ijkplayer系列文章目录：<br><a href="https://www.jianshu.com/writer#/notebooks/40971763/notes/56760993/preview" target="_blank" rel="noopener">理解ijkplayer（一）：开始</a></p><p><a href="https://www.jianshu.com/p/b5a2584e03f1" target="_blank" rel="noopener">理解ijkplayer（二）项目结构分析</a></p><p><a href="https://www.jianshu.com/p/0501be9cf4bf" target="_blank" rel="noopener">理解ijkplayer（三）从Java层开始初始化</a></p><p><a href="https://www.jianshu.com/p/f633da0db4dd" target="_blank" rel="noopener">理解ijkplayer（四）拉流</a></p><p><a href="https://www.jianshu.com/p/1e10507f18b6" target="_blank" rel="noopener">理解ijkplayer（五）解码、播放</a></p></blockquote><hr><h2 id="1-解码线程"><a href="#1-解码线程" class="headerlink" title="1 解码线程"></a>1 解码线程</h2><h3 id="简略版代码："><a href="#简略版代码：" class="headerlink" title="简略版代码："></a>简略版代码：</h3><p>解码线程位于：<code>strem_component_open()</code>中，简略版如下：</p><pre><code class="c">static int stream_component_open(FFPlayer *ffp, int stream_index){      AVCodecContext *avctx;//解码器上下文        AVCodec *codec = NULL;//解码器    //找到解码器    codec = avcodec_find_decoder(avctx-&gt;codec_id);      switch (avctx-&gt;codec_type) {    case AVMEDIA_TYPE_AUDIO:        ret = audio_open(ffp, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt);           //decoder初始化        decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread);                //decoder启动，启动audio_thread线程        if ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, ffp, &quot;ff_audio_dec&quot;)) &lt; 0)            goto out;        break;    case AVMEDIA_TYPE_VIDEO:        //decoder初始化        decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);        ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);        if (!ffp-&gt;node_vdec)          goto fail;        //解码器开始        if ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, ffp, &quot;ff_video_dec&quot;)) &lt; 0)          goto out;        break;      case AVMEDIA_TYPE_SUBTITLE:        //decoder初始化        decoder_init(&amp;is-&gt;subdec, avctx, &amp;is-&gt;subtitleq, is-&gt;continue_read_thread);        //解码器开始        if ((ret = decoder_start(&amp;is-&gt;subdec, subtitle_thread, ffp, &quot;ff_subtitle_dec&quot;)) &lt; 0)            goto out;        break;}</code></pre><h3 id="完整版代码："><a href="#完整版代码：" class="headerlink" title="完整版代码："></a>完整版代码：</h3><pre><code class="c">/* open a given stream. Return 0 if OK */static int stream_component_open(FFPlayer *ffp, int stream_index){    VideoState *is = ffp-&gt;is;    AVFormatContext *ic = is-&gt;ic;    AVCodecContext *avctx;//解码器上下文    AVCodec *codec = NULL;//解码器    const char *forced_codec_name = NULL;    AVDictionary *opts = NULL;    AVDictionaryEntry *t = NULL;    int sample_rate, nb_channels;    int64_t channel_layout;    int ret = 0;    int stream_lowres = ffp-&gt;lowres;    if (stream_index &lt; 0 || stream_index &gt;= ic-&gt;nb_streams)        return -1;    avctx = avcodec_alloc_context3(NULL);    if (!avctx)        return AVERROR(ENOMEM);    //将AVCodecParameters中的变量赋值给AVCodecContext    ret = avcodec_parameters_to_context(avctx, ic-&gt;streams[stream_index]-&gt;codecpar);    if (ret &lt; 0)        goto fail;    av_codec_set_pkt_timebase(avctx, ic-&gt;streams[stream_index]-&gt;time_base);    //找到解码器    codec = avcodec_find_decoder(avctx-&gt;codec_id);    switch (avctx-&gt;codec_type) {        case AVMEDIA_TYPE_AUDIO   : is-&gt;last_audio_stream    = stream_index; forced_codec_name = ffp-&gt;audio_codec_name; break;        case AVMEDIA_TYPE_SUBTITLE: is-&gt;last_subtitle_stream = stream_index; forced_codec_name = ffp-&gt;subtitle_codec_name; break;        case AVMEDIA_TYPE_VIDEO   : is-&gt;last_video_stream    = stream_index; forced_codec_name = ffp-&gt;video_codec_name; break;        default: break;    }    if (forced_codec_name)        codec = avcodec_find_decoder_by_name(forced_codec_name);    if (!codec) {        if (forced_codec_name) av_log(NULL, AV_LOG_WARNING,                                      &quot;No codec could be found with name &#39;%s&#39;\n&quot;, forced_codec_name);        else                   av_log(NULL, AV_LOG_WARNING,                                      &quot;No codec could be found with id %d\n&quot;, avctx-&gt;codec_id);        ret = AVERROR(EINVAL);        goto fail;    }    avctx-&gt;codec_id = codec-&gt;id;    if(stream_lowres &gt; av_codec_get_max_lowres(codec)){        av_log(avctx, AV_LOG_WARNING, &quot;The maximum value for lowres supported by the decoder is %d\n&quot;,                av_codec_get_max_lowres(codec));        stream_lowres = av_codec_get_max_lowres(codec);    }    av_codec_set_lowres(avctx, stream_lowres);#if FF_API_EMU_EDGE    if(stream_lowres) avctx-&gt;flags |= CODEC_FLAG_EMU_EDGE;#endif    if (ffp-&gt;fast)        avctx-&gt;flags2 |= AV_CODEC_FLAG2_FAST;#if FF_API_EMU_EDGE    if(codec-&gt;capabilities &amp; AV_CODEC_CAP_DR1)        avctx-&gt;flags |= CODEC_FLAG_EMU_EDGE;#endif    opts = filter_codec_opts(ffp-&gt;codec_opts, avctx-&gt;codec_id, ic, ic-&gt;streams[stream_index], codec);    if (!av_dict_get(opts, &quot;threads&quot;, NULL, 0))        av_dict_set(&amp;opts, &quot;threads&quot;, &quot;auto&quot;, 0);    if (stream_lowres)        av_dict_set_int(&amp;opts, &quot;lowres&quot;, stream_lowres, 0);    if (avctx-&gt;codec_type == AVMEDIA_TYPE_VIDEO || avctx-&gt;codec_type == AVMEDIA_TYPE_AUDIO)        av_dict_set(&amp;opts, &quot;refcounted_frames&quot;, &quot;1&quot;, 0);    if ((ret = avcodec_open2(avctx, codec, &amp;opts)) &lt; 0) {        goto fail;    }    if ((t = av_dict_get(opts, &quot;&quot;, NULL, AV_DICT_IGNORE_SUFFIX))) {        av_log(NULL, AV_LOG_ERROR, &quot;Option %s not found.\n&quot;, t-&gt;key);#ifdef FFP_MERGE        ret =  AVERROR_OPTION_NOT_FOUND;        goto fail;#endif    }    is-&gt;eof = 0;    ic-&gt;streams[stream_index]-&gt;discard = AVDISCARD_DEFAULT;    switch (avctx-&gt;codec_type) {    case AVMEDIA_TYPE_AUDIO:#if CONFIG_AVFILTER        {            AVFilterContext *sink;            is-&gt;audio_filter_src.freq           = avctx-&gt;sample_rate;            is-&gt;audio_filter_src.channels       = avctx-&gt;channels;            is-&gt;audio_filter_src.channel_layout = get_valid_channel_layout(avctx-&gt;channel_layout, avctx-&gt;channels);            is-&gt;audio_filter_src.fmt            = avctx-&gt;sample_fmt;            SDL_LockMutex(ffp-&gt;af_mutex);            if ((ret = configure_audio_filters(ffp, ffp-&gt;afilters, 0)) &lt; 0) {                SDL_UnlockMutex(ffp-&gt;af_mutex);                goto fail;            }            ffp-&gt;af_changed = 0;            SDL_UnlockMutex(ffp-&gt;af_mutex);            sink = is-&gt;out_audio_filter;            sample_rate    = av_buffersink_get_sample_rate(sink);            nb_channels    = av_buffersink_get_channels(sink);            channel_layout = av_buffersink_get_channel_layout(sink);        }#else        sample_rate    = avctx-&gt;sample_rate;        nb_channels    = avctx-&gt;channels;        channel_layout = avctx-&gt;channel_layout;#endif        /* prepare audio output */        //audio_open方法是在做什么？        if ((ret = audio_open(ffp, channel_layout, nb_channels, sample_rate, &amp;is-&gt;audio_tgt)) &lt; 0)            goto fail;        ffp_set_audio_codec_info(ffp, AVCODEC_MODULE_NAME, avcodec_get_name(avctx-&gt;codec_id));        is-&gt;audio_hw_buf_size = ret;        is-&gt;audio_src = is-&gt;audio_tgt;        is-&gt;audio_buf_size  = 0;        is-&gt;audio_buf_index = 0;        /* init averaging filter */        is-&gt;audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);        is-&gt;audio_diff_avg_count = 0;        /* since we do not have a precise anough audio FIFO fullness,           we correct audio sync only if larger than this threshold */        is-&gt;audio_diff_threshold = 2.0 * is-&gt;audio_hw_buf_size / is-&gt;audio_tgt.bytes_per_sec;        is-&gt;audio_stream = stream_index;        is-&gt;audio_st = ic-&gt;streams[stream_index];        //decoder初始化        decoder_init(&amp;is-&gt;auddec, avctx, &amp;is-&gt;audioq, is-&gt;continue_read_thread);        if ((is-&gt;ic-&gt;iformat-&gt;flags &amp; (AVFMT_NOBINSEARCH | AVFMT_NOGENSEARCH | AVFMT_NO_BYTE_SEEK)) &amp;&amp; !is-&gt;ic-&gt;iformat-&gt;read_seek) {            is-&gt;auddec.start_pts = is-&gt;audio_st-&gt;start_time;            is-&gt;auddec.start_pts_tb = is-&gt;audio_st-&gt;time_base;        }        //decoder启动，启动audio_thread线程        if ((ret = decoder_start(&amp;is-&gt;auddec, audio_thread, ffp, &quot;ff_audio_dec&quot;)) &lt; 0)            goto out;        SDL_AoutPauseAudio(ffp-&gt;aout, 0);        break;    case AVMEDIA_TYPE_VIDEO:        is-&gt;video_stream = stream_index;        is-&gt;video_st = ic-&gt;streams[stream_index];        //async_init_decoder是一个option，默认是0        if (ffp-&gt;async_init_decoder) {            while (!is-&gt;initialized_decoder) {                SDL_Delay(5);            }            if (ffp-&gt;node_vdec) {                is-&gt;viddec.avctx = avctx;                ret = ffpipeline_config_video_decoder(ffp-&gt;pipeline, ffp);            }            if (ret || !ffp-&gt;node_vdec) {                decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);                ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);                if (!ffp-&gt;node_vdec)                    goto fail;            }        } else {            //decoder初始化            decoder_init(&amp;is-&gt;viddec, avctx, &amp;is-&gt;videoq, is-&gt;continue_read_thread);            ffp-&gt;node_vdec = ffpipeline_open_video_decoder(ffp-&gt;pipeline, ffp);            if (!ffp-&gt;node_vdec)                goto fail;        }        //解码器开始        if ((ret = decoder_start(&amp;is-&gt;viddec, video_thread, ffp, &quot;ff_video_dec&quot;)) &lt; 0)            goto out;        is-&gt;queue_attachments_req = 1;        if (ffp-&gt;max_fps &gt;= 0) {            if(is-&gt;video_st-&gt;avg_frame_rate.den &amp;&amp; is-&gt;video_st-&gt;avg_frame_rate.num) {                double fps = av_q2d(is-&gt;video_st-&gt;avg_frame_rate);                SDL_ProfilerReset(&amp;is-&gt;viddec.decode_profiler, fps + 0.5);                if (fps &gt; ffp-&gt;max_fps &amp;&amp; fps &lt; 130.0) {                    is-&gt;is_video_high_fps = 1;                    av_log(ffp, AV_LOG_WARNING, &quot;fps: %lf (too high)\n&quot;, fps);                } else {                    av_log(ffp, AV_LOG_WARNING, &quot;fps: %lf (normal)\n&quot;, fps);                }            }            if(is-&gt;video_st-&gt;r_frame_rate.den &amp;&amp; is-&gt;video_st-&gt;r_frame_rate.num) {                double tbr = av_q2d(is-&gt;video_st-&gt;r_frame_rate);                if (tbr &gt; ffp-&gt;max_fps &amp;&amp; tbr &lt; 130.0) {                    is-&gt;is_video_high_fps = 1;                    av_log(ffp, AV_LOG_WARNING, &quot;fps: %lf (too high)\n&quot;, tbr);                } else {                    av_log(ffp, AV_LOG_WARNING, &quot;fps: %lf (normal)\n&quot;, tbr);                }            }        }        if (is-&gt;is_video_high_fps) {            avctx-&gt;skip_frame       = FFMAX(avctx-&gt;skip_frame, AVDISCARD_NONREF);            avctx-&gt;skip_loop_filter = FFMAX(avctx-&gt;skip_loop_filter, AVDISCARD_NONREF);            avctx-&gt;skip_idct        = FFMAX(avctx-&gt;skip_loop_filter, AVDISCARD_NONREF);        }        break;    case AVMEDIA_TYPE_SUBTITLE:        if (!ffp-&gt;subtitle) break;        is-&gt;subtitle_stream = stream_index;        is-&gt;subtitle_st = ic-&gt;streams[stream_index];        ffp_set_subtitle_codec_info(ffp, AVCODEC_MODULE_NAME, avcodec_get_name(avctx-&gt;codec_id));        decoder_init(&amp;is-&gt;subdec, avctx, &amp;is-&gt;subtitleq, is-&gt;continue_read_thread);        if ((ret = decoder_start(&amp;is-&gt;subdec, subtitle_thread, ffp, &quot;ff_subtitle_dec&quot;)) &lt; 0)            goto out;        break;    default:        break;    }    goto out;fail:    avcodec_free_context(&amp;avctx);out:    av_dict_free(&amp;opts);    return ret;}</code></pre><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><ol><li>找到解码器</li><li>初始化解码器</li><li>分别启动<code>audio_thread</code>，<code>video_thread</code>和<code>subtitle_thread</code>这3条解码线程，内部开始不断解码。</li></ol><p>那么以下3节则逐个分析这3条解码线程</p><h2 id="2-字幕解码线程subtitle-thread"><a href="#2-字幕解码线程subtitle-thread" class="headerlink" title="2 字幕解码线程subtitle_thread"></a>2 字幕解码线程<code>subtitle_thread</code></h2><p>由于字幕解码线程最简单，所以先来看看他是如何工作的，对剩下的两个解码线程就更好理解了。</p><pre><code class="c">static int subtitle_thread(void *arg){    FFPlayer *ffp = arg;    VideoState *is = ffp-&gt;is;    Frame *sp;    int got_subtitle;    double pts;    for (;;) {        //阻塞方法，阻塞，直到能取出windex（写下标）下标下的Frame        if (!(sp = frame_queue_peek_writable(&amp;is-&gt;subpq)))            return 0;        //解码，填充Frame中的字幕数据        if ((got_subtitle = decoder_decode_frame(ffp, &amp;is-&gt;subdec, NULL, &amp;sp-&gt;sub)) &lt; 0)            break;        pts = 0;#ifdef FFP_MERGE        if (got_subtitle &amp;&amp; sp-&gt;sub.format == 0) {#else        if (got_subtitle) {#endif            if (sp-&gt;sub.pts != AV_NOPTS_VALUE)                pts = sp-&gt;sub.pts / (double)AV_TIME_BASE;            sp-&gt;pts = pts;            sp-&gt;serial = is-&gt;subdec.pkt_serial;            sp-&gt;width = is-&gt;subdec.avctx-&gt;width;            sp-&gt;height = is-&gt;subdec.avctx-&gt;height;            sp-&gt;uploaded = 0;            /* now we can update the picture count */            //后移字幕FrameQueue的windex            frame_queue_push(&amp;is-&gt;subpq);#ifdef FFP_MERGE        } else if (got_subtitle) {            avsubtitle_free(&amp;sp-&gt;sub);#endif        }    }    return 0;}</code></pre><p>解码后的数据<code>sp</code>要保存，留着待会渲染，也就是要入队，那么由于<code>FrameQueue</code>是数组的特殊性，因此入队的操作不需要新建的frame数据作为参数，只需要确保数组中的write index的数据正确填充，然后将write index后移一个位置，就称为入队成功了：</p><pre><code class="c">static void  frame_queue_push(FrameQueue *f){    //当使用数组作为队列的时候，只需要移动数组中的下标到有效下标，就表示入队了，并不需要外部再传一个参数进来。    //如果到了尾下标，则windex回到起点。这是用数组作为循环队列的必要操作。    if (++f-&gt;windex == f-&gt;max_size)        f-&gt;windex = 0;    SDL_LockMutex(f-&gt;mutex);    f-&gt;size++;    SDL_CondSignal(f-&gt;cond);    SDL_UnlockMutex(f-&gt;mutex);}</code></pre><p>那么接着来看：<code>decoder_decode_frame（）</code></p><p>注意：本文基于0.8.0的ijkplayer，这个函数和以前的ijkplayer的解码逻辑和调用的ffmpeg的函数都有些区别。我看到0.8.0的版本的<code>decoder_decode_frame（）</code>函数的逻辑是在<code>0.8.7</code>的时候修改并上线的。</p><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h3 id="2-1-decoder-decode-frame-，since-version-0-8-7"><a href="#2-1-decoder-decode-frame-，since-version-0-8-7" class="headerlink" title="2.1 decoder_decode_frame()，since version 0.8.7"></a>2.1 <code>decoder_decode_frame()</code>，since version 0.8.7</h3><p>先看本文基于的0.8.0的ijkplayer的函数：</p><pre><code class="c">static int decoder_decode_frame(FFPlayer *ffp, Decoder *d, AVFrame *frame, AVSubtitle *sub) {    int ret = AVERROR(EAGAIN);    for (;;) {        AVPacket pkt;        if (d-&gt;queue-&gt;serial == d-&gt;pkt_serial) {            do {                if (d-&gt;queue-&gt;abort_request)                    return -1;                switch (d-&gt;avctx-&gt;codec_type) {                    case AVMEDIA_TYPE_VIDEO:                        //从解码器中接收frame数据。当返回0表示成功                        ret = avcodec_receive_frame(d-&gt;avctx, frame);                        if (ret &gt;= 0) {                            ffp-&gt;stat.vdps = SDL_SpeedSamplerAdd(&amp;ffp-&gt;vdps_sampler, FFP_SHOW_VDPS_AVCODEC, &quot;vdps[avcodec]&quot;);                            if (ffp-&gt;decoder_reorder_pts == -1) {                                frame-&gt;pts = frame-&gt;best_effort_timestamp;                            } else if (!ffp-&gt;decoder_reorder_pts) {                                frame-&gt;pts = frame-&gt;pkt_dts;                            }                        }                        break;                    case AVMEDIA_TYPE_AUDIO:                        //从解码器中接收frame数据。当返回0表示成功                        ret = avcodec_receive_frame(d-&gt;avctx, frame);                        if (ret &gt;= 0) {                            AVRational tb = (AVRational){1, frame-&gt;sample_rate};                            if (frame-&gt;pts != AV_NOPTS_VALUE)                                frame-&gt;pts = av_rescale_q(frame-&gt;pts, av_codec_get_pkt_timebase(d-&gt;avctx), tb);                            else if (d-&gt;next_pts != AV_NOPTS_VALUE)                                frame-&gt;pts = av_rescale_q(d-&gt;next_pts, d-&gt;next_pts_tb, tb);                            if (frame-&gt;pts != AV_NOPTS_VALUE) {                                d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;                                d-&gt;next_pts_tb = tb;                            }                        }                        break;                    default:                        break;                }                if (ret == AVERROR_EOF) {                    d-&gt;finished = d-&gt;pkt_serial;                    avcodec_flush_buffers(d-&gt;avctx);                    return 0;                }                //如果返回值&gt;=0，表示avcodec_receive_frame函数解码成功，那么从外部函数decoder_decode_frame返回1。                //视频，音频，字幕的解码都从这里返回，只要解码成功，都去读取ret然后返回给外面处理。                if (ret &gt;= 0)                    return 1;            } while (ret != AVERROR(EAGAIN));        }        do {            if (d-&gt;queue-&gt;nb_packets == 0)                SDL_CondSignal(d-&gt;empty_queue_cond);            if (d-&gt;packet_pending) {                av_packet_move_ref(&amp;pkt, &amp;d-&gt;pkt);                d-&gt;packet_pending = 0;            } else {                //从packet_queue中取出pkt，当packat_queue由于网络差等原因，没有足够的包可以取出时，则阻塞，直到有包能取出。                if (packet_queue_get_or_buffering(ffp, d-&gt;queue, &amp;pkt, &amp;d-&gt;pkt_serial, &amp;d-&gt;finished) &lt; 0)                    return -1;            }        } while (d-&gt;queue-&gt;serial != d-&gt;pkt_serial);        if (pkt.data == flush_pkt.data) {            avcodec_flush_buffers(d-&gt;avctx);            d-&gt;finished = 0;            d-&gt;next_pts = d-&gt;start_pts;            d-&gt;next_pts_tb = d-&gt;start_pts_tb;        } else {            if (d-&gt;avctx-&gt;codec_type == AVMEDIA_TYPE_SUBTITLE) {                int got_frame = 0;                //解码字幕                ret = avcodec_decode_subtitle2(d-&gt;avctx, sub, &amp;got_frame, &amp;pkt);                if (ret &lt; 0) {                    ret = AVERROR(EAGAIN);                } else {                    if (got_frame &amp;&amp; !pkt.data) {                       d-&gt;packet_pending = 1;                       av_packet_move_ref(&amp;d-&gt;pkt, &amp;pkt);                    }                    ret = got_frame ? 0 : (pkt.data ? AVERROR(EAGAIN) : AVERROR_EOF);                }            } else {                //往解码器里面发送包数据pkt                if (avcodec_send_packet(d-&gt;avctx, &amp;pkt) == AVERROR(EAGAIN)) {                    av_log(d-&gt;avctx, AV_LOG_ERROR, &quot;Receive_frame and send_packet both returned EAGAIN, which is an API violation.\n&quot;);                    d-&gt;packet_pending = 1;                    av_packet_move_ref(&amp;d-&gt;pkt, &amp;pkt);                }            }            av_packet_unref(&amp;pkt);        }    }}</code></pre><h3 id="2-2-decoder-decode-frame-，before-version-0-8-7"><a href="#2-2-decoder-decode-frame-，before-version-0-8-7" class="headerlink" title="2.2 decoder_decode_frame()，before version 0.8.7"></a>2.2 <code>decoder_decode_frame()</code>，before version 0.8.7</h3><pre><code class="c">static int decoder_decode_frame(FFPlayer *ffp, Decoder *d, AVFrame *frame, AVSubtitle *sub) {    int got_frame = 0;    do {        int ret = -1;        if (d-&gt;queue-&gt;abort_request)            return -1;        if (!d-&gt;packet_pending || d-&gt;queue-&gt;serial != d-&gt;pkt_serial) {            AVPacket pkt;            do {                if (d-&gt;queue-&gt;nb_packets == 0)                    SDL_CondSignal(d-&gt;empty_queue_cond);                  //从packet_queue中获取pkt                if (packet_queue_get_or_buffering(ffp, d-&gt;queue, &amp;pkt, &amp;d-&gt;pkt_serial, &amp;d-&gt;finished) &lt; 0)                    return -1;                if (pkt.data == flush_pkt.data) {                    avcodec_flush_buffers(d-&gt;avctx);                    d-&gt;finished = 0;                    d-&gt;next_pts = d-&gt;start_pts;                    d-&gt;next_pts_tb = d-&gt;start_pts_tb;                }            } while (pkt.data == flush_pkt.data || d-&gt;queue-&gt;serial != d-&gt;pkt_serial);            av_packet_unref(&amp;d-&gt;pkt);              //将包pkt传递给解码器d            d-&gt;pkt_temp = d-&gt;pkt = pkt;            d-&gt;packet_pending = 1;        }        switch (d-&gt;avctx-&gt;codec_type) {            case AVMEDIA_TYPE_VIDEO: {                  //调用ffmpeg方法：avcodec_deco_video2()来解码。                ret = avcodec_decode_video2(d-&gt;avctx, frame, &amp;got_frame, &amp;d-&gt;pkt_temp);                if (got_frame) {                    ffp-&gt;stat.vdps = SDL_SpeedSamplerAdd(&amp;ffp-&gt;vdps_sampler, FFP_SHOW_VDPS_AVCODEC, &quot;vdps[avcodec]&quot;);                    if (ffp-&gt;decoder_reorder_pts == -1) {                        frame-&gt;pts = av_frame_get_best_effort_timestamp(frame);                    } else if (!ffp-&gt;decoder_reorder_pts) {                        frame-&gt;pts = frame-&gt;pkt_dts;                    }                }                }                break;            case AVMEDIA_TYPE_AUDIO:                    //调用ffmpeg方法：avcodec_decode_audio4()来解码                ret = avcodec_decode_audio4(d-&gt;avctx, frame, &amp;got_frame, &amp;d-&gt;pkt_temp);                if (got_frame) {                    AVRational tb = (AVRational){1, frame-&gt;sample_rate};                    if (frame-&gt;pts != AV_NOPTS_VALUE)                        frame-&gt;pts = av_rescale_q(frame-&gt;pts, av_codec_get_pkt_timebase(d-&gt;avctx), tb);                    else if (d-&gt;next_pts != AV_NOPTS_VALUE)                        frame-&gt;pts = av_rescale_q(d-&gt;next_pts, d-&gt;next_pts_tb, tb);                    if (frame-&gt;pts != AV_NOPTS_VALUE) {                        d-&gt;next_pts = frame-&gt;pts + frame-&gt;nb_samples;                        d-&gt;next_pts_tb = tb;                    }                }                break;            case AVMEDIA_TYPE_SUBTITLE:                ret = avcodec_decode_subtitle2(d-&gt;avctx, sub, &amp;got_frame, &amp;d-&gt;pkt_temp);                break;            default:                break;        }        if (ret &lt; 0) {            d-&gt;packet_pending = 0;        } else {            d-&gt;pkt_temp.dts =            d-&gt;pkt_temp.pts = AV_NOPTS_VALUE;            if (d-&gt;pkt_temp.data) {                if (d-&gt;avctx-&gt;codec_type != AVMEDIA_TYPE_AUDIO)                    ret = d-&gt;pkt_temp.size;                d-&gt;pkt_temp.data += ret;                d-&gt;pkt_temp.size -= ret;                if (d-&gt;pkt_temp.size &lt;= 0)                    d-&gt;packet_pending = 0;            } else {                if (!got_frame) {                    d-&gt;packet_pending = 0;                    d-&gt;finished = d-&gt;pkt_serial;                }            }        }    } while (!got_frame &amp;&amp; !d-&gt;finished);    return got_frame;}</code></pre><p>那么再看回到最新的<code>decoder_decode_frame()</code>方法中，首先解码器要从包队列<code>PakcetQueue</code>中读取出包数据，再输送到ffmpeg解码器中。那么这个读取包队列中已经缓存好的包数据的方法是：</p><pre><code class="c">static int packet_queue_get_or_buffering(FFPlayer *ffp, PacketQueue *q, AVPacket *pkt, int *serial, int *finished){    assert(finished);    if (!ffp-&gt;packet_buffering)        return packet_queue_get(q, pkt, 1, serial);    while (1) {        int new_packet = packet_queue_get(q, pkt, 0, serial);        if (new_packet &lt; 0)            return -1;        else if (new_packet == 0) {            //=0表示no packet，因此要再取            if (q-&gt;is_buffer_indicator &amp;&amp; !*finished)                ffp_toggle_buffering(ffp, 1);            //阻塞，直到从包队列中取出队列头的包，并填充到pkt            new_packet = packet_queue_get(q, pkt, 1, serial);            if (new_packet &lt; 0)                return -1;        }        if (*finished == *serial) {            av_packet_unref(pkt);            continue;        }        else            break;    }    return 1;}</code></pre><p>即读取包pkt是会阻塞的，直到<code>3.6.4</code>章节介绍的视频读取线程读取并解封装包pkt，并放入<code>PacketQueue</code>，这里才能从阻塞返回并继续塞给解码器。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ol><li><p>0.8.7开始，<code>decode_decode_frame()</code>函数借助ffmpeg的两个方法来完成解码：</p><ol><li><code>int avcodec_send_packet(AVCodecContex* *avctx, const AVPacket *avpkt);</code>往解码器里面发送pkt数据。</li><li><code>int avcodec_receive_frame(AVCodecContext *avctx, AVFrame *frame);</code>从解码器里面读取出frame帧数据。</li></ol></li><li><p>而在0.8.7之前，音频和视频的解码都各自分别使用一个不同的解码函数：</p><ol><li><p>视频：</p><pre><code class="c">//已被废弃int avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture,                         int *got_picture_ptr,                         const AVPacket *avpkt);</code></pre></li><li><p>音频：</p><pre><code class="c">//已被废弃int avcodec_decode_audio4(AVCodecContext *avctx, AVFrame *frame,                          int *got_frame_ptr, const AVPacket *avpkt)</code></pre></li></ol></li><li><p>解码字幕的函数：</p><pre><code class="c">int avcodec_decode_subtitle2(AVCodecContext *avctx, AVSubtitle *sub,                            int *got_sub_ptr,                            AVPacket *avpkt);</code></pre></li><li><p>从字幕的解码流程中可以看出解码的大致逻辑为：</p><ol><li>循环地调用<code>decoder_decode_frame（）</code>，在这个方法里面对视频，音频和字幕3种流用switch语句来分别处理解码。当然，在音频解码<code>audio_thread</code>和视频解码<code>video_thread</code>中同样会调用这个方法的。</li><li>解码前，先从<code>PacketQueue</code>读取包数据，这个数据从哪里来？从<code>read_thread()</code>函数中调用的ffmpeg的函数：<code>av_read_frame(ic, pkt);</code>来的。</li><li>解码时，先塞给解码器pkt数据，再从解码器中读出解码好的frame数据。</li><li>再把frame数据入队<code>FrameQueue</code>，留给稍后的渲染器来从<code>FrameQueue</code>中读取 </li></ol></li></ol><h2 id="3-音频解码线程audio-thread"><a href="#3-音频解码线程audio-thread" class="headerlink" title="3 音频解码线程audio_thread"></a>3 音频解码线程<code>audio_thread</code></h2><pre><code class="c">static int audio_thread(void *arg){    FFPlayer *ffp = arg;    VideoState *is = ffp-&gt;is;    AVFrame *frame = av_frame_alloc();//分配一个AVFrame    Frame *af;//从FrameQueue sampq中取出来的，要写入数据的Frame#if CONFIG_AVFILTER    int last_serial = -1;    int64_t dec_channel_layout;    int reconfigure;#endif    int got_frame = 0;    AVRational tb;//分子分母对(ffmpeg为了准确性和避免转换，定义了一个分子分母对来取代float)    int ret = 0;    int audio_accurate_seek_fail = 0;    int64_t audio_seek_pos = 0;    double frame_pts = 0;    double audio_clock = 0;    int64_t now = 0;    double samples_duration = 0;    int64_t deviation = 0;    int64_t deviation2 = 0;    int64_t deviation3 = 0;    if (!frame)        return AVERROR(ENOMEM);    do {        ffp_audio_statistic_l(ffp);        //音频解码        if ((got_frame = decoder_decode_frame(ffp, &amp;is-&gt;auddec, frame, NULL)) &lt; 0)            goto the_end;        //当解码成功        if (got_frame) {                tb = (AVRational){1, frame-&gt;sample_rate};                //处理accurate_seek                if (ffp-&gt;enable_accurate_seek &amp;&amp; is-&gt;audio_accurate_seek_req &amp;&amp; !is-&gt;seek_req) {                    frame_pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);                    now = av_gettime_relative() / 1000;                    if (!isnan(frame_pts)) {                        samples_duration = (double) frame-&gt;nb_samples / frame-&gt;sample_rate;                        audio_clock = frame_pts + samples_duration;                        is-&gt;accurate_seek_aframe_pts = audio_clock * 1000 * 1000;                        audio_seek_pos = is-&gt;seek_pos;                        deviation = llabs((int64_t)(audio_clock * 1000 * 1000) - is-&gt;seek_pos);                        if ((audio_clock * 1000 * 1000 &lt; is-&gt;seek_pos ) || deviation &gt; MAX_DEVIATION) {                            if (is-&gt;drop_aframe_count == 0) {                                SDL_LockMutex(is-&gt;accurate_seek_mutex);                                if (is-&gt;accurate_seek_start_time &lt;= 0 &amp;&amp; (is-&gt;video_stream &lt; 0 || is-&gt;video_accurate_seek_req)) {                                    is-&gt;accurate_seek_start_time = now;                                }                                SDL_UnlockMutex(is-&gt;accurate_seek_mutex);                                av_log(NULL, AV_LOG_INFO, &quot;audio accurate_seek start, is-&gt;seek_pos=%lld, audio_clock=%lf, is-&gt;accurate_seek_start_time = %lld\n&quot;, is-&gt;seek_pos, audio_clock, is-&gt;accurate_seek_start_time);                            }                            is-&gt;drop_aframe_count++;                            while (is-&gt;video_accurate_seek_req &amp;&amp; !is-&gt;abort_request) {                                int64_t vpts = is-&gt;accurate_seek_vframe_pts;                                deviation2 = vpts  - audio_clock * 1000 * 1000;                                deviation3 = vpts  - is-&gt;seek_pos;                                if (deviation2 &gt; -100 * 1000 &amp;&amp; deviation3 &lt; 0) {                                    break;                                } else {                                    av_usleep(20 * 1000);                                }                                now = av_gettime_relative() / 1000;                                if ((now - is-&gt;accurate_seek_start_time) &gt; ffp-&gt;accurate_seek_timeout) {                                    break;                                }                            }                            if(!is-&gt;video_accurate_seek_req &amp;&amp; is-&gt;video_stream &gt;= 0 &amp;&amp; audio_clock * 1000 * 1000 &gt; is-&gt;accurate_seek_vframe_pts) {                                audio_accurate_seek_fail = 1;                            } else {                                now = av_gettime_relative() / 1000;                                if ((now - is-&gt;accurate_seek_start_time) &lt;= ffp-&gt;accurate_seek_timeout) {                                    av_frame_unref(frame);                                    continue;  // drop some old frame when do accurate seek                                } else {                                    audio_accurate_seek_fail = 1;                                }                            }                        } else {                            if (audio_seek_pos == is-&gt;seek_pos) {                                av_log(NULL, AV_LOG_INFO, &quot;audio accurate_seek is ok, is-&gt;drop_aframe_count=%d, audio_clock = %lf\n&quot;, is-&gt;drop_aframe_count, audio_clock);                                is-&gt;drop_aframe_count       = 0;                                SDL_LockMutex(is-&gt;accurate_seek_mutex);                                is-&gt;audio_accurate_seek_req = 0;                                SDL_CondSignal(is-&gt;video_accurate_seek_cond);                                if (audio_seek_pos == is-&gt;seek_pos &amp;&amp; is-&gt;video_accurate_seek_req &amp;&amp; !is-&gt;abort_request) {                                    SDL_CondWaitTimeout(is-&gt;audio_accurate_seek_cond, is-&gt;accurate_seek_mutex, ffp-&gt;accurate_seek_timeout);                                } else {                                    ffp_notify_msg2(ffp, FFP_MSG_ACCURATE_SEEK_COMPLETE, (int)(audio_clock * 1000));                                }                                if (audio_seek_pos != is-&gt;seek_pos &amp;&amp; !is-&gt;abort_request) {                                    is-&gt;audio_accurate_seek_req = 1;                                    SDL_UnlockMutex(is-&gt;accurate_seek_mutex);                                    av_frame_unref(frame);                                    continue;                                }                                SDL_UnlockMutex(is-&gt;accurate_seek_mutex);                            }                        }                    } else {                        audio_accurate_seek_fail = 1;                    }                    if (audio_accurate_seek_fail) {                        av_log(NULL, AV_LOG_INFO, &quot;audio accurate_seek is error, is-&gt;drop_aframe_count=%d, now = %lld, audio_clock = %lf\n&quot;, is-&gt;drop_aframe_count, now, audio_clock);                        is-&gt;drop_aframe_count       = 0;                        SDL_LockMutex(is-&gt;accurate_seek_mutex);                        is-&gt;audio_accurate_seek_req = 0;                        SDL_CondSignal(is-&gt;video_accurate_seek_cond);                        if (is-&gt;video_accurate_seek_req &amp;&amp; !is-&gt;abort_request) {                            SDL_CondWaitTimeout(is-&gt;audio_accurate_seek_cond, is-&gt;accurate_seek_mutex, ffp-&gt;accurate_seek_timeout);                        } else {                            ffp_notify_msg2(ffp, FFP_MSG_ACCURATE_SEEK_COMPLETE, (int)(audio_clock * 1000));                        }                        SDL_UnlockMutex(is-&gt;accurate_seek_mutex);                    }                    is-&gt;accurate_seek_start_time = 0;                    audio_accurate_seek_fail = 0;                }#if CONFIG_AVFILTER                dec_channel_layout = get_valid_channel_layout(frame-&gt;channel_layout, frame-&gt;channels);                reconfigure =                    cmp_audio_fmts(is-&gt;audio_filter_src.fmt, is-&gt;audio_filter_src.channels,                                   frame-&gt;format, frame-&gt;channels)    ||                    is-&gt;audio_filter_src.channel_layout != dec_channel_layout ||                    is-&gt;audio_filter_src.freq           != frame-&gt;sample_rate ||                    is-&gt;auddec.pkt_serial               != last_serial        ||                    ffp-&gt;af_changed;                if (reconfigure) {                    SDL_LockMutex(ffp-&gt;af_mutex);                    ffp-&gt;af_changed = 0;                    char buf1[1024], buf2[1024];                    av_get_channel_layout_string(buf1, sizeof(buf1), -1, is-&gt;audio_filter_src.channel_layout);                    av_get_channel_layout_string(buf2, sizeof(buf2), -1, dec_channel_layout);                    av_log(NULL, AV_LOG_DEBUG,                           &quot;Audio frame changed from rate:%d ch:%d fmt:%s layout:%s serial:%d to rate:%d ch:%d fmt:%s layout:%s serial:%d\n&quot;,                           is-&gt;audio_filter_src.freq, is-&gt;audio_filter_src.channels, av_get_sample_fmt_name(is-&gt;audio_filter_src.fmt), buf1, last_serial,                           frame-&gt;sample_rate, frame-&gt;channels, av_get_sample_fmt_name(frame-&gt;format), buf2, is-&gt;auddec.pkt_serial);                    is-&gt;audio_filter_src.fmt            = frame-&gt;format;                    is-&gt;audio_filter_src.channels       = frame-&gt;channels;                    is-&gt;audio_filter_src.channel_layout = dec_channel_layout;                    is-&gt;audio_filter_src.freq           = frame-&gt;sample_rate;                    last_serial                         = is-&gt;auddec.pkt_serial;                    if ((ret = configure_audio_filters(ffp, ffp-&gt;afilters, 1)) &lt; 0) {                        SDL_UnlockMutex(ffp-&gt;af_mutex);                        goto the_end;                    }                    SDL_UnlockMutex(ffp-&gt;af_mutex);                }            if ((ret = av_buffersrc_add_frame(is-&gt;in_audio_filter, frame)) &lt; 0)                goto the_end;            while ((ret = av_buffersink_get_frame_flags(is-&gt;out_audio_filter, frame, 0)) &gt;= 0) {                tb = av_buffersink_get_time_base(is-&gt;out_audio_filter);#endif                if (!(af = frame_queue_peek_writable(&amp;is-&gt;sampq)))//如果sampq无法写入，则失败                    goto the_end;                af-&gt;pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);                af-&gt;pos = frame-&gt;pkt_pos;                af-&gt;serial = is-&gt;auddec.pkt_serial;                af-&gt;duration = av_q2d((AVRational){frame-&gt;nb_samples, frame-&gt;sample_rate});                //Move everything contained in src to dst and reset src.将解码出来的AVFrame传给af-&gt;frame                av_frame_move_ref(af-&gt;frame, frame);                //将af-&gt;frame入队                frame_queue_push(&amp;is-&gt;sampq);#if CONFIG_AVFILTER                if (is-&gt;audioq.serial != is-&gt;auddec.pkt_serial)                    break;            }            if (ret == AVERROR_EOF)                is-&gt;auddec.finished = is-&gt;auddec.pkt_serial;#endif        }    } while (ret &gt;= 0 || ret == AVERROR(EAGAIN) || ret == AVERROR_EOF); the_end:#if CONFIG_AVFILTER    avfilter_graph_free(&amp;is-&gt;agraph);#endif    av_frame_free(&amp;frame);    return ret;}</code></pre><p>音频解码这里暂时不去分析解码之后的seek操作，所以和字幕解码没什么差别，没什么好分析的。</p><h2 id="4-视频解码线程video-thread"><a href="#4-视频解码线程video-thread" class="headerlink" title="4 视频解码线程video_thread"></a>4 视频解码线程<code>video_thread</code></h2><p>终于来到视频解码了…</p><pre><code class="c">static int video_thread(void *arg){    FFPlayer *ffp = (FFPlayer *)arg;    int       ret = 0;        //如果node_vdec不为null。    if (ffp-&gt;node_vdec) {          //调用解码器的解码方法，进入循环        ret = ffpipenode_run_sync(ffp-&gt;node_vdec);    }    return ret;}</code></pre><p>最后是走到了<code>IJKFF_Pipenode</code>的<code>func_run_sync()</code>函数中</p><pre><code class="c">static int ffplay_video_thread(void *arg){    FFPlayer *ffp = arg;    VideoState *is = ffp-&gt;is;    AVFrame *frame = av_frame_alloc();//创建一个新的AVFrame    double pts;    double duration;    int ret;    AVRational tb = is-&gt;video_st-&gt;time_base;    AVRational frame_rate = av_guess_frame_rate(is-&gt;ic, is-&gt;video_st, NULL);    int64_t dst_pts = -1;    int64_t last_dst_pts = -1;    int retry_convert_image = 0;    int convert_frame_count = 0;#if CONFIG_AVFILTER    AVFilterGraph *graph = avfilter_graph_alloc();    AVFilterContext *filt_out = NULL, *filt_in = NULL;    int last_w = 0;    int last_h = 0;    enum AVPixelFormat last_format = -2;    int last_serial = -1;    int last_vfilter_idx = 0;    if (!graph) {        av_frame_free(&amp;frame);        return AVERROR(ENOMEM);    }#else    ffp_notify_msg2(ffp, FFP_MSG_VIDEO_ROTATION_CHANGED, ffp_get_video_rotate_degrees(ffp));#endif    if (!frame) {#if CONFIG_AVFILTER        avfilter_graph_free(&amp;graph);#endif        return AVERROR(ENOMEM);    }    //开启无限循环，无限地去从packet_queue中拿取pkt来解码。    for (;;) {        ret = get_video_frame(ffp, frame);//解码，并将解码后的帧数据存放在frame中        if (ret &lt; 0)            goto the_end;        if (!ret)            continue;        if (ffp-&gt;get_frame_mode) {            if (!ffp-&gt;get_img_info || ffp-&gt;get_img_info-&gt;count &lt;= 0) {                av_frame_unref(frame);                continue;            }            last_dst_pts = dst_pts;            if (dst_pts &lt; 0) {                dst_pts = ffp-&gt;get_img_info-&gt;start_time;            } else {                dst_pts += (ffp-&gt;get_img_info-&gt;end_time - ffp-&gt;get_img_info-&gt;start_time) / (ffp-&gt;get_img_info-&gt;num - 1);            }            pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);            pts = pts * 1000;            if (pts &gt;= dst_pts) {                while (retry_convert_image &lt;= MAX_RETRY_CONVERT_IMAGE) {                    ret = convert_image(ffp, frame, (int64_t)pts, frame-&gt;width, frame-&gt;height);                    if (!ret) {                        convert_frame_count++;                        break;                    }                    retry_convert_image++;                    av_log(NULL, AV_LOG_ERROR, &quot;convert image error retry_convert_image = %d\n&quot;, retry_convert_image);                }                retry_convert_image = 0;                if (ret || ffp-&gt;get_img_info-&gt;count &lt;= 0) {                    if (ret) {                        av_log(NULL, AV_LOG_ERROR, &quot;convert image abort ret = %d\n&quot;, ret);                        ffp_notify_msg3(ffp, FFP_MSG_GET_IMG_STATE, 0, ret);                    } else {                        av_log(NULL, AV_LOG_INFO, &quot;convert image complete convert_frame_count = %d\n&quot;, convert_frame_count);                    }                    goto the_end;                }            } else {                dst_pts = last_dst_pts;            }            av_frame_unref(frame);            continue;        }//省略了AV_FILTER部分的代码            duration = (frame_rate.num &amp;&amp; frame_rate.den ? av_q2d((AVRational){frame_rate.den, frame_rate.num}) : 0);            pts = (frame-&gt;pts == AV_NOPTS_VALUE) ? NAN : frame-&gt;pts * av_q2d(tb);            //将frame入队到pictq中，来让渲染线程读取。            ret = queue_picture(ffp, frame, pts, duration, frame-&gt;pkt_pos, is-&gt;viddec.pkt_serial);            av_frame_unref(frame);        if (ret &lt; 0)            goto the_end;    } the_end:#if CONFIG_AVFILTER    avfilter_graph_free(&amp;graph);#endif    av_log(NULL, AV_LOG_INFO, &quot;convert image convert_frame_count = %d\n&quot;, convert_frame_count);    av_frame_free(&amp;frame);    return 0;}</code></pre><p>简略为：</p><pre><code class="c">static int ffplay_video_thread(void *arg){  for(;;){    ret = get_video_frame(ffp, frame);//解码，并将解码后的帧数据存放在frame中    //将frame入队到pictq中，来让渲染线程读取。    ret = queue_picture(ffp, frame, pts, duration, frame-&gt;pkt_pos, is-&gt;viddec.pkt_serial);  }}</code></pre><p>那么看下解码函数：</p><pre><code class="c">static int get_video_frame(FFPlayer *ffp, AVFrame *frame){    VideoState *is = ffp-&gt;is;    int got_picture;    ffp_video_statistic_l(ffp);    //解码，并将视频帧数据填充到frame中，可能阻塞    if ((got_picture = decoder_decode_frame(ffp, &amp;is-&gt;viddec, frame, NULL)) &lt; 0)        return -1;    if (got_picture) {        double dpts = NAN;        if (frame-&gt;pts != AV_NOPTS_VALUE)            dpts = av_q2d(is-&gt;video_st-&gt;time_base) * frame-&gt;pts;        frame-&gt;sample_aspect_ratio = av_guess_sample_aspect_ratio(is-&gt;ic, is-&gt;video_st, frame);        if (ffp-&gt;framedrop&gt;0 || (ffp-&gt;framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) {            ffp-&gt;stat.decode_frame_count++;            if (frame-&gt;pts != AV_NOPTS_VALUE) {                double diff = dpts - get_master_clock(is);                if (!isnan(diff) &amp;&amp; fabs(diff) &lt; AV_NOSYNC_THRESHOLD &amp;&amp;                    diff - is-&gt;frame_last_filter_delay &lt; 0 &amp;&amp;                    is-&gt;viddec.pkt_serial == is-&gt;vidclk.serial &amp;&amp;                    is-&gt;videoq.nb_packets) {                    is-&gt;frame_drops_early++;                    is-&gt;continuous_frame_drops_early++;                    if (is-&gt;continuous_frame_drops_early &gt; ffp-&gt;framedrop) {                        is-&gt;continuous_frame_drops_early = 0;                    } else {                        ffp-&gt;stat.drop_frame_count++;                        ffp-&gt;stat.drop_frame_rate = (float)(ffp-&gt;stat.drop_frame_count) / (float)(ffp-&gt;stat.decode_frame_count);                        av_frame_unref(frame);                        got_picture = 0;                    }                }            }        }    }    return got_picture;}</code></pre><p>那么这里又是用的和字幕解码、音频解码一样的解码函数：<code>decoder_decode_frame</code>，就不重复提了。</p><pre><code class="c">//将src_frame入队到picq中，让渲染线程渲染。static int queue_picture(FFPlayer *ffp, AVFrame *src_frame, double pts, double duration, int64_t pos, int serial){    VideoState *is = ffp-&gt;is;    Frame *vp;    int video_accurate_seek_fail = 0;    int64_t video_seek_pos = 0;    int64_t now = 0;    int64_t deviation = 0;    int64_t deviation2 = 0;    int64_t deviation3 = 0;    //处理精确seek    if (ffp-&gt;enable_accurate_seek &amp;&amp; is-&gt;video_accurate_seek_req &amp;&amp; !is-&gt;seek_req) {        if (!isnan(pts)) {            video_seek_pos = is-&gt;seek_pos;            is-&gt;accurate_seek_vframe_pts = pts * 1000 * 1000;            deviation = llabs((int64_t)(pts * 1000 * 1000) - is-&gt;seek_pos);            if ((pts * 1000 * 1000 &lt; is-&gt;seek_pos) || deviation &gt; MAX_DEVIATION) {                now = av_gettime_relative() / 1000;                if (is-&gt;drop_vframe_count == 0) {                    SDL_LockMutex(is-&gt;accurate_seek_mutex);                    if (is-&gt;accurate_seek_start_time &lt;= 0 &amp;&amp; (is-&gt;audio_stream &lt; 0 || is-&gt;audio_accurate_seek_req)) {                        is-&gt;accurate_seek_start_time = now;                    }                    SDL_UnlockMutex(is-&gt;accurate_seek_mutex);                    av_log(NULL, AV_LOG_INFO, &quot;video accurate_seek start, is-&gt;seek_pos=%lld, pts=%lf, is-&gt;accurate_seek_time = %lld\n&quot;, is-&gt;seek_pos, pts, is-&gt;accurate_seek_start_time);                }                is-&gt;drop_vframe_count++;                while (is-&gt;audio_accurate_seek_req &amp;&amp; !is-&gt;abort_request) {                    int64_t apts = is-&gt;accurate_seek_aframe_pts ;                    deviation2 = apts - pts * 1000 * 1000;                    deviation3 = apts - is-&gt;seek_pos;                    if (deviation2 &gt; -100 * 1000 &amp;&amp; deviation3 &lt; 0) {                        break;                    } else {                        av_usleep(20 * 1000);                    }                    now = av_gettime_relative() / 1000;                    if ((now - is-&gt;accurate_seek_start_time) &gt; ffp-&gt;accurate_seek_timeout) {                        break;                    }                }                if ((now - is-&gt;accurate_seek_start_time) &lt;= ffp-&gt;accurate_seek_timeout) {                    return 1;  // drop some old frame when do accurate seek                } else {                    av_log(NULL, AV_LOG_WARNING, &quot;video accurate_seek is error, is-&gt;drop_vframe_count=%d, now = %lld, pts = %lf\n&quot;, is-&gt;drop_vframe_count, now, pts);                    video_accurate_seek_fail = 1;  // if KEY_FRAME interval too big, disable accurate seek                }            } else {                av_log(NULL, AV_LOG_INFO, &quot;video accurate_seek is ok, is-&gt;drop_vframe_count =%d, is-&gt;seek_pos=%lld, pts=%lf\n&quot;, is-&gt;drop_vframe_count, is-&gt;seek_pos, pts);                if (video_seek_pos == is-&gt;seek_pos) {                    is-&gt;drop_vframe_count       = 0;                    SDL_LockMutex(is-&gt;accurate_seek_mutex);                    is-&gt;video_accurate_seek_req = 0;                    SDL_CondSignal(is-&gt;audio_accurate_seek_cond);                    if (video_seek_pos == is-&gt;seek_pos &amp;&amp; is-&gt;audio_accurate_seek_req &amp;&amp; !is-&gt;abort_request) {                        SDL_CondWaitTimeout(is-&gt;video_accurate_seek_cond, is-&gt;accurate_seek_mutex, ffp-&gt;accurate_seek_timeout);                    } else {                        ffp_notify_msg2(ffp, FFP_MSG_ACCURATE_SEEK_COMPLETE, (int)(pts * 1000));                    }                    if (video_seek_pos != is-&gt;seek_pos &amp;&amp; !is-&gt;abort_request) {                        is-&gt;video_accurate_seek_req = 1;                        SDL_UnlockMutex(is-&gt;accurate_seek_mutex);                        return 1;                    }                    SDL_UnlockMutex(is-&gt;accurate_seek_mutex);                }            }        } else {            video_accurate_seek_fail = 1;        }        if (video_accurate_seek_fail) {            is-&gt;drop_vframe_count = 0;            SDL_LockMutex(is-&gt;accurate_seek_mutex);            is-&gt;video_accurate_seek_req = 0;            SDL_CondSignal(is-&gt;audio_accurate_seek_cond);            if (is-&gt;audio_accurate_seek_req &amp;&amp; !is-&gt;abort_request) {                SDL_CondWaitTimeout(is-&gt;video_accurate_seek_cond, is-&gt;accurate_seek_mutex, ffp-&gt;accurate_seek_timeout);            } else {                if (!isnan(pts)) {                    ffp_notify_msg2(ffp, FFP_MSG_ACCURATE_SEEK_COMPLETE, (int)(pts * 1000));                } else {                    ffp_notify_msg2(ffp, FFP_MSG_ACCURATE_SEEK_COMPLETE, 0);                }            }            SDL_UnlockMutex(is-&gt;accurate_seek_mutex);        }        is-&gt;accurate_seek_start_time = 0;        video_accurate_seek_fail = 0;        is-&gt;accurate_seek_vframe_pts = 0;    }#if defined(DEBUG_SYNC)    printf(&quot;frame_type=%c pts=%0.3f\n&quot;,           av_get_picture_type_char(src_frame-&gt;pict_type), pts);#endif    if (!(vp = frame_queue_peek_writable(&amp;is-&gt;pictq)))        return -1;    vp-&gt;sar = src_frame-&gt;sample_aspect_ratio;#ifdef FFP_MERGE    vp-&gt;uploaded = 0;#endif    /* alloc or resize hardware picture buffer */    if (!vp-&gt;bmp || !vp-&gt;allocated ||        vp-&gt;width  != src_frame-&gt;width ||        vp-&gt;height != src_frame-&gt;height ||        vp-&gt;format != src_frame-&gt;format) {        if (vp-&gt;width != src_frame-&gt;width || vp-&gt;height != src_frame-&gt;height)            ffp_notify_msg3(ffp, FFP_MSG_VIDEO_SIZE_CHANGED, src_frame-&gt;width, src_frame-&gt;height);        vp-&gt;allocated = 0;        vp-&gt;width = src_frame-&gt;width;        vp-&gt;height = src_frame-&gt;height;        vp-&gt;format = src_frame-&gt;format;        /* the allocation must be done in the main thread to avoid           locking problems. */        alloc_picture(ffp, src_frame-&gt;format);        if (is-&gt;videoq.abort_request)            return -1;    }    /* if the frame is not skipped, then display it */    if (vp-&gt;bmp) {        /* get a pointer on the bitmap */        SDL_VoutLockYUVOverlay(vp-&gt;bmp);//加锁#ifdef FFP_MERGE#if CONFIG_AVFILTER        // FIXME use direct rendering        av_image_copy(data, linesize, (const uint8_t **)src_frame-&gt;data, src_frame-&gt;linesize,                        src_frame-&gt;format, vp-&gt;width, vp-&gt;height);#else        // sws_getCachedContext(...);#endif#endif        // FIXME: set swscale options        //将src_frame中的帧数据填充到vp-&gt;bmp中，这个vp-&gt;bmp其实指的是bitmap？        if (SDL_VoutFillFrameYUVOverlay(vp-&gt;bmp, src_frame) &lt; 0) {            av_log(NULL, AV_LOG_FATAL, &quot;Cannot initialize the conversion context\n&quot;);            exit(1);        }        /* update the bitmap content */        SDL_VoutUnlockYUVOverlay(vp-&gt;bmp);//解锁        vp-&gt;pts = pts;        vp-&gt;duration = duration;        vp-&gt;pos = pos;        vp-&gt;serial = serial;        vp-&gt;sar = src_frame-&gt;sample_aspect_ratio;        vp-&gt;bmp-&gt;sar_num = vp-&gt;sar.num;        vp-&gt;bmp-&gt;sar_den = vp-&gt;sar.den;#ifdef FFP_MERGE        av_frame_move_ref(vp-&gt;frame, src_frame);#endif        frame_queue_push(&amp;is-&gt;pictq);        if (!is-&gt;viddec.first_frame_decoded) {            ALOGD(&quot;Video: first frame decoded\n&quot;);            ffp_notify_msg1(ffp, FFP_MSG_VIDEO_DECODED_START);            is-&gt;viddec.first_frame_decoded_time = SDL_GetTickHR();            is-&gt;viddec.first_frame_decoded = 1;        }    }    return 0;}</code></pre><p>这里重点看下将frame数据填充到vp-&gt;bmp数据中的这个操作。</p><p>bmp长得非常像bitmap，看来意思是将帧数据填充到图像数据中的意思了。</p><pre><code class="c">int SDL_VoutFillFrameYUVOverlay(SDL_VoutOverlay *overlay, const AVFrame *frame){    if (!overlay || !overlay-&gt;func_fill_frame)        return -1;    return overlay-&gt;func_fill_frame(overlay, frame);}</code></pre><pre><code class="c">static int func_fill_frame(SDL_VoutOverlay *overlay, const AVFrame *frame){    //...    overlay_fill(overlay, opaque-&gt;linked_frame, opaque-&gt;planes);    //...}static void overlay_fill(SDL_VoutOverlay *overlay, AVFrame *frame, int planes){    overlay-&gt;planes = planes;    for (int i = 0; i &lt; AV_NUM_DATA_POINTERS; ++i) {        //数组的复制         overlay-&gt;pixels[i] = frame-&gt;data[i];        overlay-&gt;pitches[i] = frame-&gt;linesize[i];    }}</code></pre><p>那么到这里，应该是将<code>AVFrame</code>中的数据全部复制到这个<code>vp-&gt;bmp</code>中了，而他是：<code>*SDL_VoutOverlay*</code></p><h2 id="5-视频渲染线程"><a href="#5-视频渲染线程" class="headerlink" title="5 视频渲染线程"></a>5 视频渲染线程</h2><pre><code class="c">//创建视频刷新线程is-&gt;video_refresh_tid = SDL_CreateThreadEx(&amp;is-&gt;_video_refresh_tid, video_refresh_thread, ffp, &quot;ff_vout&quot;);</code></pre><p>创建一个线程专门用于渲染视频。在看代码之前，先了解一下视频渲染要做什么：</p><ol><li>从<code>FrameQueue</code>中拿取每一帧解码完的原始图像帧数据。</li><li>将帧数据发送到显示设备，让对应设备将图像数据画出来。</li><li>这是一个循环的过程，解码线程不断解码出图像帧，这边的渲染线程不断地读取图像帧并输送到渲染设备。</li></ol><pre><code class="c">//    ijkmedia/ijkplayer/ff_ffplay.cstatic int video_refresh_thread(void *arg){    FFPlayer *ffp = arg;    VideoState *is = ffp-&gt;is;    double remaining_time = 0.0;      //循环，如果没有中断请求，那么就一直尝试去渲染。    while (!is-&gt;abort_request) {        if (remaining_time &gt; 0.0)            av_usleep((int)(int64_t)(remaining_time * 1000000.0));        remaining_time = REFRESH_RATE;        if (is-&gt;show_mode != SHOW_MODE_NONE &amp;&amp; (!is-&gt;paused || is-&gt;force_refresh))              //刷新视频            video_refresh(ffp, &amp;remaining_time);    }    return 0;}</code></pre><pre><code class="c">//    ijkmedia/ijkplayer/ff_ffplay.c/* called to display each frame */static void video_refresh(FFPlayer *opaque, double *remaining_time){    FFPlayer *ffp = opaque;    VideoState *is = ffp-&gt;is;    double time;    Frame *sp, *sp2;    //处理时钟。    if (!is-&gt;paused &amp;&amp; get_master_sync_type(is) == AV_SYNC_EXTERNAL_CLOCK &amp;&amp; is-&gt;realtime)        check_external_clock_speed(is);    if (!ffp-&gt;display_disable &amp;&amp; is-&gt;show_mode != SHOW_MODE_VIDEO &amp;&amp; is-&gt;audio_st) {        time = av_gettime_relative() / 1000000.0;        if (is-&gt;force_refresh || is-&gt;last_vis_time + ffp-&gt;rdftspeed &lt; time) {            //①            video_display2(ffp);            is-&gt;last_vis_time = time;        }        *remaining_time = FFMIN(*remaining_time, is-&gt;last_vis_time + ffp-&gt;rdftspeed - time);    }    if (is-&gt;video_st) {retry:        if (frame_queue_nb_remaining(&amp;is-&gt;pictq) == 0) {            // nothing to do, no picture to display in the queue        } else {            double last_duration, duration, delay;            Frame *vp, *lastvp;            /* dequeue the picture */            lastvp = frame_queue_peek_last(&amp;is-&gt;pictq);            vp = frame_queue_peek(&amp;is-&gt;pictq);            if (vp-&gt;serial != is-&gt;videoq.serial) {                frame_queue_next(&amp;is-&gt;pictq);                goto retry;            }            if (lastvp-&gt;serial != vp-&gt;serial)                is-&gt;frame_timer = av_gettime_relative() / 1000000.0;            if (is-&gt;paused)                goto display;            /* compute nominal last_duration */            last_duration = vp_duration(is, lastvp, vp);            delay = compute_target_delay(ffp, last_duration, is);            time= av_gettime_relative()/1000000.0;            if (isnan(is-&gt;frame_timer) || time &lt; is-&gt;frame_timer)                is-&gt;frame_timer = time;            if (time &lt; is-&gt;frame_timer + delay) {                *remaining_time = FFMIN(is-&gt;frame_timer + delay - time, *remaining_time);                goto display;            }            is-&gt;frame_timer += delay;            if (delay &gt; 0 &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)                is-&gt;frame_timer = time;            SDL_LockMutex(is-&gt;pictq.mutex);            if (!isnan(vp-&gt;pts))                update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);            SDL_UnlockMutex(is-&gt;pictq.mutex);            if (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; 1) {                Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);                duration = vp_duration(is, vp, nextvp);                if(!is-&gt;step &amp;&amp; (ffp-&gt;framedrop &gt; 0 || (ffp-&gt;framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; time &gt; is-&gt;frame_timer + duration) {                    frame_queue_next(&amp;is-&gt;pictq);                    goto retry;                }            }            if (is-&gt;subtitle_st) {                while (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; 0) {                    sp = frame_queue_peek(&amp;is-&gt;subpq);                    if (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; 1)                        sp2 = frame_queue_peek_next(&amp;is-&gt;subpq);                    else                        sp2 = NULL;                    if (sp-&gt;serial != is-&gt;subtitleq.serial                            || (is-&gt;vidclk.pts &gt; (sp-&gt;pts + ((float) sp-&gt;sub.end_display_time / 1000)))                            || (sp2 &amp;&amp; is-&gt;vidclk.pts &gt; (sp2-&gt;pts + ((float) sp2-&gt;sub.start_display_time / 1000))))                    {                        if (sp-&gt;uploaded) {                            ffp_notify_msg4(ffp, FFP_MSG_TIMED_TEXT, 0, 0, &quot;&quot;, 1);                        }                        frame_queue_next(&amp;is-&gt;subpq);                    } else {                        break;                    }                }            }            frame_queue_next(&amp;is-&gt;pictq);            is-&gt;force_refresh = 1;            SDL_LockMutex(ffp-&gt;is-&gt;play_mutex);            if (is-&gt;step) {                is-&gt;step = 0;                if (!is-&gt;paused)                    stream_update_pause_l(ffp);            }            SDL_UnlockMutex(ffp-&gt;is-&gt;play_mutex);        }display:        /* display picture */        if (!ffp-&gt;display_disable &amp;&amp; is-&gt;force_refresh &amp;&amp; is-&gt;show_mode == SHOW_MODE_VIDEO &amp;&amp; is-&gt;pictq.rindex_shown)            //①            video_display2(ffp);    }    is-&gt;force_refresh = 0;    if (ffp-&gt;show_status) {        static int64_t last_time;        int64_t cur_time;        int aqsize, vqsize, sqsize __unused;        double av_diff;        cur_time = av_gettime_relative();        if (!last_time || (cur_time - last_time) &gt;= 30000) {            aqsize = 0;            vqsize = 0;            sqsize = 0;            if (is-&gt;audio_st)                aqsize = is-&gt;audioq.size;            if (is-&gt;video_st)                vqsize = is-&gt;videoq.size;#ifdef FFP_MERGE            if (is-&gt;subtitle_st)                sqsize = is-&gt;subtitleq.size;#else            sqsize = 0;#endif            av_diff = 0;            if (is-&gt;audio_st &amp;&amp; is-&gt;video_st)                av_diff = get_clock(&amp;is-&gt;audclk) - get_clock(&amp;is-&gt;vidclk);            else if (is-&gt;video_st)                av_diff = get_master_clock(is) - get_clock(&amp;is-&gt;vidclk);            else if (is-&gt;audio_st)                av_diff = get_master_clock(is) - get_clock(&amp;is-&gt;audclk);            av_log(NULL, AV_LOG_INFO,                   &quot;%7.2f %s:%7.3f fd=%4d aq=%5dKB vq=%5dKB sq=%5dB f=%&quot;PRId64&quot;/%&quot;PRId64&quot;   \r&quot;,                   get_master_clock(is),                   (is-&gt;audio_st &amp;&amp; is-&gt;video_st) ? &quot;A-V&quot; : (is-&gt;video_st ? &quot;M-V&quot; : (is-&gt;audio_st ? &quot;M-A&quot; : &quot;   &quot;)),                   av_diff,                   is-&gt;frame_drops_early + is-&gt;frame_drops_late,                   aqsize / 1024,                   vqsize / 1024,                   sqsize,                   is-&gt;video_st ? is-&gt;viddec.avctx-&gt;pts_correction_num_faulty_dts : 0,                   is-&gt;video_st ? is-&gt;viddec.avctx-&gt;pts_correction_num_faulty_pts : 0);            fflush(stdout);            last_time = cur_time;        }    }}</code></pre><p>一长串代码，貌似有一些根据时钟来同步音视频的代码？暂时不做分析，这里面要跳转到方法（用①做了标记，有两处）：</p><pre><code class="c">//①video_display2(ffp);</code></pre><pre><code class="c">/* display the current picture, if any */static void video_display2(FFPlayer *ffp){    VideoState *is = ffp-&gt;is;    if (is-&gt;video_st)        video_image_display2(ffp);}</code></pre><pre><code class="c">static void video_image_display2(FFPlayer *ffp){    VideoState *is = ffp-&gt;is;    Frame *vp;    Frame *sp = NULL;    //is-&gt;pictq就是picture queue的意思。读取队列中最后一帧。    vp = frame_queue_peek_last(&amp;is-&gt;pictq);    //如果帧中的SDL_VoutOverlay数据不为null，那么就开始渲染    if (vp-&gt;bmp) {        //如果字幕流不为空，去渲染字幕        if (is-&gt;subtitle_st) {            if (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; 0) {                sp = frame_queue_peek(&amp;is-&gt;subpq);                if (vp-&gt;pts &gt;= sp-&gt;pts + ((float) sp-&gt;sub.start_display_time / 1000)) {                    if (!sp-&gt;uploaded) {                        if (sp-&gt;sub.num_rects &gt; 0) {                            char buffered_text[4096];                            if (sp-&gt;sub.rects[0]-&gt;text) {                                strncpy(buffered_text, sp-&gt;sub.rects[0]-&gt;text, 4096);                            }                            else if (sp-&gt;sub.rects[0]-&gt;ass) {                                parse_ass_subtitle(sp-&gt;sub.rects[0]-&gt;ass, buffered_text);                            }                            ffp_notify_msg4(ffp, FFP_MSG_TIMED_TEXT, 0, 0, buffered_text, sizeof(buffered_text));                        }                        sp-&gt;uploaded = 1;                    }                }            }        }        if (ffp-&gt;render_wait_start &amp;&amp; !ffp-&gt;start_on_prepared &amp;&amp; is-&gt;pause_req) {            if (!ffp-&gt;first_video_frame_rendered) {                ffp-&gt;first_video_frame_rendered = 1;                ffp_notify_msg1(ffp, FFP_MSG_VIDEO_RENDERING_START);            }            while (is-&gt;pause_req &amp;&amp; !is-&gt;abort_request) {                SDL_Delay(20);            }        }        //显示YUV数据。        SDL_VoutDisplayYUVOverlay(ffp-&gt;vout, vp-&gt;bmp);        ffp-&gt;stat.vfps = SDL_SpeedSamplerAdd(&amp;ffp-&gt;vfps_sampler, FFP_SHOW_VFPS_FFPLAY, &quot;vfps[ffplay]&quot;);        if (!ffp-&gt;first_video_frame_rendered) {            ffp-&gt;first_video_frame_rendered = 1;            ffp_notify_msg1(ffp, FFP_MSG_VIDEO_RENDERING_START);        }        if (is-&gt;latest_video_seek_load_serial == vp-&gt;serial) {            int latest_video_seek_load_serial = __atomic_exchange_n(&amp;(is-&gt;latest_video_seek_load_serial), -1, memory_order_seq_cst);            if (latest_video_seek_load_serial == vp-&gt;serial) {                ffp-&gt;stat.latest_seek_load_duration = (av_gettime() - is-&gt;latest_seek_load_start_at) / 1000;                if (ffp-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {                    ffp_notify_msg2(ffp, FFP_MSG_VIDEO_SEEK_RENDERING_START, 1);                } else {                    ffp_notify_msg2(ffp, FFP_MSG_VIDEO_SEEK_RENDERING_START, 0);                }            }        }    }}</code></pre><p>首先看到取视频帧的这一段代码：</p><pre><code class="c">Frame *vp;Frame *sp = NULL;//is-&gt;pictq就是picture queue的意思。读取队列中最后一帧。vp = frame_queue_peek_last(&amp;is-&gt;pictq);</code></pre><p>在这里，<code>Frame</code>就是每一帧解码后的图像数据，是直接拿去显示的。而<code>is-&gt;pictq</code>就是<code>VideoState</code>里面的解码后的图像队列<code>FrameQueue</code>。</p><p>看一下<code>Frame</code>和<code>FrameQueue</code></p><pre><code class="c">typedef struct Frame {    AVFrame *frame;//ffmpeg定义的数据结构，里面存着buffer，存着真实的yuv图像数据    AVSubtitle sub;//字幕数据    int serial;    double pts;           /* presentation timestamp for the frame */    double duration;      /* estimated duration of the frame */    int64_t pos;          /* byte position of the frame in the input file */#ifdef FFP_MERGE    SDL_Texture *bmp;#else    SDL_VoutOverlay *bmp;//vout设备#endif    int allocated;    int width;    int height;    int format;    AVRational sar;    int uploaded;} Frame;typedef struct FrameQueue {    Frame queue[FRAME_QUEUE_SIZE];//数组    int rindex;//read index。下一个读取的下标    int windex;//write index。下一个写入的下标    int size;    int max_size;    int keep_last;    int rindex_shown;    SDL_mutex *mutex;    SDL_cond *cond;    PacketQueue *pktq;//引用的未解码的包队列} FrameQueue;</code></pre><p>然后是看到渲染的这一句：</p><pre><code class="c">//显示YUV数据。这个vp是Frame，而这个bmp是bitmap的意思SDL_VoutDisplayYUVOverlay(ffp-&gt;vout, vp-&gt;bmp);</code></pre><p>这里的意思是将vp-&gt;bmp中的数据输送到ffp-&gt;vout中。<br>ffp);<br>            is-&gt;last_vis_time = time;<br>        }<br>        <em>remaining_time = FFMIN(</em>remaining_time, is-&gt;last_vis_time + ffp-&gt;rdftspeed - time);<br>    }</p><pre><code>if (is-&gt;video_st) {</code></pre><p>retry:<br>        if (frame_queue_nb_remaining(&amp;is-&gt;pictq) == 0) {<br>            // nothing to do, no picture to display in the queue<br>        } else {<br>            double last_duration, duration, delay;<br>            Frame *vp, *lastvp;</p><pre><code>        /* dequeue the picture */        lastvp = frame_queue_peek_last(&amp;is-&gt;pictq);        vp = frame_queue_peek(&amp;is-&gt;pictq);        if (vp-&gt;serial != is-&gt;videoq.serial) {            frame_queue_next(&amp;is-&gt;pictq);            goto retry;        }        if (lastvp-&gt;serial != vp-&gt;serial)            is-&gt;frame_timer = av_gettime_relative() / 1000000.0;        if (is-&gt;paused)            goto display;        /* compute nominal last_duration */        last_duration = vp_duration(is, lastvp, vp);        delay = compute_target_delay(ffp, last_duration, is);        time= av_gettime_relative()/1000000.0;        if (isnan(is-&gt;frame_timer) || time &lt; is-&gt;frame_timer)            is-&gt;frame_timer = time;        if (time &lt; is-&gt;frame_timer + delay) {            *remaining_time = FFMIN(is-&gt;frame_timer + delay - time, *remaining_time);            goto display;        }        is-&gt;frame_timer += delay;        if (delay &gt; 0 &amp;&amp; time - is-&gt;frame_timer &gt; AV_SYNC_THRESHOLD_MAX)            is-&gt;frame_timer = time;        SDL_LockMutex(is-&gt;pictq.mutex);        if (!isnan(vp-&gt;pts))            update_video_pts(is, vp-&gt;pts, vp-&gt;pos, vp-&gt;serial);        SDL_UnlockMutex(is-&gt;pictq.mutex);        if (frame_queue_nb_remaining(&amp;is-&gt;pictq) &gt; 1) {            Frame *nextvp = frame_queue_peek_next(&amp;is-&gt;pictq);            duration = vp_duration(is, vp, nextvp);            if(!is-&gt;step &amp;&amp; (ffp-&gt;framedrop &gt; 0 || (ffp-&gt;framedrop &amp;&amp; get_master_sync_type(is) != AV_SYNC_VIDEO_MASTER)) &amp;&amp; time &gt; is-&gt;frame_timer + duration) {                frame_queue_next(&amp;is-&gt;pictq);                goto retry;            }        }        if (is-&gt;subtitle_st) {            while (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; 0) {                sp = frame_queue_peek(&amp;is-&gt;subpq);                if (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; 1)                    sp2 = frame_queue_peek_next(&amp;is-&gt;subpq);                else                    sp2 = NULL;                if (sp-&gt;serial != is-&gt;subtitleq.serial                        || (is-&gt;vidclk.pts &gt; (sp-&gt;pts + ((float) sp-&gt;sub.end_display_time / 1000)))                        || (sp2 &amp;&amp; is-&gt;vidclk.pts &gt; (sp2-&gt;pts + ((float) sp2-&gt;sub.start_display_time / 1000))))                {                    if (sp-&gt;uploaded) {                        ffp_notify_msg4(ffp, FFP_MSG_TIMED_TEXT, 0, 0, &quot;&quot;, 1);                    }                    frame_queue_next(&amp;is-&gt;subpq);                } else {                    break;                }            }        }        frame_queue_next(&amp;is-&gt;pictq);        is-&gt;force_refresh = 1;        SDL_LockMutex(ffp-&gt;is-&gt;play_mutex);        if (is-&gt;step) {            is-&gt;step = 0;            if (!is-&gt;paused)                stream_update_pause_l(ffp);        }        SDL_UnlockMutex(ffp-&gt;is-&gt;play_mutex);    }</code></pre><p>display:<br>        /* display picture */<br>        if (!ffp-&gt;display_disable &amp;&amp; is-&gt;force_refresh &amp;&amp; is-&gt;show_mode == SHOW_MODE_VIDEO &amp;&amp; is-&gt;pictq.rindex_shown)<br>            //①<br>            video_display2(ffp);<br>    }<br>    is-&gt;force_refresh = 0;<br>    if (ffp-&gt;show_status) {<br>        static int64_t last_time;<br>        int64_t cur_time;<br>        int aqsize, vqsize, sqsize __unused;<br>        double av_diff;</p><pre><code>    cur_time = av_gettime_relative();    if (!last_time || (cur_time - last_time) &gt;= 30000) {        aqsize = 0;        vqsize = 0;        sqsize = 0;        if (is-&gt;audio_st)            aqsize = is-&gt;audioq.size;        if (is-&gt;video_st)            vqsize = is-&gt;videoq.size;</code></pre><p>#ifdef FFP_MERGE<br>            if (is-&gt;subtitle_st)<br>                sqsize = is-&gt;subtitleq.size;<br>#else<br>            sqsize = 0;<br>#endif<br>            av_diff = 0;<br>            if (is-&gt;audio_st &amp;&amp; is-&gt;video_st)<br>                av_diff = get_clock(&amp;is-&gt;audclk) - get_clock(&amp;is-&gt;vidclk);<br>            else if (is-&gt;video_st)<br>                av_diff = get_master_clock(is) - get_clock(&amp;is-&gt;vidclk);<br>            else if (is-&gt;audio_st)<br>                av_diff = get_master_clock(is) - get_clock(&amp;is-&gt;audclk);<br>            av_log(NULL, AV_LOG_INFO,<br>                   “%7.2f %s:%7.3f fd=%4d aq=%5dKB vq=%5dKB sq=%5dB f=%”PRId64”/%”PRId64”   \r”,<br>                   get_master_clock(is),<br>                   (is-&gt;audio_st &amp;&amp; is-&gt;video_st) ? “A-V” : (is-&gt;video_st ? “M-V” : (is-&gt;audio_st ? “M-A” : “   “)),<br>                   av_diff,<br>                   is-&gt;frame_drops_early + is-&gt;frame_drops_late,<br>                   aqsize / 1024,<br>                   vqsize / 1024,<br>                   sqsize,<br>                   is-&gt;video_st ? is-&gt;viddec.avctx-&gt;pts_correction_num_faulty_dts : 0,<br>                   is-&gt;video_st ? is-&gt;viddec.avctx-&gt;pts_correction_num_faulty_pts : 0);<br>            fflush(stdout);<br>            last_time = cur_time;<br>        }<br>    }<br>}</p><pre><code>一长串代码，貌似有一些根据时钟来同步音视频的代码？暂时不做分析，这里面要跳转到方法（用①做了标记，有两处）：``` c//①video_display2(ffp);</code></pre><pre><code class="c">/* display the current picture, if any */static void video_display2(FFPlayer *ffp){    VideoState *is = ffp-&gt;is;    if (is-&gt;video_st)        video_image_display2(ffp);}</code></pre><p>``` c<br>static void video_image_display2(FFPlayer *ffp)<br>{<br>    VideoState *is = ffp-&gt;is;<br>    Frame *vp;<br>    Frame *sp = NULL;<br>    //is-&gt;pictq就是picture queue的意思。读取队列中最后一帧。<br>    vp = frame_queue_peek_last(&amp;is-&gt;pictq);<br>    //如果帧中的SDL_VoutOverlay数据不为null，那么就开始渲染<br>    if (vp-&gt;bmp) {<br>        //如果字幕流不为空，去渲染字幕<br>        if (is-&gt;subtitle_st) {<br>            if (frame_queue_nb_remaining(&amp;is-&gt;subpq) &gt; 0) {<br>                sp = frame_queue_peek(&amp;is-&gt;subpq);</p><pre><code>            if (vp-&gt;pts &gt;= sp-&gt;pts + ((float) sp-&gt;sub.start_display_time / 1000)) {                if (!sp-&gt;uploaded) {                    if (sp-&gt;sub.num_rects &gt; 0) {                        char buffered_text[4096];                        if (sp-&gt;sub.rects[0]-&gt;text) {                            strncpy(buffered_text, sp-&gt;sub.rects[0]-&gt;text, 4096);                        }                        else if (sp-&gt;sub.rects[0]-&gt;ass) {                            parse_ass_subtitle(sp-&gt;sub.rects[0]-&gt;ass, buffered_text);                        }                        ffp_notify_msg4(ffp, FFP_MSG_TIMED_TEXT, 0, 0, buffered_text, sizeof(buffered_text));                    }                    sp-&gt;uploaded = 1;                }            }        }    }    if (ffp-&gt;render_wait_start &amp;&amp; !ffp-&gt;start_on_prepared &amp;&amp; is-&gt;pause_req) {        if (!ffp-&gt;first_video_frame_rendered) {            ffp-&gt;first_video_frame_rendered = 1;            ffp_notify_msg1(ffp, FFP_MSG_VIDEO_RENDERING_START);        }        while (is-&gt;pause_req &amp;&amp; !is-&gt;abort_request) {            SDL_Delay(20);        }    }    //显示YUV数据。    SDL_VoutDisplayYUVOverlay(ffp-&gt;vout, vp-&gt;bmp);    ffp-&gt;stat.vfps = SDL_SpeedSamplerAdd(&amp;ffp-&gt;vfps_sampler, FFP_SHOW_VFPS_FFPLAY, &quot;vfps[ffplay]&quot;);    if (!ffp-&gt;first_video_frame_rendered) {        ffp-&gt;first_video_frame_rendered = 1;        ffp_notify_msg1(ffp, FFP_MSG_VIDEO_RENDERING_START);    }    if (is-&gt;latest_video_seek_load_serial == vp-&gt;serial) {        int latest_video_seek_load_serial = __atomic_exchange_n(&amp;(is-&gt;latest_video_seek_load_serial), -1, memory_order_seq_cst);        if (latest_video_seek_load_serial == vp-&gt;serial) {            ffp-&gt;stat.latest_seek_load_duration = (av_gettime() - is-&gt;latest_seek_load_start_at) / 1000;            if (ffp-&gt;av_sync_type == AV_SYNC_VIDEO_MASTER) {                ffp_notify_msg2(ffp, FFP_MSG_VIDEO_SEEK_RENDERING</code></pre>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>理解ijkplayer（四）拉流</title>
    <link href="/2019/12/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8B%89%E6%B5%81/"/>
    <url>/2019/12/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E5%9B%9B%EF%BC%89%E6%8B%89%E6%B5%81/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p><p>我是一名打算走音视频路线的android开发者。以此系列文章开始，记录我的音视频开发学习之路</p><p>ijkplayer系列文章目录：<br><a href="https://www.jianshu.com/writer#/notebooks/40971763/notes/56760993/preview" target="_blank" rel="noopener">理解ijkplayer（一）：开始</a></p><p><a href="https://www.jianshu.com/p/b5a2584e03f1" target="_blank" rel="noopener">理解ijkplayer（二）项目结构分析</a></p><p><a href="https://www.jianshu.com/p/0501be9cf4bf" target="_blank" rel="noopener">理解ijkplayer（三）从Java层开始初始化</a></p><p><a href="https://www.jianshu.com/p/f633da0db4dd" target="_blank" rel="noopener">理解ijkplayer（四）拉流</a></p><p><a href="https://www.jianshu.com/p/1e10507f18b6" target="_blank" rel="noopener">理解ijkplayer（五）解码、播放</a></p></blockquote><hr><p>由于篇幅的原因，因此这一篇文章是接着上一篇继续写的。</p><p>上一篇文章分析完了：</p><ol><li>JNI_Onload()</li><li>native_init()</li><li>native_setup()</li><li>_setDataSource()</li><li>_setVideoSurface</li></ol><h3 id="1-prepareAsync"><a href="#1-prepareAsync" class="headerlink" title="1  _prepareAsync()"></a>1  _prepareAsync()</h3><p>播放器的异步准备。这是初始化阶段中最复杂，最重要的函数。</p><pre><code class="c">//    ijkmedia/ijkplayer/android/ijkplayer_jni.cstatic voidIjkMediaPlayer_prepareAsync(JNIEnv *env, jobject thiz){    MPTRACE(&quot;%s\n&quot;, __func__);    int retval = 0;    IjkMediaPlayer *mp = jni_get_media_player(env, thiz);    JNI_CHECK_GOTO(mp, env, &quot;java/lang/IllegalStateException&quot;, &quot;mpjni: prepareAsync: null mp&quot;, LABEL_RETURN);    retval = ijkmp_prepare_async(mp);    IJK_CHECK_MPRET_GOTO(retval, env, LABEL_RETURN);LABEL_RETURN:    ijkmp_dec_ref_p(&amp;mp);}</code></pre><pre><code class="c">//    ijkmedia/ijkplayer/ijkplayer.cint ijkmp_prepare_async(IjkMediaPlayer *mp){    assert(mp);    MPTRACE(&quot;ijkmp_prepare_async()\n&quot;);    pthread_mutex_lock(&amp;mp-&gt;mutex);    int retval = ijkmp_prepare_async_l(mp);    pthread_mutex_unlock(&amp;mp-&gt;mutex);    MPTRACE(&quot;ijkmp_prepare_async()=%d\n&quot;, retval);    return retval;}</code></pre><pre><code class="c">static int ijkmp_prepare_async_l(IjkMediaPlayer *mp){    assert(mp);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_IDLE);    // MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_INITIALIZED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_ASYNC_PREPARING);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_PREPARED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_STARTED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_PAUSED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_COMPLETED);    // MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_STOPPED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_ERROR);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_END);    //声明url不为空    assert(mp-&gt;data_source);    //改变播放器状态到MP_STATE_ASYNC_PREPARING    ijkmp_change_state_l(mp, MP_STATE_ASYNC_PREPARING);    //消息队列开始    msg_queue_start(&amp;mp-&gt;ffplayer-&gt;msg_queue);    // released in msg_loop    ijkmp_inc_ref(mp);    //创建并启动消息线程，开启循环来读取消息队列的消息。    mp-&gt;msg_thread = SDL_CreateThreadEx(&amp;mp-&gt;_msg_thread, ijkmp_msg_loop, mp, &quot;ff_msg_loop&quot;);    // msg_thread is detached inside msg_loop    // TODO: 9 release weak_thiz if pthread_create() failed;    //逻辑跳转到ff_ffplay.c    int retval = ffp_prepare_async_l(mp-&gt;ffplayer, mp-&gt;data_source);    if (retval &lt; 0) {        //出错，则抛出MP_STATE_ERROR        ijkmp_change_state_l(mp, MP_STATE_ERROR);        return retval;    }    return 0;}</code></pre><p>看到创建消息线程的那一句的<code>ijkmp_msg_loop</code>函数</p><pre><code class="c">//这句函数会在线程被启动的时候调用，类似于Thread中的Runnablestatic int ijkmp_msg_loop(void *arg){    IjkMediaPlayer *mp = arg;      //调用mp的msg_loop函数。    int ret = mp-&gt;msg_loop(arg);    return ret;}</code></pre><p><code>mp-&gt;msg_loop</code>这个函数，在前面播放器被创建的时候被赋值，在<code>3.3.2</code>中。</p><p>那么这时开启了消息循环线程，并且prepare的逻辑跳转到了<code>ff_ffplay.c</code>中</p><pre><code class="c">//    ijkmedia/ijkplayer/ff_ffplay.cint ffp_prepare_async_l(FFPlayer *ffp, const char *file_name){    assert(ffp);    assert(!ffp-&gt;is);    assert(file_name);    //针对rtmp和rtsp协议，移除选项”timeout“    if (av_stristart(file_name, &quot;rtmp&quot;, NULL) ||        av_stristart(file_name, &quot;rtsp&quot;, NULL)) {        // There is total different meaning for &#39;timeout&#39; option in rtmp        av_log(ffp, AV_LOG_WARNING, &quot;remove &#39;timeout&#39; option for rtmp.\n&quot;);        av_dict_set(&amp;ffp-&gt;format_opts, &quot;timeout&quot;, NULL, 0);    }    /* there is a length limit in avformat */    if (strlen(file_name) + 1 &gt; 1024) {        av_log(ffp, AV_LOG_ERROR, &quot;%s too long url\n&quot;, __func__);        if (avio_find_protocol_name(&quot;ijklongurl:&quot;)) {            av_dict_set(&amp;ffp-&gt;format_opts, &quot;ijklongurl-url&quot;, file_name, 0);            file_name = &quot;ijklongurl:&quot;;        }    }    //打印版本信息    av_log(NULL, AV_LOG_INFO, &quot;===== versions =====\n&quot;);    ffp_show_version_str(ffp, &quot;ijkplayer&quot;,      ijk_version_info());    ffp_show_version_str(ffp, &quot;FFmpeg&quot;,         av_version_info());    ffp_show_version_int(ffp, &quot;libavutil&quot;,      avutil_version());    ffp_show_version_int(ffp, &quot;libavcodec&quot;,     avcodec_version());    ffp_show_version_int(ffp, &quot;libavformat&quot;,    avformat_version());    ffp_show_version_int(ffp, &quot;libswscale&quot;,     swscale_version());    ffp_show_version_int(ffp, &quot;libswresample&quot;,  swresample_version());    av_log(NULL, AV_LOG_INFO, &quot;===== options =====\n&quot;);    ffp_show_dict(ffp, &quot;player-opts&quot;, ffp-&gt;player_opts);    ffp_show_dict(ffp, &quot;format-opts&quot;, ffp-&gt;format_opts);    ffp_show_dict(ffp, &quot;codec-opts &quot;, ffp-&gt;codec_opts);    ffp_show_dict(ffp, &quot;sws-opts   &quot;, ffp-&gt;sws_dict);    ffp_show_dict(ffp, &quot;swr-opts   &quot;, ffp-&gt;swr_opts);    av_log(NULL, AV_LOG_INFO, &quot;===================\n&quot;);    //设置播放器选项    av_opt_set_dict(ffp, &amp;ffp-&gt;player_opts);    //如果ffplayer-&gt;aout==null，那么久打开音频输出设备。前面的初始化代码是没有为这个赋值过的，所以第一次调用肯定会返回true.    if (!ffp-&gt;aout) {        ffp-&gt;aout = ffpipeline_open_audio_output(ffp-&gt;pipeline, ffp);        if (!ffp-&gt;aout)            return -1;    }#if CONFIG_AVFILTER    if (ffp-&gt;vfilter0) {        GROW_ARRAY(ffp-&gt;vfilters_list, ffp-&gt;nb_vfilters);        ffp-&gt;vfilters_list[ffp-&gt;nb_vfilters - 1] = ffp-&gt;vfilter0;    }#endif        //打开流，并返回一个VideoState的结构体    VideoState *is = stream_open(ffp, file_name, NULL);    if (!is) {        av_log(NULL, AV_LOG_WARNING, &quot;ffp_prepare_async_l: stream_open failed OOM&quot;);        return EIJK_OUT_OF_MEMORY;    }    ffp-&gt;is = is;    ffp-&gt;input_filename = av_strdup(file_name);    return 0;}</code></pre><h3 id="2-打开音频输出设备"><a href="#2-打开音频输出设备" class="headerlink" title="2 打开音频输出设备"></a>2 打开音频输出设备</h3><pre><code class="c">//如果ffplayer-&gt;aout==null，那么久打开音频输出设备。前面的初始化代码是没有为这个赋值过的，所以第一次调用肯定会返回true.    if (!ffp-&gt;aout) {        ffp-&gt;aout = ffpipeline_open_audio_output(ffp-&gt;pipeline, ffp);        if (!ffp-&gt;aout)            return -1;    }</code></pre><pre><code class="c">SDL_Aout *ffpipeline_open_audio_output(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    //借助pipeline的方法    return pipeline-&gt;func_open_audio_output(pipeline, ffp);}</code></pre><p>而<code>ffp-&gt;pipeline</code>是在创建播放器IjkMediaPlayer的时候，在创建完<code>ffplayer</code>，和<code>ffplyaer-&gt;vout</code>一起创建的，在<code>3.3.2</code>有如下的代码：</p><pre><code class="c">//    ijkmedia/ijkplayer/android/ijkplayer_android.cIjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*)){    //创建IjkMediaPlayer    IjkMediaPlayer *mp = ijkmp_create(msg_loop);    if (!mp)        goto fail;    //创建视频输出设备，会根据根据硬解还是软件，硬解用MediaCodec创建，软解用FFmpeg创建    mp-&gt;ffplayer-&gt;vout = SDL_VoutAndroid_CreateForAndroidSurface();    if (!mp-&gt;ffplayer-&gt;vout)        goto fail;    //暂时不太理解这个叫做”管道“的东西是什么    mp-&gt;ffplayer-&gt;pipeline = ffpipeline_create_from_android(mp-&gt;ffplayer);    if (!mp-&gt;ffplayer-&gt;pipeline)        goto fail;    //将创建的视频输出设备vout，赋值到ffplayer-&gt;pipeline中    ffpipeline_set_vout(mp-&gt;ffplayer-&gt;pipeline, mp-&gt;ffplayer-&gt;vout);    return mp;fail:    ijkmp_dec_ref_p(&amp;mp);    return NULL;}</code></pre><p>那么我们看到<code>pipeline-&gt;func_open_audio_output(pipeline, ffp);</code>的这个方法：我一点进去直接跳转到<code>IJKFF_Pipeline</code>的结构体的定义来了。</p><pre><code class="c">struct IJKFF_Pipeline {    SDL_Class             *opaque_class;    IJKFF_Pipeline_Opaque *opaque;    void            (*func_destroy)             (IJKFF_Pipeline *pipeline);    IJKFF_Pipenode *(*func_open_video_decoder)  (IJKFF_Pipeline *pipeline, FFPlayer *ffp);      //我们要看的是这个方法，名叫：打开音频输出设备。    SDL_Aout       *(*func_open_audio_output)   (IJKFF_Pipeline *pipeline, FFPlayer *ffp);    IJKFF_Pipenode *(*func_init_video_decoder)  (IJKFF_Pipeline *pipeline, FFPlayer *ffp);    int           (*func_config_video_decoder)  (IJKFF_Pipeline *pipeline, FFPlayer *ffp);};</code></pre><p>这个函数应该是在某个地方被赋值了，我们得找一下，全局搜索关键字：<code>func_open_audio_output</code></p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-39dc9db5869ee765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>全局搜索中出现了3个对<code>func_open_audio_output</code>赋值的语句，分别出现在</p><ol><li><code>ffpipleline_android.c</code></li><li><code>ffpipeline_ffplay.c</code></li><li><code>ffpipeline_ios.c</code></li></ol><p>其中貌似android和ios平台有各自的赋值规则，然后又一个中立的赋值的地方，我们先看这个平台无关的中立的赋值的地方：</p><pre><code class="c">static SDL_Aout *func_open_audio_output(IJKFF_Pipeline *pipeline, FFPlayer *ffp){          //返回NULL    return NULL;}IJKFF_Pipeline *ffpipeline_create_from_ffplay(FFPlayer *ffp){    IJKFF_Pipeline *pipeline = ffpipeline_alloc(&amp;g_pipeline_class, sizeof(IJKFF_Pipeline_Opaque));    if (!pipeline)        return pipeline;    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    opaque-&gt;ffp                   = ffp;    pipeline-&gt;func_destroy            = func_destroy;    pipeline-&gt;func_open_video_decoder = func_open_video_decoder;      //在这里    pipeline-&gt;func_open_audio_output  = func_open_audio_output;    return pipeline;}</code></pre><p>这个平台无关的函数赋值语句赋值的函数返回了NULL。而我再全局搜索一下这个<code>ffpipeline_create_from_ffplay</code>，发现没有调用这个的地方。那么这个函数应该只是一个示范函数，让Android和ios平台去各自实现。</p><p>那么看下android这边的：</p><pre><code class="c">IJKFF_Pipeline *ffpipeline_create_from_android(FFPlayer *ffp){    ALOGD(&quot;ffpipeline_create_from_android()\n&quot;);    IJKFF_Pipeline *pipeline = ffpipeline_alloc(&amp;g_pipeline_class, sizeof(IJKFF_Pipeline_Opaque));    if (!pipeline)        return pipeline;    IJKFF_Pipeline_Opaque *opaque = pipeline-&gt;opaque;    opaque-&gt;ffp                   = ffp;    opaque-&gt;surface_mutex         = SDL_CreateMutex();    opaque-&gt;left_volume           = 1.0f;    opaque-&gt;right_volume          = 1.0f;    if (!opaque-&gt;surface_mutex) {        ALOGE(&quot;ffpipeline-android:create SDL_CreateMutex failed\n&quot;);        goto fail;    }    pipeline-&gt;func_destroy              = func_destroy;    pipeline-&gt;func_open_video_decoder   = func_open_video_decoder;      //打开音频输出设备    pipeline-&gt;func_open_audio_output    = func_open_audio_output;    pipeline-&gt;func_init_video_decoder   = func_init_video_decoder;    pipeline-&gt;func_config_video_decoder = func_config_video_decoder;    return pipeline;fail:    ffpipeline_free_p(&amp;pipeline);    return NULL;}</code></pre><p>注意，这个<code>ffpipeline_create_from_android</code>方法被调用的地方，是在创建完<code>ffplayer</code>播放器后，和<code>ffplayer-&gt;vout</code>一起创建的，在<code>3.3.2</code>中有示例代码。</p><p>继续看<code>func_open_audio_output</code>函数：</p><pre><code class="c">static SDL_Aout *func_open_audio_output(IJKFF_Pipeline *pipeline, FFPlayer *ffp){    SDL_Aout *aout = NULL;    if (ffp-&gt;opensles) {          //如果打开了opensles，则用OpenSLES来创建音频输出设备        aout = SDL_AoutAndroid_CreateForOpenSLES();    } else {          //否则，使用Android平台的AudioTrack来创建音频输出设备        aout = SDL_AoutAndroid_CreateForAudioTrack();    }    if (aout)        SDL_AoutSetStereoVolume(aout, pipeline-&gt;opaque-&gt;left_volume, pipeline-&gt;opaque-&gt;right_volume);    return aout;}</code></pre><p>那么这个<code>ffp-&gt;opensles</code>的返回值就很关键了，通过全局搜索，我看到在</p><p><code>inline static void ffp_reset_internal(*FFPlayer* **ffp*)</code>函数中有：</p><pre><code class="c">    ffp-&gt;opensles                       = 0; // option</code></pre><p>即opensles是默认关闭的，除非用了option去打开它。</p><p>而option的定义位于：<code>ijkmedia/ijkplayer/ff_ffplay_options.h</code>。option是如何发挥作用的，后面再分析。</p><p>对于ijkplayer是如何利用AudioTrack来播放解码后的pcm音频数据的，这里也暂不分析。</p><h3 id="3-打开流"><a href="#3-打开流" class="headerlink" title="3 打开流"></a>3 打开流</h3><pre><code class="c">    VideoState *is = stream_open(ffp, file_name, NULL);</code></pre><p>单看这一句，感觉是：根据file_name(url)打开对应的视频流，并返回一个<code>VideoState</code>(视频状态)</p><p>而这个<code>VideoState</code>是保存在<code>FFPlayer</code>里面的</p><pre><code class="c">typedef struct FFPlayer {    const AVClass *av_class;    /* ffplay context */    VideoState *is;      //...}</code></pre><p>而这个<code>FFPlayer</code>则是<code>IikMediaPlayer</code>中真正的播放器对象。</p><p>即一个播放器对应一个<code>VideoState</code>对象。</p><p>那么先看一下<code>VideoState</code>的结构体：</p><pre><code class="c">typedef struct VideoState {    SDL_Thread *read_tid;//读线程    SDL_Thread _read_tid;    AVInputFormat *iformat;//输入格式    int abort_request;//停止请求    int force_refresh;//强制刷新    int paused;//暂停    int last_paused;    int queue_attachments_req;    int seek_req;    int seek_flags;    int64_t seek_pos;    int64_t seek_rel;#ifdef FFP_MERGE    int read_pause_return;#endif    AVFormatContext *ic;    int realtime;    Clock audclk;//音频时钟    Clock vidclk;//视频时钟    Clock extclk;//外部时钟    FrameQueue pictq;//图片帧队列：解码后的视频数据    FrameQueue subpq;//字幕帧队列：解码后的字幕数据    FrameQueue sampq;//音频帧队列：解码后的音频数据    Decoder auddec;//音频解码器    Decoder viddec;//视频解码器    Decoder subdec;//字幕解码器    int audio_stream;//音频流    int av_sync_type;    void *handle;    double audio_clock;    int audio_clock_serial;    double audio_diff_cum; /* used for AV difference average computation */    double audio_diff_avg_coef;    double audio_diff_threshold;    int audio_diff_avg_count;    AVStream *audio_st;    PacketQueue audioq;//音频包数据：未解码的音频数据，从demuxers输出    int audio_hw_buf_size;    uint8_t *audio_buf;    uint8_t *audio_buf1;    short *audio_new_buf;  /* for soundtouch buf */    unsigned int audio_buf_size; /* in bytes */    unsigned int audio_buf1_size;    unsigned int audio_new_buf_size;    int audio_buf_index; /* in bytes */    int audio_write_buf_size;    int audio_volume;    int muted;    struct AudioParams audio_src;#if CONFIG_AVFILTER    struct AudioParams audio_filter_src;#endif    struct AudioParams audio_tgt;    struct SwrContext *swr_ctx;    int frame_drops_early;    int frame_drops_late;    int continuous_frame_drops_early;    enum ShowMode {        SHOW_MODE_NONE = -1, SHOW_MODE_VIDEO = 0, SHOW_MODE_WAVES, SHOW_MODE_RDFT, SHOW_MODE_NB    } show_mode;    int16_t sample_array[SAMPLE_ARRAY_SIZE];    int sample_array_index;    int last_i_start;#ifdef FFP_MERGE    RDFTContext *rdft;    int rdft_bits;    FFTSample *rdft_data;    int xpos;#endif    double last_vis_time;#ifdef FFP_MERGE    SDL_Texture *vis_texture;    SDL_Texture *sub_texture;#endif    int subtitle_stream;    AVStream *subtitle_st;    PacketQueue subtitleq;//未解码的字幕数据：从demuxser输出    double frame_timer;    double frame_last_returned_time;    double frame_last_filter_delay;    int video_stream;    AVStream *video_st;    PacketQueue videoq;//未解码的视频数据：从demuxsers输出    double max_frame_duration;      // maximum duration of a frame - above this, we consider the jump a timestamp discontinuity    struct SwsContext *img_convert_ctx;#ifdef FFP_SUB    struct SwsContext *sub_convert_ctx;#endif    int eof;    char *filename;    int width, height, xleft, ytop;//视频的：宽、高、左上角x坐标，左上角y坐标。和ffmpeg里面的是对应的。    int step;#if CONFIG_AVFILTER    int vfilter_idx;    AVFilterContext *in_video_filter;   // the first filter in the video chain    AVFilterContext *out_video_filter;  // the last filter in the video chain    AVFilterContext *in_audio_filter;   // the first filter in the audio chain    AVFilterContext *out_audio_filter;  // the last filter in the audio chain    AVFilterGraph *agraph;              // audio filter graph#endif    int last_video_stream, last_audio_stream, last_subtitle_stream;    SDL_cond *continue_read_thread;    /* extra fields */    SDL_mutex  *play_mutex; // only guard state, do not block any long operation    SDL_Thread *video_refresh_tid;    SDL_Thread _video_refresh_tid;    int buffering_on;    int pause_req;    int dropping_frame;    int is_video_high_fps; // above 30fps    int is_video_high_res; // above 1080p    PacketQueue *buffer_indicator_queue;    volatile int latest_video_seek_load_serial;    volatile int latest_audio_seek_load_serial;    volatile int64_t latest_seek_load_start_at;    int drop_aframe_count;    int drop_vframe_count;    int64_t accurate_seek_start_time;    volatile int64_t accurate_seek_vframe_pts;    volatile int64_t accurate_seek_aframe_pts;    int audio_accurate_seek_req;    int video_accurate_seek_req;    SDL_mutex *accurate_seek_mutex;    SDL_cond  *video_accurate_seek_cond;    SDL_cond  *audio_accurate_seek_cond;    volatile int initialized_decoder;    int seek_buffering;} VideoState;</code></pre><p>我针对我理解了的字段做了一些注释。</p><p>那么现在看到返回<code>VideoState</code>结构体的方法<code>openstream</code></p><pre><code class="c">static VideoState *stream_open(FFPlayer *ffp, const char *filename, AVInputFormat *iformat){    assert(!ffp-&gt;is);    VideoState *is;    //创建VideoState结构体    is = av_mallocz(sizeof(VideoState));    if (!is)        return NULL;    //给VideoState结构体中的属性赋值    is-&gt;filename = av_strdup(filename);    if (!is-&gt;filename)        goto fail;    is-&gt;iformat = iformat;    is-&gt;ytop    = 0;    is-&gt;xleft   = 0;#if defined(__ANDROID__)    //android平台下的soundtouch，不太清楚是做什么的    if (ffp-&gt;soundtouch_enable) {        is-&gt;handle = ijk_soundtouch_create();    }#endif    /* start video display */    //初始化3个帧队列（解码后帧的队列）    if (frame_queue_init(&amp;is-&gt;pictq, &amp;is-&gt;videoq, ffp-&gt;pictq_size, 1) &lt; 0)        goto fail;    if (frame_queue_init(&amp;is-&gt;subpq, &amp;is-&gt;subtitleq, SUBPICTURE_QUEUE_SIZE, 0) &lt; 0)        goto fail;    if (frame_queue_init(&amp;is-&gt;sampq, &amp;is-&gt;audioq, SAMPLE_QUEUE_SIZE, 1) &lt; 0)        goto fail;    //初始化3个包队列（解码前的帧队列,不过是demuxer输出的数据了）    if (packet_queue_init(&amp;is-&gt;videoq) &lt; 0 ||        packet_queue_init(&amp;is-&gt;audioq) &lt; 0 ||        packet_queue_init(&amp;is-&gt;subtitleq) &lt; 0)        goto fail;    //以下3个创建SDL_cond的函数，不太清楚他们的作用是什么，暂不分析    if (!(is-&gt;continue_read_thread = SDL_CreateCond())) {        av_log(NULL, AV_LOG_FATAL, &quot;SDL_CreateCond(): %s\n&quot;, SDL_GetError());        goto fail;    }    if (!(is-&gt;video_accurate_seek_cond = SDL_CreateCond())) {        av_log(NULL, AV_LOG_FATAL, &quot;SDL_CreateCond(): %s\n&quot;, SDL_GetError());        ffp-&gt;enable_accurate_seek = 0;    }    if (!(is-&gt;audio_accurate_seek_cond = SDL_CreateCond())) {        av_log(NULL, AV_LOG_FATAL, &quot;SDL_CreateCond(): %s\n&quot;, SDL_GetError());        ffp-&gt;enable_accurate_seek = 0;    }    //初始化音频时钟，视频时钟，外部时钟    init_clock(&amp;is-&gt;vidclk, &amp;is-&gt;videoq.serial);    init_clock(&amp;is-&gt;audclk, &amp;is-&gt;audioq.serial);    init_clock(&amp;is-&gt;extclk, &amp;is-&gt;extclk.serial);    is-&gt;audio_clock_serial = -1;    //初始化播放器的初始音量    if (ffp-&gt;startup_volume &lt; 0)        av_log(NULL, AV_LOG_WARNING, &quot;-volume=%d &lt; 0, setting to 0\n&quot;, ffp-&gt;startup_volume);    if (ffp-&gt;startup_volume &gt; 100)        av_log(NULL, AV_LOG_WARNING, &quot;-volume=%d &gt; 100, setting to 100\n&quot;, ffp-&gt;startup_volume);    ffp-&gt;startup_volume = av_clip(ffp-&gt;startup_volume, 0, 100);    ffp-&gt;startup_volume = av_clip(SDL_MIX_MAXVOLUME * ffp-&gt;startup_volume / 100, 0, SDL_MIX_MAXVOLUME);    is-&gt;audio_volume = ffp-&gt;startup_volume;    is-&gt;muted = 0;    is-&gt;av_sync_type = ffp-&gt;av_sync_type;    //初始化播放器互斥锁    is-&gt;play_mutex = SDL_CreateMutex();    is-&gt;accurate_seek_mutex = SDL_CreateMutex();    ffp-&gt;is = is;    //如果start_on_prepared=false，那么当prepare完之后要暂停，不能直接播放。    is-&gt;pause_req = !ffp-&gt;start_on_prepared;    //创建视频渲染线程    is-&gt;video_refresh_tid = SDL_CreateThreadEx(&amp;is-&gt;_video_refresh_tid, video_refresh_thread, ffp, &quot;ff_vout&quot;);    if (!is-&gt;video_refresh_tid) {        av_freep(&amp;ffp-&gt;is);        return NULL;    }    //********开始初始化解码器    is-&gt;initialized_decoder = 0;    //创建读取线程    is-&gt;read_tid = SDL_CreateThreadEx(&amp;is-&gt;_read_tid, read_thread, ffp, &quot;ff_read&quot;);    if (!is-&gt;read_tid) {        av_log(NULL, AV_LOG_FATAL, &quot;SDL_CreateThread(): %s\n&quot;, SDL_GetError());        goto fail;    }    if (ffp-&gt;async_init_decoder &amp;&amp; !ffp-&gt;video_disable &amp;&amp; ffp-&gt;video_mime_type &amp;&amp; strlen(ffp-&gt;video_mime_type) &gt; 0                    &amp;&amp; ffp-&gt;mediacodec_default_name &amp;&amp; strlen(ffp-&gt;mediacodec_default_name) &gt; 0) {        if (ffp-&gt;mediacodec_all_videos || ffp-&gt;mediacodec_avc || ffp-&gt;mediacodec_hevc || ffp-&gt;mediacodec_mpeg2) {            decoder_init(&amp;is-&gt;viddec, NULL, &amp;is-&gt;videoq, is-&gt;continue_read_thread);            ffp-&gt;node_vdec = ffpipeline_init_video_decoder(ffp-&gt;pipeline, ffp);        }    }    //********初始化解码器完成    is-&gt;initialized_decoder = 1;    return is;fail:    is-&gt;initialized_decoder = 1;    is-&gt;abort_request = true;    if (is-&gt;video_refresh_tid)        SDL_WaitThread(is-&gt;video_refresh_tid, NULL);    stream_close(ffp);    return NULL;}</code></pre><p>他的逻辑大致为：</p><ol><li>创建<code>VideoState</code>对象，并初始化他的一些默认属性。</li><li>初始化视频、音频、字幕的解码后的帧队列。</li><li>初始化视频、音频、字幕的解码前的包队列。</li><li>初始化播放器音量。</li><li>创建视频渲染线程。</li><li>创建视频数据读取线程（从网络读取或者从文件读取，io操作）。</li><li>初始化解码器。（ffmpeg应该会在内部创建解码线程）。</li></ol><p>因此，在<code>openstream()</code>方法中完成了最主要的3个线程的创建。</p><h3 id="4-视频读取线程"><a href="#4-视频读取线程" class="headerlink" title="4 视频读取线程"></a>4 视频读取线程</h3><p>在<code>stream_open</code>这个打开流的函数中，在开启了视频渲染线程后，接着就开启了视频读取线程。</p><pre><code class="c">static VideoState *stream_open(FFPlayer *ffp, const char *filename, AVInputFormat *iformat){      //...        is-&gt;read_tid = SDL_CreateThreadEx(&amp;is-&gt;_read_tid, read_thread, ffp, &quot;ff_read&quot;);      //...}</code></pre><p>通过创建单独的线程，专门用于读取Packet，在<code>read_thread()</code>函数中。而这个函数非常长，做了很多事情，先放出一个浓缩版的：</p><h4 id="简略版代码："><a href="#简略版代码：" class="headerlink" title="简略版代码："></a>简略版代码：</h4><pre><code class="c">static int read_thread(void *arg){       //Open an input stream and read the header. The codecs are not opened.    //The stream must be closed with avformat_close_input().    //打开输入流，并读取文件头部，解码器还未打开。主要作用是探测流的协议，如http还是rtmp等。    err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;ffp-&gt;format_opts);    // Read packets of a media file to get stream information. This    // is useful for file formats with no headers such as MPEG. This    // function also computes the real framerate in case of MPEG-2 repeat    // frame mode.    // The logical file position is not changed by this function;    // examined packets may buffered for later processing.     //探测文件封装格式，音视频编码参数等信息。    err = avformat_find_stream_info(ic, opts);    // Find the &quot;best&quot; stream in the file.    // The best stream is determined according to various heuristics as the most    // likely to be what the user expects.    // If the decoder parameter is non-NULL, av_find_best_stream will find the    // default decoder for the stream&#39;s codec; streams for which no decoder can    // be found are ignored.    //根据 AVFormatContext，找到最佳的流。    av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,                        st_index[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);      //内部分别开启audio,video,subtitle的解码器的线程，开始各自的解码的工作。在稍后的3.6.5解码线程中分析这里的内容    stream_component_open(ffp, st_index[AVMEDIA_TYPE_AUDIO]);    stream_component_open(ffp, st_index[AVMEDIA_TYPE_VIDEO]);    stream_component_open(ffp, st_index[AVMEDIA_TYPE_SUBTITLE]);      //开始无限循环,调用ffmpeg的av_read_frame()读取AVPacket，并入队。      for (;;) {      //AVPacket pkt;      ret = av_read_frame(ic, pkt);      //把网络读取到并解封装到的pkt包入队列。（稍后在解码线程会拿到这些pkt包去解码。）            //如果是音频流的包      packet_queue_put(&amp;is-&gt;audioq, pkt);      //如果是视频流的包      packet_queue_put(&amp;is-&gt;videoq, pkt);      //如果是字幕流的包      packet_queue_put(&amp;is-&gt;subtitleq, pkt);    }  }</code></pre><h4 id="完整版代码："><a href="#完整版代码：" class="headerlink" title="完整版代码："></a>完整版代码：</h4><p>那么详细的全部的源码（600行）如下，做了部分注释。</p><pre><code class="c">/* this thread gets the stream from the disk or the network */static int read_thread(void *arg){    FFPlayer *ffp = arg;    VideoState *is = ffp-&gt;is;    AVFormatContext *ic = NULL;    int err, i, ret __unused;    int st_index[AVMEDIA_TYPE_NB];    AVPacket pkt1, *pkt = &amp;pkt1;    int64_t stream_start_time;    int completed = 0;    int pkt_in_play_range = 0;    AVDictionaryEntry *t;    SDL_mutex *wait_mutex = SDL_CreateMutex();    int scan_all_pmts_set = 0;    int64_t pkt_ts;    int last_error = 0;    int64_t prev_io_tick_counter = 0;    int64_t io_tick_counter = 0;    int init_ijkmeta = 0;    if (!wait_mutex) {        av_log(NULL, AV_LOG_FATAL, &quot;SDL_CreateMutex(): %s\n&quot;, SDL_GetError());        ret = AVERROR(ENOMEM);        goto fail;    }    memset(st_index, -1, sizeof(st_index));    is-&gt;last_video_stream = is-&gt;video_stream = -1;    is-&gt;last_audio_stream = is-&gt;audio_stream = -1;    is-&gt;last_subtitle_stream = is-&gt;subtitle_stream = -1;    is-&gt;eof = 0;    //初始化AVFormatContext    ic = avformat_alloc_context();    if (!ic) {        av_log(NULL, AV_LOG_FATAL, &quot;Could not allocate context.\n&quot;);        ret = AVERROR(ENOMEM);        goto fail;    }    //为AVFormatContext设置中断回调    ic-&gt;interrupt_callback.callback = decode_interrupt_cb;    ic-&gt;interrupt_callback.opaque = is;    if (!av_dict_get(ffp-&gt;format_opts, &quot;scan_all_pmts&quot;, NULL, AV_DICT_MATCH_CASE)) {        av_dict_set(&amp;ffp-&gt;format_opts, &quot;scan_all_pmts&quot;, &quot;1&quot;, AV_DICT_DONT_OVERWRITE);        scan_all_pmts_set = 1;    }    if (av_stristart(is-&gt;filename, &quot;rtmp&quot;, NULL) ||        av_stristart(is-&gt;filename, &quot;rtsp&quot;, NULL)) {        // There is total different meaning for &#39;timeout&#39; option in rtmp        av_log(ffp, AV_LOG_WARNING, &quot;remove &#39;timeout&#39; option for rtmp.\n&quot;);        av_dict_set(&amp;ffp-&gt;format_opts, &quot;timeout&quot;, NULL, 0);    }    if (ffp-&gt;skip_calc_frame_rate) {        av_dict_set_int(&amp;ic-&gt;metadata, &quot;skip-calc-frame-rate&quot;, ffp-&gt;skip_calc_frame_rate, 0);        av_dict_set_int(&amp;ffp-&gt;format_opts, &quot;skip-calc-frame-rate&quot;, ffp-&gt;skip_calc_frame_rate, 0);    }    if (ffp-&gt;iformat_name)        //找到视频格式:AVInputFormat        is-&gt;iformat = av_find_input_format(ffp-&gt;iformat_name);    //Open an input stream and read the header. The codecs are not opened.    //The stream must be closed with avformat_close_input().    //打开输入流，并读取文件头部，解码器还未打开。主要作用是探测流的协议，如http还是rtmp等。    err = avformat_open_input(&amp;ic, is-&gt;filename, is-&gt;iformat, &amp;ffp-&gt;format_opts);    if (err &lt; 0) {        print_error(is-&gt;filename, err);        ret = -1;        goto fail;    }    ffp_notify_msg1(ffp, FFP_MSG_OPEN_INPUT);    if (scan_all_pmts_set)        av_dict_set(&amp;ffp-&gt;format_opts, &quot;scan_all_pmts&quot;, NULL, AV_DICT_MATCH_CASE);    if ((t = av_dict_get(ffp-&gt;format_opts, &quot;&quot;, NULL, AV_DICT_IGNORE_SUFFIX))) {        av_log(NULL, AV_LOG_ERROR, &quot;Option %s not found.\n&quot;, t-&gt;key);#ifdef FFP_MERGE        ret = AVERROR_OPTION_NOT_FOUND;        goto fail;#endif    }    is-&gt;ic = ic;    if (ffp-&gt;genpts)        ic-&gt;flags |= AVFMT_FLAG_GENPTS;    av_format_inject_global_side_data(ic);    //    //AVDictionary **opts;    //int orig_nb_streams;    //opts = setup_find_stream_info_opts(ic, ffp-&gt;codec_opts);    //orig_nb_streams = ic-&gt;nb_streams;    if (ffp-&gt;find_stream_info) {        AVDictionary **opts = setup_find_stream_info_opts(ic, ffp-&gt;codec_opts);        int orig_nb_streams = ic-&gt;nb_streams;        do {            if (av_stristart(is-&gt;filename, &quot;data:&quot;, NULL) &amp;&amp; orig_nb_streams &gt; 0) {                for (i = 0; i &lt; orig_nb_streams; i++) {                    if (!ic-&gt;streams[i] || !ic-&gt;streams[i]-&gt;codecpar || ic-&gt;streams[i]-&gt;codecpar-&gt;profile == FF_PROFILE_UNKNOWN) {                        break;                    }                }                if (i == orig_nb_streams) {                    break;                }            }            // Read packets of a media file to get stream information. This            // is useful for file formats with no headers such as MPEG. This            // function also computes the real framerate in case of MPEG-2 repeat            // frame mode.            // The logical file position is not changed by this function;            // examined packets may buffered for later processing.             //探测文件封装格式，音视频编码参数等信息。            err = avformat_find_stream_info(ic, opts);        } while(0);        ffp_notify_msg1(ffp, FFP_MSG_FIND_STREAM_INFO);        for (i = 0; i &lt; orig_nb_streams; i++)            av_dict_free(&amp;opts[i]);        av_freep(&amp;opts);        if (err &lt; 0) {            av_log(NULL, AV_LOG_WARNING,                   &quot;%s: could not find codec parameters\n&quot;, is-&gt;filename);            ret = -1;            goto fail;        }    }    if (ic-&gt;pb)        ic-&gt;pb-&gt;eof_reached = 0; // FIXME hack, ffplay maybe should not use avio_feof() to test for the end    if (ffp-&gt;seek_by_bytes &lt; 0)        ffp-&gt;seek_by_bytes = !!(ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) &amp;&amp; strcmp(&quot;ogg&quot;, ic-&gt;iformat-&gt;name);    is-&gt;max_frame_duration = (ic-&gt;iformat-&gt;flags &amp; AVFMT_TS_DISCONT) ? 10.0 : 3600.0;    is-&gt;max_frame_duration = 10.0;    av_log(ffp, AV_LOG_INFO, &quot;max_frame_duration: %.3f\n&quot;, is-&gt;max_frame_duration);#ifdef FFP_MERGE    if (!window_title &amp;&amp; (t = av_dict_get(ic-&gt;metadata, &quot;title&quot;, NULL, 0)))        window_title = av_asprintf(&quot;%s - %s&quot;, t-&gt;value, input_filename);#endif    //处理seek    /* if seeking requested, we execute it */    if (ffp-&gt;start_time != AV_NOPTS_VALUE) {        int64_t timestamp;        timestamp = ffp-&gt;start_time;        /* add the stream start time */        if (ic-&gt;start_time != AV_NOPTS_VALUE)            timestamp += ic-&gt;start_time;        ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0);        if (ret &lt; 0) {            av_log(NULL, AV_LOG_WARNING, &quot;%s: could not seek to position %0.3f\n&quot;,                    is-&gt;filename, (double)timestamp / AV_TIME_BASE);        }    }    is-&gt;realtime = is_realtime(ic);    //打印详细的格式信息    av_dump_format(ic, 0, is-&gt;filename, 0);    int video_stream_count = 0;    int h264_stream_count = 0;    int first_h264_stream = -1;    for (i = 0; i &lt; ic-&gt;nb_streams; i++) {        AVStream *st = ic-&gt;streams[i];        enum AVMediaType type = st-&gt;codecpar-&gt;codec_type;        st-&gt;discard = AVDISCARD_ALL;        if (type &gt;= 0 &amp;&amp; ffp-&gt;wanted_stream_spec[type] &amp;&amp; st_index[type] == -1)            if (avformat_match_stream_specifier(ic, st, ffp-&gt;wanted_stream_spec[type]) &gt; 0)                st_index[type] = i;        // choose first h264        if (type == AVMEDIA_TYPE_VIDEO) {            enum AVCodecID codec_id = st-&gt;codecpar-&gt;codec_id;            video_stream_count++;            if (codec_id == AV_CODEC_ID_H264) {                h264_stream_count++;                if (first_h264_stream &lt; 0)                    first_h264_stream = i;            }        }    }    if (video_stream_count &gt; 1 &amp;&amp; st_index[AVMEDIA_TYPE_VIDEO] &lt; 0) {        st_index[AVMEDIA_TYPE_VIDEO] = first_h264_stream;        av_log(NULL, AV_LOG_WARNING, &quot;multiple video stream found, prefer first h264 stream: %d\n&quot;, first_h264_stream);    }    //*****对视频，音频，和字幕，调用av_find_best_stream，找到对应的stream的下标，并填充在st_index数组中    if (!ffp-&gt;video_disable)        st_index[AVMEDIA_TYPE_VIDEO] =            // Find the &quot;best&quot; stream in the file.            // The best stream is determined according to various heuristics as the most            // likely to be what the user expects.            // If the decoder parameter is non-NULL, av_find_best_stream will find the            // default decoder for the stream&#39;s codec; streams for which no decoder can            // be found are ignored.            //根据AVFormatContext，找到最佳的流。            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,                                st_index[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);    if (!ffp-&gt;audio_disable)        st_index[AVMEDIA_TYPE_AUDIO] =            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,                                st_index[AVMEDIA_TYPE_AUDIO],                                st_index[AVMEDIA_TYPE_VIDEO],                                NULL, 0);    if (!ffp-&gt;video_disable &amp;&amp; !ffp-&gt;subtitle_disable)        st_index[AVMEDIA_TYPE_SUBTITLE] =            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,                                st_index[AVMEDIA_TYPE_SUBTITLE],                                (st_index[AVMEDIA_TYPE_AUDIO] &gt;= 0 ?                                 st_index[AVMEDIA_TYPE_AUDIO] :                                 st_index[AVMEDIA_TYPE_VIDEO]),                                NULL, 0);    is-&gt;show_mode = ffp-&gt;show_mode;#ifdef FFP_MERGE // bbc: dunno if we need this    if (st_index[AVMEDIA_TYPE_VIDEO] &gt;= 0) {        AVStream *st = ic-&gt;streams[st_index[AVMEDIA_TYPE_VIDEO]];        AVCodecParameters *codecpar = st-&gt;codecpar;        AVRational sar = av_guess_sample_aspect_ratio(ic, st, NULL);        if (codecpar-&gt;width)            set_default_window_size(codecpar-&gt;width, codecpar-&gt;height, sar);    }#endif    //******打开3个流 start    /* open the streams */    if (st_index[AVMEDIA_TYPE_AUDIO] &gt;= 0) {        stream_component_open(ffp, st_index[AVMEDIA_TYPE_AUDIO]);    } else {        ffp-&gt;av_sync_type = AV_SYNC_VIDEO_MASTER;        is-&gt;av_sync_type  = ffp-&gt;av_sync_type;    }    ret = -1;    if (st_index[AVMEDIA_TYPE_VIDEO] &gt;= 0) {        ret = stream_component_open(ffp, st_index[AVMEDIA_TYPE_VIDEO]);    }    if (is-&gt;show_mode == SHOW_MODE_NONE)        is-&gt;show_mode = ret &gt;= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;    if (st_index[AVMEDIA_TYPE_SUBTITLE] &gt;= 0) {        stream_component_open(ffp, st_index[AVMEDIA_TYPE_SUBTITLE]);    }    //******打开3个流 end    ffp_notify_msg1(ffp, FFP_MSG_COMPONENT_OPEN);    if (!ffp-&gt;ijkmeta_delay_init) {        ijkmeta_set_avformat_context_l(ffp-&gt;meta, ic);    }    ffp-&gt;stat.bit_rate = ic-&gt;bit_rate;    if (st_index[AVMEDIA_TYPE_VIDEO] &gt;= 0)        ijkmeta_set_int64_l(ffp-&gt;meta, IJKM_KEY_VIDEO_STREAM, st_index[AVMEDIA_TYPE_VIDEO]);    if (st_index[AVMEDIA_TYPE_AUDIO] &gt;= 0)        ijkmeta_set_int64_l(ffp-&gt;meta, IJKM_KEY_AUDIO_STREAM, st_index[AVMEDIA_TYPE_AUDIO]);    if (st_index[AVMEDIA_TYPE_SUBTITLE] &gt;= 0)        ijkmeta_set_int64_l(ffp-&gt;meta, IJKM_KEY_TIMEDTEXT_STREAM, st_index[AVMEDIA_TYPE_SUBTITLE]);    if (is-&gt;video_stream &lt; 0 &amp;&amp; is-&gt;audio_stream &lt; 0) {        av_log(NULL, AV_LOG_FATAL, &quot;Failed to open file &#39;%s&#39; or configure filtergraph\n&quot;,               is-&gt;filename);        ret = -1;        goto fail;    }    //初始化缓冲指示器队列，优先使用音频packetQueue，找不到就使用视频packetQueue。    if (is-&gt;audio_stream &gt;= 0) {        is-&gt;audioq.is_buffer_indicator = 1;        is-&gt;buffer_indicator_queue = &amp;is-&gt;audioq;    } else if (is-&gt;video_stream &gt;= 0) {        is-&gt;videoq.is_buffer_indicator = 1;        is-&gt;buffer_indicator_queue = &amp;is-&gt;videoq;    } else {        assert(&quot;invalid streams&quot;);    }    //如果是直播流，则播放器使用无限缓存    if (ffp-&gt;infinite_buffer &lt; 0 &amp;&amp; is-&gt;realtime)        ffp-&gt;infinite_buffer = 1;    if (!ffp-&gt;render_wait_start &amp;&amp; !ffp-&gt;start_on_prepared)        toggle_pause(ffp, 1);    if (is-&gt;video_st &amp;&amp; is-&gt;video_st-&gt;codecpar) {        AVCodecParameters *codecpar = is-&gt;video_st-&gt;codecpar;        //发送VIDEO_SIZE_CHANGED回调和SAR_CHANGED回调        ffp_notify_msg3(ffp, FFP_MSG_VIDEO_SIZE_CHANGED, codecpar-&gt;width, codecpar-&gt;height);        ffp_notify_msg3(ffp, FFP_MSG_SAR_CHANGED, codecpar-&gt;sample_aspect_ratio.num, codecpar-&gt;sample_aspect_ratio.den);    }    ffp-&gt;prepared = true;    //发送PREPARED回调    ffp_notify_msg1(ffp, FFP_MSG_PREPARED);    if (!ffp-&gt;render_wait_start &amp;&amp; !ffp-&gt;start_on_prepared) {        while (is-&gt;pause_req &amp;&amp; !is-&gt;abort_request) {            SDL_Delay(20);        }    }    if (ffp-&gt;auto_resume) {        ffp_notify_msg1(ffp, FFP_REQ_START);        ffp-&gt;auto_resume = 0;    }    /* offset should be seeked*/    if (ffp-&gt;seek_at_start &gt; 0) {        ffp_seek_to_l(ffp, (long)(ffp-&gt;seek_at_start));    }    //开始无限循环,调用ffmpeg的av_read_frame()读取AVPacket，并入队。    for (;;) {        //如果中断请求，则跳出循环        if (is-&gt;abort_request)            break;#ifdef FFP_MERGE        if (is-&gt;paused != is-&gt;last_paused) {            is-&gt;last_paused = is-&gt;paused;            if (is-&gt;paused)                is-&gt;read_pause_return = av_read_pause(ic);            else                av_read_play(ic);        }#endif#if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL        if (is-&gt;paused &amp;&amp;                (!strcmp(ic-&gt;iformat-&gt;name, &quot;rtsp&quot;) ||                 (ic-&gt;pb &amp;&amp; !strncmp(ffp-&gt;input_filename, &quot;mmsh:&quot;, 5)))) {            /* wait 10 ms to avoid trying to get another packet */            /* XXX: horrible */            SDL_Delay(10);            continue;        }#endif        //如果是seek 请求        if (is-&gt;seek_req) {            int64_t seek_target = is-&gt;seek_pos;            int64_t seek_min    = is-&gt;seek_rel &gt; 0 ? seek_target - is-&gt;seek_rel + 2: INT64_MIN;            int64_t seek_max    = is-&gt;seek_rel &lt; 0 ? seek_target - is-&gt;seek_rel - 2: INT64_MAX;// FIXME the +-2 is due to rounding being not done in the correct direction in generation//      of the seek_pos/seek_rel variables            ffp_toggle_buffering(ffp, 1);            ffp_notify_msg3(ffp, FFP_MSG_BUFFERING_UPDATE, 0, 0);            //ffmepg 中处理seek            ret = avformat_seek_file(is-&gt;ic, -1, seek_min, seek_target, seek_max, is-&gt;seek_flags);            if (ret &lt; 0) {                av_log(NULL, AV_LOG_ERROR,                       &quot;%s: error while seeking\n&quot;, is-&gt;ic-&gt;filename);            } else {                if (is-&gt;audio_stream &gt;= 0) {                    packet_queue_flush(&amp;is-&gt;audioq);                    packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);                    // TODO: clear invaild audio data                    // SDL_AoutFlushAudio(ffp-&gt;aout);                }                if (is-&gt;subtitle_stream &gt;= 0) {                    packet_queue_flush(&amp;is-&gt;subtitleq);                    packet_queue_put(&amp;is-&gt;subtitleq, &amp;flush_pkt);                }                if (is-&gt;video_stream &gt;= 0) {                    if (ffp-&gt;node_vdec) {                        ffpipenode_flush(ffp-&gt;node_vdec);                    }                    packet_queue_flush(&amp;is-&gt;videoq);                    packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);                }                if (is-&gt;seek_flags &amp; AVSEEK_FLAG_BYTE) {                   set_clock(&amp;is-&gt;extclk, NAN, 0);                } else {                   set_clock(&amp;is-&gt;extclk, seek_target / (double)AV_TIME_BASE, 0);                }                is-&gt;latest_video_seek_load_serial = is-&gt;videoq.serial;                is-&gt;latest_audio_seek_load_serial = is-&gt;audioq.serial;                is-&gt;latest_seek_load_start_at = av_gettime();            }            ffp-&gt;dcc.current_high_water_mark_in_ms = ffp-&gt;dcc.first_high_water_mark_in_ms;            is-&gt;seek_req = 0;            is-&gt;queue_attachments_req = 1;            is-&gt;eof = 0;#ifdef FFP_MERGE            if (is-&gt;paused)                step_to_next_frame(is);#endif            completed = 0;            SDL_LockMutex(ffp-&gt;is-&gt;play_mutex);            if (ffp-&gt;auto_resume) {                is-&gt;pause_req = 0;                if (ffp-&gt;packet_buffering)                    is-&gt;buffering_on = 1;                ffp-&gt;auto_resume = 0;                stream_update_pause_l(ffp);            }            if (is-&gt;pause_req)                step_to_next_frame_l(ffp);            SDL_UnlockMutex(ffp-&gt;is-&gt;play_mutex);            if (ffp-&gt;enable_accurate_seek) {                is-&gt;drop_aframe_count = 0;                is-&gt;drop_vframe_count = 0;                SDL_LockMutex(is-&gt;accurate_seek_mutex);                if (is-&gt;video_stream &gt;= 0) {                    is-&gt;video_accurate_seek_req = 1;                }                if (is-&gt;audio_stream &gt;= 0) {                    is-&gt;audio_accurate_seek_req = 1;                }                SDL_CondSignal(is-&gt;audio_accurate_seek_cond);                SDL_CondSignal(is-&gt;video_accurate_seek_cond);                SDL_UnlockMutex(is-&gt;accurate_seek_mutex);            }            ffp_notify_msg3(ffp, FFP_MSG_SEEK_COMPLETE, (int)fftime_to_milliseconds(seek_target), ret);            ffp_toggle_buffering(ffp, 1);        }        if (is-&gt;queue_attachments_req) {            if (is-&gt;video_st &amp;&amp; (is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) {                AVPacket copy = { 0 };                if ((ret = av_packet_ref(&amp;copy, &amp;is-&gt;video_st-&gt;attached_pic)) &lt; 0)                    goto fail;                packet_queue_put(&amp;is-&gt;videoq, &amp;copy);                packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);            }            is-&gt;queue_attachments_req = 0;        }        /* if the queue are full, no need to read more */        if (ffp-&gt;infinite_buffer&lt;1 &amp;&amp; !is-&gt;seek_req &amp;&amp;#ifdef FFP_MERGE              (is-&gt;audioq.size + is-&gt;videoq.size + is-&gt;subtitleq.size &gt; MAX_QUEUE_SIZE#else              (is-&gt;audioq.size + is-&gt;videoq.size + is-&gt;subtitleq.size &gt; ffp-&gt;dcc.max_buffer_size#endif                    //内部逻辑为queue-&gt;nb_packets &gt; min_frames            || (   stream_has_enough_packets(is-&gt;audio_st, is-&gt;audio_stream, &amp;is-&gt;audioq, MIN_FRAMES)                &amp;&amp; stream_has_enough_packets(is-&gt;video_st, is-&gt;video_stream, &amp;is-&gt;videoq, MIN_FRAMES)                &amp;&amp; stream_has_enough_packets(is-&gt;subtitle_st, is-&gt;subtitle_stream, &amp;is-&gt;subtitleq, MIN_FRAMES)))) {            if (!is-&gt;eof) {                ffp_toggle_buffering(ffp, 0);            }            /* wait 10 ms */            SDL_LockMutex(wait_mutex);            SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, 10);            SDL_UnlockMutex(wait_mutex);            //进入到下一次循环            continue;        }        //处理播放结束        if ((!is-&gt;paused || completed) &amp;&amp;            (!is-&gt;audio_st || (is-&gt;auddec.finished == is-&gt;audioq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;sampq) == 0)) &amp;&amp;            (!is-&gt;video_st || (is-&gt;viddec.finished == is-&gt;videoq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;pictq) == 0))) {            if (ffp-&gt;loop != 1 &amp;&amp; (!ffp-&gt;loop || --ffp-&gt;loop)) {                stream_seek(is, ffp-&gt;start_time != AV_NOPTS_VALUE ? ffp-&gt;start_time : 0, 0, 0);            } else if (ffp-&gt;autoexit) {                ret = AVERROR_EOF;                goto fail;            } else {                ffp_statistic_l(ffp);                if (completed) {                    av_log(ffp, AV_LOG_INFO, &quot;ffp_toggle_buffering: eof\n&quot;);                    SDL_LockMutex(wait_mutex);                    // infinite wait may block shutdown                    while(!is-&gt;abort_request &amp;&amp; !is-&gt;seek_req)                        SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, 100);                    SDL_UnlockMutex(wait_mutex);                    if (!is-&gt;abort_request)                        continue;                } else {                    completed = 1;                    ffp-&gt;auto_resume = 0;                    // TODO: 0 it&#39;s a bit early to notify complete here                    ffp_toggle_buffering(ffp, 0);                    toggle_pause(ffp, 1);                    if (ffp-&gt;error) {                        av_log(ffp, AV_LOG_INFO, &quot;ffp_toggle_buffering: error: %d\n&quot;, ffp-&gt;error);                        ffp_notify_msg1(ffp, FFP_MSG_ERROR);                    } else {                        av_log(ffp, AV_LOG_INFO, &quot;ffp_toggle_buffering: completed: OK\n&quot;);                        ffp_notify_msg1(ffp, FFP_MSG_COMPLETED);                    }                }            }        }        pkt-&gt;flags = 0;        //读帧，读到这个pkt包里面？        //0 if OK, &lt; 0 on error or end of file        ret = av_read_frame(ic, pkt);        if (ret &lt; 0) {            int pb_eof = 0;            int pb_error = 0;            //EOF表示：end of file            if ((ret == AVERROR_EOF || avio_feof(ic-&gt;pb)) &amp;&amp; !is-&gt;eof) {                ffp_check_buffering_l(ffp);                pb_eof = 1;                // check error later            }            if (ic-&gt;pb &amp;&amp; ic-&gt;pb-&gt;error) {                pb_eof = 1;                pb_error = ic-&gt;pb-&gt;error;            }            if (ret == AVERROR_EXIT) {                pb_eof = 1;                pb_error = AVERROR_EXIT;            }            if (pb_eof) {                if (is-&gt;video_stream &gt;= 0)                    packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);                if (is-&gt;audio_stream &gt;= 0)                    packet_queue_put_nullpacket(&amp;is-&gt;audioq, is-&gt;audio_stream);                if (is-&gt;subtitle_stream &gt;= 0)                    packet_queue_put_nullpacket(&amp;is-&gt;subtitleq, is-&gt;subtitle_stream);                is-&gt;eof = 1;            }            if (pb_error) {                if (is-&gt;video_stream &gt;= 0)                    packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);                if (is-&gt;audio_stream &gt;= 0)                    packet_queue_put_nullpacket(&amp;is-&gt;audioq, is-&gt;audio_stream);                if (is-&gt;subtitle_stream &gt;= 0)                    packet_queue_put_nullpacket(&amp;is-&gt;subtitleq, is-&gt;subtitle_stream);                is-&gt;eof = 1;                ffp-&gt;error = pb_error;                av_log(ffp, AV_LOG_ERROR, &quot;av_read_frame error: %s\n&quot;, ffp_get_error_string(ffp-&gt;error));                // break;            } else {                ffp-&gt;error = 0;            }            if (is-&gt;eof) {                ffp_toggle_buffering(ffp, 0);                SDL_Delay(100);            }            SDL_LockMutex(wait_mutex);            SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, 10);            SDL_UnlockMutex(wait_mutex);            ffp_statistic_l(ffp);            continue;        } else {            is-&gt;eof = 0;        }        //flush_pkt是用来做什么的？        if (pkt-&gt;flags &amp; AV_PKT_FLAG_DISCONTINUITY) {            if (is-&gt;audio_stream &gt;= 0) {                packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);            }            if (is-&gt;subtitle_stream &gt;= 0) {                packet_queue_put(&amp;is-&gt;subtitleq, &amp;flush_pkt);            }            if (is-&gt;video_stream &gt;= 0) {                packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);            }        }        /* check if packet is in play range specified by user, then queue, otherwise discard */        stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;        pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;        pkt_in_play_range = ffp-&gt;duration == AV_NOPTS_VALUE ||                (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) *                av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -                (double)(ffp-&gt;start_time != AV_NOPTS_VALUE ? ffp-&gt;start_time : 0) / 1000000                &lt;= ((double)ffp-&gt;duration / 1000000);        if (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) {            packet_queue_put(&amp;is-&gt;audioq, pkt);        } else if (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range                   &amp;&amp; !(is-&gt;video_st &amp;&amp; (is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC))) {            packet_queue_put(&amp;is-&gt;videoq, pkt);        } else if (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) {            packet_queue_put(&amp;is-&gt;subtitleq, pkt);        } else {            av_packet_unref(pkt);        }        ffp_statistic_l(ffp);        if (ffp-&gt;ijkmeta_delay_init &amp;&amp; !init_ijkmeta &amp;&amp;                (ffp-&gt;first_video_frame_rendered || !is-&gt;video_st) &amp;&amp; (ffp-&gt;first_audio_frame_rendered || !is-&gt;audio_st)) {            ijkmeta_set_avformat_context_l(ffp-&gt;meta, ic);            init_ijkmeta = 1;        }        if (ffp-&gt;packet_buffering) {            io_tick_counter = SDL_GetTickHR();            if ((!ffp-&gt;first_video_frame_rendered &amp;&amp; is-&gt;video_st) || (!ffp-&gt;first_audio_frame_rendered &amp;&amp; is-&gt;audio_st)) {                if (abs((int)(io_tick_counter - prev_io_tick_counter)) &gt; FAST_BUFFERING_CHECK_PER_MILLISECONDS) {                    prev_io_tick_counter = io_tick_counter;                    ffp-&gt;dcc.current_high_water_mark_in_ms = ffp-&gt;dcc.first_high_water_mark_in_ms;                    ffp_check_buffering_l(ffp);                }            } else {                if (abs((int)(io_tick_counter - prev_io_tick_counter)) &gt; BUFFERING_CHECK_PER_MILLISECONDS) {                    prev_io_tick_counter = io_tick_counter;                    ffp_check_buffering_l(ffp);                }            }        }    }    ret = 0; fail:    if (ic &amp;&amp; !is-&gt;ic)        avformat_close_input(&amp;ic);    if (!ffp-&gt;prepared || !is-&gt;abort_request) {        ffp-&gt;last_error = last_error;        ffp_notify_msg2(ffp, FFP_MSG_ERROR, last_error);    }    SDL_DestroyMutex(wait_mutex);    return 0;}</code></pre><h4 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h4><p>总结一下：视频读取线程大致做的事情就是：</p><ol><li>ffmpeg进行协议探测，封装格式探测等网络请求，为创建解码器做准备。</li><li>创建video，audio，subtitle解码器并开启相应的解码线程。</li><li>for循环不断地调用<code>av_read_frame()</code>去从ffmpeg内部维护的网络包缓存去取出下载好的AVPacket，并放入相应的队列中，供稍后解码线程取出解码。</li></ol><p>tex);<br>            if (ffp-&gt;auto_resume) {<br>                is-&gt;pause_req = 0;<br>                if (ffp-&gt;packet_buffering)<br>                    is-&gt;buffering_on = 1;<br>                ffp-&gt;auto_resume = 0;<br>                stream_update_pause_l(ffp);<br>            }<br>            if (is-&gt;pause_req)<br>                step_to_next_frame_l(ffp);<br>            SDL_UnlockMutex(ffp-&gt;is-&gt;play_mutex);</p><pre><code>        if (ffp-&gt;enable_accurate_seek) {            is-&gt;drop_aframe_count = 0;            is-&gt;drop_vframe_count = 0;            SDL_LockMutex(is-&gt;accurate_seek_mutex);            if (is-&gt;video_stream &gt;= 0) {                is-&gt;video_accurate_seek_req = 1;            }            if (is-&gt;audio_stream &gt;= 0) {                is-&gt;audio_accurate_seek_req = 1;            }            SDL_CondSignal(is-&gt;audio_accurate_seek_cond);            SDL_CondSignal(is-&gt;video_accurate_seek_cond);            SDL_UnlockMutex(is-&gt;accurate_seek_mutex);        }        ffp_notify_msg3(ffp, FFP_MSG_SEEK_COMPLETE, (int)fftime_to_milliseconds(seek_target), ret);        ffp_toggle_buffering(ffp, 1);    }    if (is-&gt;queue_attachments_req) {        if (is-&gt;video_st &amp;&amp; (is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC)) {            AVPacket copy = { 0 };            if ((ret = av_packet_ref(&amp;copy, &amp;is-&gt;video_st-&gt;attached_pic)) &lt; 0)                goto fail;            packet_queue_put(&amp;is-&gt;videoq, &amp;copy);            packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);        }        is-&gt;queue_attachments_req = 0;    }    /* if the queue are full, no need to read more */    if (ffp-&gt;infinite_buffer&lt;1 &amp;&amp; !is-&gt;seek_req &amp;&amp;</code></pre><p>#ifdef FFP_MERGE<br>              (is-&gt;audioq.size + is-&gt;videoq.size + is-&gt;subtitleq.size &gt; MAX_QUEUE_SIZE<br>#else<br>              (is-&gt;audioq.size + is-&gt;videoq.size + is-&gt;subtitleq.size &gt; ffp-&gt;dcc.max_buffer_size<br>#endif<br>                    //内部逻辑为queue-&gt;nb_packets &gt; min_frames<br>            || (   stream_has_enough_packets(is-&gt;audio_st, is-&gt;audio_stream, &amp;is-&gt;audioq, MIN_FRAMES)<br>                &amp;&amp; stream_has_enough_packets(is-&gt;video_st, is-&gt;video_stream, &amp;is-&gt;videoq, MIN_FRAMES)<br>                &amp;&amp; stream_has_enough_packets(is-&gt;subtitle_st, is-&gt;subtitle_stream, &amp;is-&gt;subtitleq, MIN_FRAMES)))) {<br>            if (!is-&gt;eof) {<br>                ffp_toggle_buffering(ffp, 0);<br>            }<br>            /* wait 10 ms */<br>            SDL_LockMutex(wait_mutex);<br>            SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, 10);<br>            SDL_UnlockMutex(wait_mutex);<br>            //进入到下一次循环<br>            continue;<br>        }<br>        //处理播放结束<br>        if ((!is-&gt;paused || completed) &amp;&amp;<br>            (!is-&gt;audio_st || (is-&gt;auddec.finished == is-&gt;audioq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;sampq) == 0)) &amp;&amp;<br>            (!is-&gt;video_st || (is-&gt;viddec.finished == is-&gt;videoq.serial &amp;&amp; frame_queue_nb_remaining(&amp;is-&gt;pictq) == 0))) {<br>            if (ffp-&gt;loop != 1 &amp;&amp; (!ffp-&gt;loop || –ffp-&gt;loop)) {<br>                stream_seek(is, ffp-&gt;start_time != AV_NOPTS_VALUE ? ffp-&gt;start_time : 0, 0, 0);<br>            } else if (ffp-&gt;autoexit) {<br>                ret = AVERROR_EOF;<br>                goto fail;<br>            } else {<br>                ffp_statistic_l(ffp);<br>                if (completed) {<br>                    av_log(ffp, AV_LOG_INFO, “ffp_toggle_buffering: eof\n”);<br>                    SDL_LockMutex(wait_mutex);<br>                    // infinite wait may block shutdown<br>                    while(!is-&gt;abort_request &amp;&amp; !is-&gt;seek_req)<br>                        SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, 100);<br>                    SDL_UnlockMutex(wait_mutex);<br>                    if (!is-&gt;abort_request)<br>                        continue;<br>                } else {<br>                    completed = 1;<br>                    ffp-&gt;auto_resume = 0;</p><pre><code>                // TODO: 0 it&#39;s a bit early to notify complete here                ffp_toggle_buffering(ffp, 0);                toggle_pause(ffp, 1);                if (ffp-&gt;error) {                    av_log(ffp, AV_LOG_INFO, &quot;ffp_toggle_buffering: error: %d\n&quot;, ffp-&gt;error);                    ffp_notify_msg1(ffp, FFP_MSG_ERROR);                } else {                    av_log(ffp, AV_LOG_INFO, &quot;ffp_toggle_buffering: completed: OK\n&quot;);                    ffp_notify_msg1(ffp, FFP_MSG_COMPLETED);                }            }        }    }    pkt-&gt;flags = 0;    //读帧，读到这个pkt包里面？    //0 if OK, &lt; 0 on error or end of file    ret = av_read_frame(ic, pkt);    if (ret &lt; 0) {        int pb_eof = 0;        int pb_error = 0;        //EOF表示：end of file        if ((ret == AVERROR_EOF || avio_feof(ic-&gt;pb)) &amp;&amp; !is-&gt;eof) {            ffp_check_buffering_l(ffp);            pb_eof = 1;            // check error later        }        if (ic-&gt;pb &amp;&amp; ic-&gt;pb-&gt;error) {            pb_eof = 1;            pb_error = ic-&gt;pb-&gt;error;        }        if (ret == AVERROR_EXIT) {            pb_eof = 1;            pb_error = AVERROR_EXIT;        }        if (pb_eof) {            if (is-&gt;video_stream &gt;= 0)                packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);            if (is-&gt;audio_stream &gt;= 0)                packet_queue_put_nullpacket(&amp;is-&gt;audioq, is-&gt;audio_stream);            if (is-&gt;subtitle_stream &gt;= 0)                packet_queue_put_nullpacket(&amp;is-&gt;subtitleq, is-&gt;subtitle_stream);            is-&gt;eof = 1;        }        if (pb_error) {            if (is-&gt;video_stream &gt;= 0)                packet_queue_put_nullpacket(&amp;is-&gt;videoq, is-&gt;video_stream);            if (is-&gt;audio_stream &gt;= 0)                packet_queue_put_nullpacket(&amp;is-&gt;audioq, is-&gt;audio_stream);            if (is-&gt;subtitle_stream &gt;= 0)                packet_queue_put_nullpacket(&amp;is-&gt;subtitleq, is-&gt;subtitle_stream);            is-&gt;eof = 1;            ffp-&gt;error = pb_error;            av_log(ffp, AV_LOG_ERROR, &quot;av_read_frame error: %s\n&quot;, ffp_get_error_string(ffp-&gt;error));            // break;        } else {            ffp-&gt;error = 0;        }        if (is-&gt;eof) {            ffp_toggle_buffering(ffp, 0);            SDL_Delay(100);        }        SDL_LockMutex(wait_mutex);        SDL_CondWaitTimeout(is-&gt;continue_read_thread, wait_mutex, 10);        SDL_UnlockMutex(wait_mutex);        ffp_statistic_l(ffp);        continue;    } else {        is-&gt;eof = 0;    }    //flush_pkt是用来做什么的？    if (pkt-&gt;flags &amp; AV_PKT_FLAG_DISCONTINUITY) {        if (is-&gt;audio_stream &gt;= 0) {            packet_queue_put(&amp;is-&gt;audioq, &amp;flush_pkt);        }        if (is-&gt;subtitle_stream &gt;= 0) {            packet_queue_put(&amp;is-&gt;subtitleq, &amp;flush_pkt);        }        if (is-&gt;video_stream &gt;= 0) {            packet_queue_put(&amp;is-&gt;videoq, &amp;flush_pkt);        }    }    /* check if packet is in play range specified by user, then queue, otherwise discard */    stream_start_time = ic-&gt;streams[pkt-&gt;stream_index]-&gt;start_time;    pkt_ts = pkt-&gt;pts == AV_NOPTS_VALUE ? pkt-&gt;dts : pkt-&gt;pts;    pkt_in_play_range = ffp-&gt;duration == AV_NOPTS_VALUE ||            (pkt_ts - (stream_start_time != AV_NOPTS_VALUE ? stream_start_time : 0)) *            av_q2d(ic-&gt;streams[pkt-&gt;stream_index]-&gt;time_base) -            (double)(ffp-&gt;start_time != AV_NOPTS_VALUE ? ffp-&gt;start_time : 0) / 1000000            &lt;= ((double)ffp-&gt;duration / 1000000);    if (pkt-&gt;stream_index == is-&gt;audio_stream &amp;&amp; pkt_in_play_range) {        packet_queue_put(&amp;is-&gt;audioq, pkt);    } else if (pkt-&gt;stream_index == is-&gt;video_stream &amp;&amp; pkt_in_play_range               &amp;&amp; !(is-&gt;video_st &amp;&amp; (is-&gt;video_st-&gt;disposition &amp; AV_DISPOSITION_ATTACHED_PIC))) {        packet_queue_put(&amp;is-&gt;videoq, pkt);    } else if (pkt-&gt;stream_index == is-&gt;subtitle_stream &amp;&amp; pkt_in_play_range) {        packet_queue_put(&amp;is-&gt;subtitleq, pkt);    } else {        av_packet_unref(pkt);    }    ffp_statistic_l(ffp);    if (ffp-&gt;ijkmeta_delay_init &amp;&amp; !init_ijkmeta &amp;&amp;            (ffp-&gt;first_video_frame_rendered || !is-&gt;video_st) &amp;&amp; (ffp-&gt;first_audio_frame_rendered || !is-&gt;audio_st)) {        ijkmeta_set_avformat_context_l(ffp-&gt;meta, ic);        init_ijkmeta = 1;    }    if (ffp-&gt;packet_buffering) {        io_tick_counter = SDL_GetTickHR();        if ((!ffp-&gt;first_video_frame_rendered &amp;&amp; is-&gt;video_st) || (!ffp-&gt;first_audio_frame_rendered &amp;&amp; is-&gt;audio_st)) {            if (abs((int)(io_tick_counter - prev_io_tick_counter)) &gt; FAST_BUFFERING_CHECK_PER_MILLISECONDS) {                prev_io_tick_counter = io_tick_counter;                ffp-&gt;dcc.current_high_water_mark_in_ms = ffp-&gt;dcc.first_high_water_mark_in_ms;                ffp_check_buffering_l(ffp);            }        } else {            if (abs((int)(io_tick_counter - prev_io_tick_counter)) &gt; BUFFERING_CHECK_PER_MILLISECONDS) {                prev_io_tick_counter = io_tick_counter;                ffp_check_buffering_l(ffp);            }        }    }}ret = 0;</code></pre><p> fail:<br>    if (ic &amp;&amp; !is-&gt;ic)<br>        avformat_close_input(&amp;ic);</p><pre><code>if (!ffp-&gt;prepared || !is-&gt;abort_request) {    ffp-&gt;last_error = last_error;    ffp_notify_msg2(ffp, FFP_MSG_ERROR, last_error);}SDL_D</code></pre>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>理解ijkplayer（三）从Java层开始初始化</title>
    <link href="/2019/12/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E4%B8%89%EF%BC%89%E4%BB%8EJava%E5%B1%82%E5%BC%80%E5%A7%8B%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2019/12/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E4%B8%89%EF%BC%89%E4%BB%8EJava%E5%B1%82%E5%BC%80%E5%A7%8B%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p><p>我是一名打算走音视频路线的android开发者。以此系列文章开始，记录我的音视频开发学习之路</p><p>ijkplayer系列文章目录：<br><a href="https://www.jianshu.com/writer#/notebooks/40971763/notes/56760993/preview" target="_blank" rel="noopener">理解ijkplayer（一）：开始</a></p><p><a href="https://www.jianshu.com/p/b5a2584e03f1" target="_blank" rel="noopener">理解ijkplayer（二）项目结构分析</a></p><p><a href="https://www.jianshu.com/p/0501be9cf4bf" target="_blank" rel="noopener">理解ijkplayer（三）从Java层开始初始化</a></p><p><a href="https://www.jianshu.com/p/f633da0db4dd" target="_blank" rel="noopener">理解ijkplayer（四）拉流</a></p><p><a href="https://www.jianshu.com/p/1e10507f18b6" target="_blank" rel="noopener">理解ijkplayer（五）解码、播放</a></p></blockquote><hr><h2 id="1-应用层使用"><a href="#1-应用层使用" class="headerlink" title="1. 应用层使用"></a>1. 应用层使用</h2><pre><code class="kotlin">//实例化val videoView:IjkVideoView = IjkVideoView(this)//添加到布局fl_video_container.addView(    videoView,    ViewGroup.LayoutParams.MATCH_PARENT,    ViewGroup.LayoutParams.MATCH_PARENT)//设置urivideoView.setVideoURI(Uri.parse(url))//开始播放videoView.start()</code></pre><p>短短4行代码就集成了一个播放器，实在太简单了。</p><p>现在开始分析。</p><h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h2><pre><code class="kotlin">val videoView:IjkVideoView = IjkVideoView(this)</code></pre><p>构造函数中调用了–&gt;</p><pre><code class="java">private void initVideoView(Context context) {    mAppContext = context.getApplicationContext();    mSettings = new Settings(mAppContext);    //是否开启后台播放，如果开启了后台播放，就启动一个Service来做后台播放。    initBackground();    //初始化渲染器，创建SurfaceView或TextureView，并addView()。（IjkVideoView是FrameLayout）    initRenders();    //初始化播放器宽高    mVideoWidth = 0;    mVideoHeight = 0;    // REMOVED: getHolder().addCallback(mSHCallback);    // REMOVED: getHolder().setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS);    //焦点    setFocusable(true);    setFocusableInTouchMode(true);    requestFocus();    // REMOVED: mPendingSubtitleTracks = new Vector&lt;Pair&lt;InputStream, MediaFormat&gt;&gt;();    //状态    mCurrentState = STATE_IDLE;    mTargetState = STATE_IDLE;    //字幕View    subtitleDisplay = new TextView(context);    subtitleDisplay.setTextSize(24);    subtitleDisplay.setGravity(Gravity.CENTER);    FrameLayout.LayoutParams layoutParams_txt = new FrameLayout.LayoutParams(            FrameLayout.LayoutParams.MATCH_PARENT,            FrameLayout.LayoutParams.WRAP_CONTENT,            Gravity.BOTTOM);    addView(subtitleDisplay, layoutParams_txt);}</code></pre><p>注意：</p><p><code>initRenders()</code>创建的渲染器View，要在<code>IjkMediaPlayer</code>对象创建后才设置给播放器对象，现在只是创建，并添加到layout。</p><h2 id="3-setVideoURI"><a href="#3-setVideoURI" class="headerlink" title="3. setVideoURI()"></a>3. setVideoURI()</h2><pre><code class="java">private void setVideoURI(Uri uri, Map&lt;String, String&gt; headers) {    mUri = uri;    mHeaders = headers;    mSeekWhenPrepared = 0;      //打开视频    openVideo();    requestLayout();    invalidate();}</code></pre><pre><code class="java">@TargetApi(Build.VERSION_CODES.M)private void openVideo() {    if (mUri == null || mSurfaceHolder == null) {        // not ready for playback just yet, will try again later        return;    }    // we shouldn&#39;t clear the target state, because somebody might have    // called start() previously    release(false);      //获取音频焦点    AudioManager am = (AudioManager) mAppContext.getSystemService(Context.AUDIO_SERVICE);    am.requestAudioFocus(null, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);    try {          //创建IjkMediaPlayer对象，他是真正的播放器对象。        mMediaPlayer = createPlayer(mSettings.getPlayer());        // TODO: create SubtitleController in MediaPlayer, but we need        // a context for the subtitle renderers        final Context context = getContext();        // REMOVED: SubtitleController        // REMOVED: mAudioSession          //设置IjkMediaPlayer对象从c层发出的各种播放器事件的回调，并通过对应的mXXXListener变量转发到上层        mMediaPlayer.setOnPreparedListener(mPreparedListener);        mMediaPlayer.setOnVideoSizeChangedListener(mSizeChangedListener);        mMediaPlayer.setOnCompletionListener(mCompletionListener);        mMediaPlayer.setOnErrorListener(mErrorListener);        mMediaPlayer.setOnInfoListener(mInfoListener);        mMediaPlayer.setOnBufferingUpdateListener(mBufferingUpdateListener);        mMediaPlayer.setOnSeekCompleteListener(mSeekCompleteListener);        mMediaPlayer.setOnTimedTextListener(mOnTimedTextListener);        mCurrentBufferPercentage = 0;        String scheme = mUri.getScheme();          //调用setDataSouce()设置数据源。本地url或者网络url        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M &amp;&amp;                mSettings.getUsingMediaDataSource() &amp;&amp;                (TextUtils.isEmpty(scheme) || scheme.equalsIgnoreCase(&quot;file&quot;))) {            IMediaDataSource dataSource = new FileMediaDataSource(new File(mUri.toString()));            mMediaPlayer.setDataSource(dataSource);        }  else if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) {            mMediaPlayer.setDataSource(mAppContext, mUri, mHeaders);        } else {            mMediaPlayer.setDataSource(mUri.toString());        }          //将渲染器（SurfaceView或TextureView）传递给IjkMediaPlayer对象，即设置渲染器。        bindSurfaceHolder(mMediaPlayer, mSurfaceHolder);          //设置音频流类型（原生MediaPlayer有逻辑，而IjkMediaPlayer是空实现）        mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);          //setKeepScreenOn不息屏        mMediaPlayer.setScreenOnWhilePlaying(true);          //记录preapare前的时间（后面onPrepared回调里面会根据这个事件算出parepare花了多长时间）        mPrepareStartTime = System.currentTimeMillis();          //异步prepare        mMediaPlayer.prepareAsync();        if (mHudViewHolder != null)            mHudViewHolder.setMediaPlayer(mMediaPlayer);        // REMOVED: mPendingSubtitleTracks        // we don&#39;t set the target state here either, but preserve the        // target state that was there before.        mCurrentState = STATE_PREPARING;        attachMediaController();    } catch (IOException ex) {        Log.w(TAG, &quot;Unable to open content: &quot; + mUri, ex);        mCurrentState = STATE_ERROR;        mTargetState = STATE_ERROR;        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);    } catch (IllegalArgumentException ex) {        Log.w(TAG, &quot;Unable to open content: &quot; + mUri, ex);        mCurrentState = STATE_ERROR;        mTargetState = STATE_ERROR;        mErrorListener.onError(mMediaPlayer, MediaPlayer.MEDIA_ERROR_UNKNOWN, 0);    } finally {        // REMOVED: mPendingSubtitleTracks.clear();    }}</code></pre><p>这里创建播放器的入口：</p><pre><code class="java">//创建IjkMediaPlayer对象，他是真正的播放器对象。mMediaPlayer = createPlayer(mSettings.getPlayer());//--&gt;ijkMediaPlayer = new IjkMediaPlayer();</code></pre><pre><code class="java">//IjkMediaPlayer.javapublic IjkMediaPlayer() {    this(sLocalLibLoader);}public IjkMediaPlayer(IjkLibLoader libLoader) {    initPlayer(libLoader);}private void initPlayer(IjkLibLoader libLoader) {      //装载so库    loadLibrariesOnce(libLoader);      //第一次调用c层函数，native_init()，初始化c层播放器    initNativeOnce();    Looper looper;    if ((looper = Looper.myLooper()) != null) {        mEventHandler = new EventHandler(this, looper);    } else if ((looper = Looper.getMainLooper()) != null) {        mEventHandler = new EventHandler(this, looper);    } else {        mEventHandler = null;    }    /*     * Native setup requires a weak reference to our object. It&#39;s easier to     * create it here than in C++.     */      //调用native_setup()    native_setup(new WeakReference&lt;IjkMediaPlayer&gt;(this));}public static void loadLibrariesOnce(IjkLibLoader libLoader) {    synchronized (IjkMediaPlayer.class) {        if (!mIsLibLoaded) {            if (libLoader == null)                libLoader = sLocalLibLoader;            libLoader.loadLibrary(&quot;ijkffmpeg&quot;);            libLoader.loadLibrary(&quot;ijksdl&quot;);            libLoader.loadLibrary(&quot;ijkplayer&quot;);            mIsLibLoaded = true;        }    }}private static void initNativeOnce() {    synchronized (IjkMediaPlayer.class) {        if (!mIsNativeInitialized) {            native_init();            mIsNativeInitialized = true;        }    }}</code></pre><p>那么，在<code>setVideoURI()</code>方法中，总共调用了jni的方法为：</p><table><thead><tr><th>java方法</th><th>jni方法</th></tr></thead><tbody><tr><td>initNativeOnce</td><td>native_init()</td></tr><tr><td>initPlayer()中</td><td>native_setup</td></tr><tr><td>setDataSource()</td><td>_setDataSource()</td></tr><tr><td>setDisplay(SurfaceHolder) /  setSurface(Surface)</td><td>_setVideoSurface(Surface)</td></tr><tr><td>prepareAsync()</td><td>_prepareAsync()</td></tr></tbody></table><p>接下来逐个分析各个c层的方法做了什么。</p><p>在开始分析c层代码之前，要知道一下ijkplayer的jni方法是动态注册的。</p><p>动态注册Jni方法详见<a href="https://developer.android.google.cn/training/articles/perf-jni" target="_blank" rel="noopener">官方文档</a></p><p>即借助<code>JNI_OnLoad()</code>方法去动态注册。</p><h3 id="3-1-JNI-Onload"><a href="#3-1-JNI-Onload" class="headerlink" title="3.1 JNI_Onload()"></a>3.1 JNI_Onload()</h3><pre><code class="c">JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved){    JNIEnv* env = NULL;    g_jvm = vm;    if ((*vm)-&gt;GetEnv(vm, (void**) &amp;env, JNI_VERSION_1_4) != JNI_OK) {        return -1;    }    assert(env != NULL);    pthread_mutex_init(&amp;g_clazz.mutex, NULL );    // FindClass returns LocalReference    IJK_FIND_JAVA_CLASS(env, g_clazz.clazz, JNI_CLASS_IJKPLAYER);    //标准的饿RegisterNatives方法，g_methods方法返回要注册的jni方法数组    (*env)-&gt;RegisterNatives(env, g_clazz.clazz, g_methods, NELEM(g_methods) );    //播放器全局初始化，注册ffmpeg的解码器，解封装器，加载外部库如openssl等    ijkmp_global_init();    ijkmp_global_set_inject_callback(inject_callback);    FFmpegApi_global_init(env);    return JNI_VERSION_1_4;}</code></pre><h4 id="3-1-1-注册jni方法"><a href="#3-1-1-注册jni方法" class="headerlink" title="3.1.1 注册jni方法"></a>3.1.1 注册jni方法</h4><p>在<code>g_methods()</code>方法中，定义了所有的从java–&gt;c的jni方法。</p><pre><code class="c">static JNINativeMethod g_methods[] = {    {        &quot;_setDataSource&quot;,        &quot;(Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)V&quot;,        (void *) IjkMediaPlayer_setDataSourceAndHeaders    },    { &quot;_setDataSourceFd&quot;,       &quot;(I)V&quot;,     (void *) IjkMediaPlayer_setDataSourceFd },    { &quot;_setDataSource&quot;,         &quot;(Ltv/danmaku/ijk/media/player/misc/IMediaDataSource;)V&quot;, (void *)IjkMediaPlayer_setDataSourceCallback },    { &quot;_setAndroidIOCallback&quot;,  &quot;(Ltv/danmaku/ijk/media/player/misc/IAndroidIO;)V&quot;, (void *)IjkMediaPlayer_setAndroidIOCallback },    { &quot;_setVideoSurface&quot;,       &quot;(Landroid/view/Surface;)V&quot;, (void *) IjkMediaPlayer_setVideoSurface },    { &quot;_prepareAsync&quot;,          &quot;()V&quot;,      (void *) IjkMediaPlayer_prepareAsync },    { &quot;_start&quot;,                 &quot;()V&quot;,      (void *) IjkMediaPlayer_start },    { &quot;_stop&quot;,                  &quot;()V&quot;,      (void *) IjkMediaPlayer_stop },    { &quot;seekTo&quot;,                 &quot;(J)V&quot;,     (void *) IjkMediaPlayer_seekTo },    { &quot;_pause&quot;,                 &quot;()V&quot;,      (void *) IjkMediaPlayer_pause },    { &quot;isPlaying&quot;,              &quot;()Z&quot;,      (void *) IjkMediaPlayer_isPlaying },    { &quot;getCurrentPosition&quot;,     &quot;()J&quot;,      (void *) IjkMediaPlayer_getCurrentPosition },    { &quot;getDuration&quot;,            &quot;()J&quot;,      (void *) IjkMediaPlayer_getDuration },    { &quot;_release&quot;,               &quot;()V&quot;,      (void *) IjkMediaPlayer_release },    { &quot;_reset&quot;,                 &quot;()V&quot;,      (void *) IjkMediaPlayer_reset },    { &quot;setVolume&quot;,              &quot;(FF)V&quot;,    (void *) IjkMediaPlayer_setVolume },    { &quot;getAudioSessionId&quot;,      &quot;()I&quot;,      (void *) IjkMediaPlayer_getAudioSessionId },    { &quot;native_init&quot;,            &quot;()V&quot;,      (void *) IjkMediaPlayer_native_init },    { &quot;native_setup&quot;,           &quot;(Ljava/lang/Object;)V&quot;, (void *) IjkMediaPlayer_native_setup },    { &quot;native_finalize&quot;,        &quot;()V&quot;,      (void *) IjkMediaPlayer_native_finalize },    { &quot;_setOption&quot;,             &quot;(ILjava/lang/String;Ljava/lang/String;)V&quot;, (void *) IjkMediaPlayer_setOption },    { &quot;_setOption&quot;,             &quot;(ILjava/lang/String;J)V&quot;,                  (void *) IjkMediaPlayer_setOptionLong },    { &quot;_getColorFormatName&quot;,    &quot;(I)Ljava/lang/String;&quot;,    (void *) IjkMediaPlayer_getColorFormatName },    { &quot;_getVideoCodecInfo&quot;,     &quot;()Ljava/lang/String;&quot;,     (void *) IjkMediaPlayer_getVideoCodecInfo },    { &quot;_getAudioCodecInfo&quot;,     &quot;()Ljava/lang/String;&quot;,     (void *) IjkMediaPlayer_getAudioCodecInfo },    { &quot;_getMediaMeta&quot;,          &quot;()Landroid/os/Bundle;&quot;,    (void *) IjkMediaPlayer_getMediaMeta },    { &quot;_setLoopCount&quot;,          &quot;(I)V&quot;,                     (void *) IjkMediaPlayer_setLoopCount },    { &quot;_getLoopCount&quot;,          &quot;()I&quot;,                      (void *) IjkMediaPlayer_getLoopCount },    { &quot;_getPropertyFloat&quot;,      &quot;(IF)F&quot;,                    (void *) ijkMediaPlayer_getPropertyFloat },    { &quot;_setPropertyFloat&quot;,      &quot;(IF)V&quot;,                    (void *) ijkMediaPlayer_setPropertyFloat },    { &quot;_getPropertyLong&quot;,       &quot;(IJ)J&quot;,                    (void *) ijkMediaPlayer_getPropertyLong },    { &quot;_setPropertyLong&quot;,       &quot;(IJ)V&quot;,                    (void *) ijkMediaPlayer_setPropertyLong },    { &quot;_setStreamSelected&quot;,     &quot;(IZ)V&quot;,                    (void *) ijkMediaPlayer_setStreamSelected },    { &quot;native_profileBegin&quot;,    &quot;(Ljava/lang/String;)V&quot;,    (void *) IjkMediaPlayer_native_profileBegin },    { &quot;native_profileEnd&quot;,      &quot;()V&quot;,                      (void *) IjkMediaPlayer_native_profileEnd },    { &quot;native_setLogLevel&quot;,     &quot;(I)V&quot;,                     (void *) IjkMediaPlayer_native_setLogLevel },    { &quot;_setFrameAtTime&quot;,        &quot;(Ljava/lang/String;JJII)V&quot;, (void *) IjkMediaPlayer_setFrameAtTime },};</code></pre><h4 id="3-1-2-播放器全局初始化"><a href="#3-1-2-播放器全局初始化" class="headerlink" title="3.1.2 播放器全局初始化"></a>3.1.2 播放器全局初始化</h4><p>后面调用</p><pre><code class="c">//播放器全局初始化，注册ffmpeg的解码器，解封装器，加载外部库如openssl等ijkmp_global_init();</code></pre><p>调用到<code>ijkmedia/ijkplayer/ff_ffplay.c</code></p><pre><code class="c">void ffp_global_init(){    if (g_ffmpeg_global_inited)        return;    ALOGD(&quot;ijkmediaplayer version : %s&quot;, ijkmp_version());    /* register all codecs, demux and protocols */    //ffmpeg方法，注册所有的编码器和解码器    avcodec_register_all();#if CONFIG_AVDEVICE    //ffmpeg方法，注册所有设备    avdevice_register_all();#endif#if CONFIG_AVFILTER    //注册所有过滤器（注册所有过滤器）    avfilter_register_all();#endif    //ffmpeg方法，注册所有封装器和解封装器    av_register_all();    //ijkmedia/ijkplayer/ijkavformat/allformats.c注册ijkplayer额外支持的协议，例如ijkio，async，ijklongurl    ijkav_register_all();    //初始化openssl库    avformat_network_init();    av_lockmgr_register(lockmgr);    av_log_set_callback(ffp_log_callback_brief);    av_init_packet(&amp;flush_pkt);    flush_pkt.data = (uint8_t *)&amp;flush_pkt;    g_ffmpeg_global_inited = true;}</code></pre><p>到这里，ijkplayer借助<code>JNI_OnLoad（）</code>方法进行了</p><ol><li>jni方法的注册</li><li>ffmpeg编解码器的注册，ffmpeg封装解封装器的注册，其他外部库如openssl的加载等。</li></ol><h3 id="3-2-native-init"><a href="#3-2-native-init" class="headerlink" title="3.2 native_init()"></a>3.2 native_init()</h3><p>根据<code>g_methods()方法</code>中的jni方法映射，找到对应的方法，所有直接映射的方法都依然在<code>ijkmedia/ijkplayer/android/ijkplayer_jni.c</code>中定义（后续所有的Jni方法直接给出对应的c层映射方法）：</p><pre><code class="c">static voidIjkMediaPlayer_native_init(JNIEnv *env){    MPTRACE(&quot;%s\n&quot;, __func__);}</code></pre><p>这个<code>MPTRACE()</code>方法会去调用<code>ALOG()</code>方法，而后者调用<code>(void)printf(__VA_ARGS__)</code>，也就是打印。</p><p>我猜这个方法应该是作者预留给开发者的初始化方法？</p><h3 id="3-3-native-setup"><a href="#3-3-native-setup" class="headerlink" title="3.3 native_setup()"></a>3.3 native_setup()</h3><pre><code class="c">static voidIjkMediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this){    MPTRACE(&quot;%s\n&quot;, __func__);    //创建IjkMediaPlayer，并传入message_loop()方法作为参数    IjkMediaPlayer *mp = ijkmp_android_create(message_loop);    JNI_CHECK_GOTO(mp, env, &quot;java/lang/OutOfMemoryError&quot;, &quot;mpjni: native_setup: ijkmp_create() failed&quot;, LABEL_RETURN);    jni_set_media_player(env, thiz, mp);    ijkmp_set_weak_thiz(mp, (*env)-&gt;NewGlobalRef(env, weak_this));    ijkmp_set_inject_opaque(mp, ijkmp_get_weak_thiz(mp));    ijkmp_set_ijkio_inject_opaque(mp, ijkmp_get_weak_thiz(mp));    ijkmp_android_set_mediacodec_select_callback(mp, mediacodec_select_callback, ijkmp_get_weak_thiz(mp));LABEL_RETURN:    ijkmp_dec_ref_p(&amp;mp);}</code></pre><h4 id="3-3-1-创建类似looper的消息机制"><a href="#3-3-1-创建类似looper的消息机制" class="headerlink" title="3.3.1 创建类似looper的消息机制"></a>3.3.1 创建类似looper的消息机制</h4><p>在上面的代码中，<code>message_loop()</code>方法创建了类似android的looper的消息机制，如果不熟悉的话，要复习一下Android的Looper、MessageQueue、Handler那一套了。</p><pre><code class="c">static int message_loop(void *arg){    MPTRACE(&quot;%s\n&quot;, __func__);    JNIEnv *env = NULL;    if (JNI_OK != SDL_JNI_SetupThreadEnv(&amp;env)) {        ALOGE(&quot;%s: SetupThreadEnv failed\n&quot;, __func__);        return -1;    }    IjkMediaPlayer *mp = (IjkMediaPlayer*) arg;    JNI_CHECK_GOTO(mp, env, NULL, &quot;mpjni: native_message_loop: null mp&quot;, LABEL_RETURN);    //开启类似Android的looper的消息机制。    message_loop_n(env, mp);LABEL_RETURN:    ijkmp_dec_ref_p(&amp;mp);    MPTRACE(&quot;message_loop exit&quot;);    return 0;}</code></pre><pre><code class="c">//message_loop_n函数中取消息，并用post_event调用jni方法把事件发送到java层static void message_loop_n(JNIEnv *env, IjkMediaPlayer *mp){    jobject weak_thiz = (jobject) ijkmp_get_weak_thiz(mp);    JNI_CHECK_GOTO(weak_thiz, env, NULL, &quot;mpjni: message_loop_n: null weak_thiz&quot;, LABEL_RETURN);    while (1) {        AVMessage msg;        //取消息队列的消息，如果没有消息就阻塞，直到有消息被发到消息队列。        int retval = ijkmp_get_msg(mp, &amp;msg, 1);        if (retval &lt; 0)            break;        // block-get should never return 0        assert(retval &gt; 0);        switch (msg.what) {        case FFP_MSG_FLUSH:            MPTRACE(&quot;FFP_MSG_FLUSH:\n&quot;);            //调用post_event，把事件发送到java层。            post_event(env, weak_thiz, MEDIA_NOP, 0, 0);            break;        case FFP_MSG_ERROR:            MPTRACE(&quot;FFP_MSG_ERROR: %d\n&quot;, msg.arg1);            post_event(env, weak_thiz, MEDIA_ERROR, MEDIA_ERROR_IJK_PLAYER, msg.arg1);            break;        case FFP_MSG_PREPARED:            MPTRACE(&quot;FFP_MSG_PREPARED:\n&quot;);            post_event(env, weak_thiz, MEDIA_PREPARED, 0, 0);            break;        case FFP_MSG_COMPLETED:            MPTRACE(&quot;FFP_MSG_COMPLETED:\n&quot;);            post_event(env, weak_thiz, MEDIA_PLAYBACK_COMPLETE, 0, 0);            break;        //...其他省略        msg_free_res(&amp;msg);    }LABEL_RETURN:    ;}</code></pre><pre><code class="c">//获取消息，并在这个函数中针对每一个取出来的消息做c层的处理，例如ijkplayer的当前播放器状态的赋值。int ijkmp_get_msg(IjkMediaPlayer *mp, AVMessage *msg, int block){    assert(mp);    while (1) {        int continue_wait_next_msg = 0;        //取消息，如果没有消息则阻塞。        int retval = msg_queue_get(&amp;mp-&gt;ffplayer-&gt;msg_queue, msg, block);        if (retval &lt;= 0)            return retval;        switch (msg-&gt;what) {        case FFP_MSG_PREPARED:            MPTRACE(&quot;ijkmp_get_msg: FFP_MSG_PREPARED\n&quot;);            pthread_mutex_lock(&amp;mp-&gt;mutex);            if (mp-&gt;mp_state == MP_STATE_ASYNC_PREPARING) {                ijkmp_change_state_l(mp, MP_STATE_PREPARED);            } else {                // FIXME: 1: onError() ?                av_log(mp-&gt;ffplayer, AV_LOG_DEBUG, &quot;FFP_MSG_PREPARED: expecting mp_state==MP_STATE_ASYNC_PREPARING\n&quot;);            }            if (!mp-&gt;ffplayer-&gt;start_on_prepared) {                ijkmp_change_state_l(mp, MP_STATE_PAUSED);            }            pthread_mutex_unlock(&amp;mp-&gt;mutex);            break;        case FFP_MSG_COMPLETED:            MPTRACE(&quot;ijkmp_get_msg: FFP_MSG_COMPLETED\n&quot;);            pthread_mutex_lock(&amp;mp-&gt;mutex);            mp-&gt;restart = 1;            mp-&gt;restart_from_beginning = 1;            ijkmp_change_state_l(mp, MP_STATE_COMPLETED);            pthread_mutex_unlock(&amp;mp-&gt;mutex);            break;        //...省略        if (continue_wait_next_msg) {            msg_free_res(msg);            continue;        }        return retval;    }    return -1;}</code></pre><pre><code class="c">/* return &lt; 0 if aborted, 0 if no msg and &gt; 0 if msg.  */inline static int msg_queue_get(MessageQueue *q, AVMessage *msg, int block){    AVMessage *msg1;    int ret;    SDL_LockMutex(q-&gt;mutex);    for (;;) {        if (q-&gt;abort_request) {            ret = -1;            break;        }        msg1 = q-&gt;first_msg;        if (msg1) {            q-&gt;first_msg = msg1-&gt;next;            if (!q-&gt;first_msg)                q-&gt;last_msg = NULL;            q-&gt;nb_messages--;            *msg = *msg1;            msg1-&gt;obj = NULL;#ifdef FFP_MERGE            av_free(msg1);#else            msg1-&gt;next = q-&gt;recycle_msg;            q-&gt;recycle_msg = msg1;#endif            ret = 1;            break;        } else if (!block) {            ret = 0;            break;        } else {            //如果消息队列为空，则阻塞当前线程并等待被唤醒。            SDL_CondWait(q-&gt;cond, q-&gt;mutex);        }    }    SDL_UnlockMutex(q-&gt;mutex);    return ret;}</code></pre><p>而<code>post_event（）</code>方法会将事件从c层抛到java层的：</p><pre><code class="java">//tv.danmaku.ijk.media.player.IjkMediaPlayer/* * Called from native code when an interesting event happens. This method * just uses the EventHandler system to post the event back to the main app * thread. We use a weak reference to the original IjkMediaPlayer object so * that the native code is safe from the object disappearing from underneath * it. (This is the cookie passed to native_setup().) */@CalledByNativeprivate static void postEventFromNative(Object weakThiz, int what,        int arg1, int arg2, Object obj) {    if (weakThiz == null)        return;    @SuppressWarnings(&quot;rawtypes&quot;)    IjkMediaPlayer mp = (IjkMediaPlayer) ((WeakReference) weakThiz).get();    if (mp == null) {        return;    }    if (what == MEDIA_INFO &amp;&amp; arg1 == MEDIA_INFO_STARTED_AS_NEXT) {        // this acquires the wakelock if needed, and sets the client side        // state        mp.start();    }    if (mp.mEventHandler != null) {        Message m = mp.mEventHandler.obtainMessage(what, arg1, arg2, obj);        mp.mEventHandler.sendMessage(m);    }}private static class EventHandler extends Handler {        private final WeakReference&lt;IjkMediaPlayer&gt; mWeakPlayer;        public EventHandler(IjkMediaPlayer mp, Looper looper) {            super(looper);            mWeakPlayer = new WeakReference&lt;IjkMediaPlayer&gt;(mp);        }        @Override        public void handleMessage(Message msg) {            IjkMediaPlayer player = mWeakPlayer.get();            if (player == null || player.mNativeMediaPlayer == 0) {                DebugLog.w(TAG,                        &quot;IjkMediaPlayer went away with unhandled events&quot;);                return;            }                        //根据事件类型，回调对应的OnXXX方法，把播放器状态回调给使用IjkPlayer的java开发者            switch (msg.what) {            case MEDIA_PREPARED:                player.notifyOnPrepared();                return;            case MEDIA_PLAYBACK_COMPLETE:                player.stayAwake(false);                player.notifyOnCompletion();                return;            case MEDIA_BUFFERING_UPDATE:                long bufferPosition = msg.arg1;                if (bufferPosition &lt; 0) {                    bufferPosition = 0;                }                long percent = 0;                long duration = player.getDuration();                if (duration &gt; 0) {                    percent = bufferPosition * 100 / duration;                }                if (percent &gt;= 100) {                    percent = 100;                }                // DebugLog.efmt(TAG, &quot;Buffer (%d%%) %d/%d&quot;,  percent, bufferPosition, duration);                player.notifyOnBufferingUpdate((int)percent);                return;            case MEDIA_SEEK_COMPLETE:                player.notifyOnSeekComplete();                return;            case MEDIA_SET_VIDEO_SIZE:                player.mVideoWidth = msg.arg1;                player.mVideoHeight = msg.arg2;                player.notifyOnVideoSizeChanged(player.mVideoWidth, player.mVideoHeight,                        player.mVideoSarNum, player.mVideoSarDen);                return;            case MEDIA_ERROR:                DebugLog.e(TAG, &quot;Error (&quot; + msg.arg1 + &quot;,&quot; + msg.arg2 + &quot;)&quot;);                if (!player.notifyOnError(msg.arg1, msg.arg2)) {                    player.notifyOnCompletion();                }                player.stayAwake(false);                return;            case MEDIA_INFO:                switch (msg.arg1) {                    case MEDIA_INFO_VIDEO_RENDERING_START:                        DebugLog.i(TAG, &quot;Info: MEDIA_INFO_VIDEO_RENDERING_START\n&quot;);                        break;                }                player.notifyOnInfo(msg.arg1, msg.arg2);                // No real default action so far.                return;            case MEDIA_TIMED_TEXT:                if (msg.obj == null) {                    player.notifyOnTimedText(null);                } else {                    IjkTimedText text = new IjkTimedText(new Rect(0, 0, 1, 1), (String)msg.obj);                    player.notifyOnTimedText(text);                }                return;            case MEDIA_NOP: // interface test message - ignore                break;            case MEDIA_SET_VIDEO_SAR:                player.mVideoSarNum = msg.arg1;                player.mVideoSarDen = msg.arg2;                player.notifyOnVideoSizeChanged(player.mVideoWidth, player.mVideoHeight,                        player.mVideoSarNum, player.mVideoSarDen);                break;            default:                DebugLog.e(TAG, &quot;Unknown message type &quot; + msg.what);            }        }    }</code></pre><p>到这里，从java到c和从c到java的事件通信和传送大概就是这些了，然而种类面涉及到一些细节例如：线程转换等，并没有去探究，</p><p>注意,<code>message_loop()</code>方法是创建一个消息循环机制，那么回到<code>message_loop()</code>函数被使用的地方：</p><pre><code class="c">static voidIjkMediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this){    MPTRACE(&quot;%s\n&quot;, __func__);    //创建IjkMediaPlayer，并传入message_loop()方法作为参数    IjkMediaPlayer *mp = ijkmp_android_create(message_loop);    JNI_CHECK_GOTO(mp, env, &quot;java/lang/OutOfMemoryError&quot;, &quot;mpjni: native_setup: ijkmp_create() failed&quot;, LABEL_RETURN);    jni_set_media_player(env, thiz, mp);    ijkmp_set_weak_thiz(mp, (*env)-&gt;NewGlobalRef(env, weak_this));    ijkmp_set_inject_opaque(mp, ijkmp_get_weak_thiz(mp));    ijkmp_set_ijkio_inject_opaque(mp, ijkmp_get_weak_thiz(mp));    ijkmp_android_set_mediacodec_select_callback(mp, mediacodec_select_callback, ijkmp_get_weak_thiz(mp));LABEL_RETURN:    ijkmp_dec_ref_p(&amp;mp);}</code></pre><p><code>message_loop</code>这个函数作为参数被传递，在这里依然还没有调用，即没有开启循环读队列。那么猜想<code>message_loop</code>函数一定是被传递下去，在某个地方被调用了，并且需要在一个独立的线程中调用，就像模拟Android的<code>HandlerThread</code>类做的那样，一个独立的线程中开启了循环。</p><h4 id="3-3-2-创建IjkMediaPlayer"><a href="#3-3-2-创建IjkMediaPlayer" class="headerlink" title="3.3.2 创建IjkMediaPlayer"></a>3.3.2 创建IjkMediaPlayer</h4><p>依然看到上面的代码块，通过<code>ijkmp_android_create(message_loop)</code>方法创建了<code>IjkMediaPlayer</code>播放器结构体，在看具体创建代码之前，我们先看一下结构体：</p><pre><code class="c">//    ijkmedia/ijkplayer/ijkplayer_internal.hstruct IjkMediaPlayer {    volatile int ref_count;      //互斥锁，用于保证线程安全    pthread_mutex_t mutex;      //ffplayer，位于ijkmedia/ijkplayer/ff_ffplay_def.h，他会直接调用ffmpeg的方法了    FFPlayer *ffplayer;      //一个函数指针，指向的是谁？指向的其实就是刚才创建的message_loop，即消息循环函数    int (*msg_loop)(void*);      //消息机制线程    SDL_Thread *msg_thread;    SDL_Thread _msg_thread;        //播放器状态，例如prepared,resumed,error,completed等    int mp_state;      //字符串，就是一个播放url    char *data_source;      //弱引用    void *weak_thiz;    int restart;    int restart_from_beginning;    int seek_req;    long seek_msec;};</code></pre><p>结构体的说明如注释所示。</p><p>那么现在看创建播放器的函数：</p><pre><code class="c">//    ijkmedia/ijkplayer/android/ijkplayer_android.cIjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*)){    //创建IjkMediaPlayer    IjkMediaPlayer *mp = ijkmp_create(msg_loop);    if (!mp)        goto fail;    //创建视频输出设备，会根据根据硬解还是软件，硬解用MediaCodec创建，软解用FFmpeg创建    mp-&gt;ffplayer-&gt;vout = SDL_VoutAndroid_CreateForAndroidSurface();    if (!mp-&gt;ffplayer-&gt;vout)        goto fail;    //暂时不太理解这个叫做”管道“的东西是什么    mp-&gt;ffplayer-&gt;pipeline = ffpipeline_create_from_android(mp-&gt;ffplayer);    if (!mp-&gt;ffplayer-&gt;pipeline)        goto fail;    //将创建的视频输出设备vout，赋值到ffplayer-&gt;pipeline中    ffpipeline_set_vout(mp-&gt;ffplayer-&gt;pipeline, mp-&gt;ffplayer-&gt;vout);    return mp;fail:    ijkmp_dec_ref_p(&amp;mp);    return NULL;}</code></pre><p>那么看到创建<code>IjkMediaPlayer</code>的函数</p><pre><code class="c">//    ijkmedia/ijkplayer/ff_ffplay.cIjkMediaPlayer *ijkmp_create(int (*msg_loop)(void*)){    //分配内存    IjkMediaPlayer *mp = (IjkMediaPlayer *) mallocz(sizeof(IjkMediaPlayer));    if (!mp)        goto fail;    //创建IjkMediaPlayer内部的FFPlayer    mp-&gt;ffplayer = ffp_create();    if (!mp-&gt;ffplayer)        goto fail;    //注意：将msg_loop函数赋值给IjkMediaPlayer的函数引用，在创建的时候赋值，在另一处被调用。    //在哪里被调用呢？在prepareAsync()里面，后面分析prepare方法的时候就会再见到消息循环函数了。    mp-&gt;msg_loop = msg_loop;    ijkmp_inc_ref(mp);    pthread_mutex_init(&amp;mp-&gt;mutex, NULL);    return mp;    fail:    ijkmp_destroy_p(&amp;mp);    return NULL;}</code></pre><p>那么再看到<code>ffp_create()</code>方法中创建<code>FFPlayer</code>的逻辑</p><pre><code class="c">FFPlayer *ffp_create(){    av_log(NULL, AV_LOG_INFO, &quot;av_version_info: %s\n&quot;, av_version_info());    av_log(NULL, AV_LOG_INFO, &quot;ijk_version_info: %s\n&quot;, ijk_version_info());    FFPlayer* ffp = (FFPlayer*) av_mallocz(sizeof(FFPlayer));    if (!ffp)        return NULL;    //创建消息循环的消息队列MessageQueue，这个MessageQueue就是后面在message_loop函数中调用的那个    msg_queue_init(&amp;ffp-&gt;msg_queue);    ffp-&gt;af_mutex = SDL_CreateMutex();    ffp-&gt;vf_mutex = SDL_CreateMutex();    //重置ffplayer属性    ffp_reset_internal(ffp);    //赋值AVClass，是一个常量    ffp-&gt;av_class = &amp;ffp_context_class;    //创建IjkMediaMeta    ffp-&gt;meta = ijkmeta_create();    av_opt_set_defaults(ffp);    return ffp;}</code></pre><p>播放器的创建到这里就结束了，但是还没有分析</p><p><code>ffplay-&gt;vout</code>视频设备</p><p><code>ffplay-&gt;pipeline</code>管道</p><p>这两个东西的创建和作用（因为我自己也还不知道这是干嘛用的，回头再补吧）</p><h3 id="3-4-setDataSource"><a href="#3-4-setDataSource" class="headerlink" title="3.4 _setDataSource()"></a>3.4 _setDataSource()</h3><pre><code class="c">//    ijkmedia/ijkplayer/ijkplayer.cstatic int ijkmp_set_data_source_l(IjkMediaPlayer *mp, const char *url){    assert(mp);    assert(url);    // MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_IDLE);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_INITIALIZED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_ASYNC_PREPARING);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_PREPARED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_STARTED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_PAUSED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_COMPLETED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_STOPPED);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_ERROR);    MPST_RET_IF_EQ(mp-&gt;mp_state, MP_STATE_END);    freep((void**)&amp;mp-&gt;data_source);    //设置Url    mp-&gt;data_source = strdup(url);    if (!mp-&gt;data_source)        return EIJK_OUT_OF_MEMORY;    //改变播放器状态为MP_STATE_INITIALIZED    ijkmp_change_state_l(mp, MP_STATE_INITIALIZED);    return 0;}</code></pre><p> 看一下改变播放器状态的函数：</p><pre><code class="c">//    ijkmedia/ijkplayer/ijkplayer.cvoid ijkmp_change_state_l(IjkMediaPlayer *mp, int new_state){    mp-&gt;mp_state = new_state;      //出现了notify字样，一般这个notify字样的方法，都是表示将某个事件通知外部的监听器    ffp_notify_msg1(mp-&gt;ffplayer, FFP_MSG_PLAYBACK_STATE_CHANGED);}</code></pre><pre><code class="c">//    ijkmedia/ijkplayer/ff_ffmsg_queue.hinline static void msg_queue_put_simple3(MessageQueue *q, int what, int arg1, int arg2){    AVMessage msg;    //初始化一条空的msg    msg_init_msg(&amp;msg);    msg.what = what;    msg.arg1 = arg1;    msg.arg2 = arg2;    //消息入队，这个队列是ffplay-&gt;msg_queue。    msg_queue_put(q, &amp;msg);}</code></pre><pre><code class="c">//    ijkmedia/ijkplayer/ff_ffmsg_queue.hinline static int msg_queue_put(MessageQueue *q, AVMessage *msg){    int ret;    //线程安全保护    SDL_LockMutex(q-&gt;mutex);    ret = msg_queue_put_private(q, msg);    SDL_UnlockMutex(q-&gt;mutex);    return ret;}</code></pre><pre><code class="c">inline static int msg_queue_put_private(MessageQueue *q, AVMessage *msg){    AVMessage *msg1;    if (q-&gt;abort_request)        return -1;#ifdef FFP_MERGE    msg1 = av_malloc(sizeof(AVMessage));#else    msg1 = q-&gt;recycle_msg;    if (msg1) {        q-&gt;recycle_msg = msg1-&gt;next;        q-&gt;recycle_count++;    } else {        q-&gt;alloc_count++;        msg1 = av_malloc(sizeof(AVMessage));    }#ifdef FFP_SHOW_MSG_RECYCLE    int total_count = q-&gt;recycle_count + q-&gt;alloc_count;    if (!(total_count % 10)) {        av_log(NULL, AV_LOG_DEBUG, &quot;msg-recycle \t%d + \t%d = \t%d\n&quot;, q-&gt;recycle_count, q-&gt;alloc_count, total_count);    }#endif#endif    if (!msg1)        return -1;    *msg1 = *msg;    msg1-&gt;next = NULL;    if (!q-&gt;last_msg)        q-&gt;first_msg = msg1;    else        q-&gt;last_msg-&gt;next = msg1;    q-&gt;last_msg = msg1;    q-&gt;nb_messages++;    //唤醒正在等待消息线程msg_thread    SDL_CondSignal(q-&gt;cond);    return 0;}</code></pre><p>notify函数的一系列过程就是类似Android中的Handler生成一个Message对象，然后入队MessageQueue，然后MessageQueue唤醒阻塞的Looper线程。</p><p>而这里发出去的消息是<code>FFP_MSG_PLAYBACK_STATE_CHANGED</code></p><p>全局搜索这个关键字，可以看到，在<code>ijkplayer_jni.c</code>的 <code>static void message_loop_n(JNIEnv **env*, IjkMediaPlayer **mp*)</code>函数中：</p><pre><code class="c"> case FFP_MSG_PLAYBACK_STATE_CHANGED:            break;</code></pre><p>对该事件没有做任何的处理。</p><p>所以，<code>_setDataSource()</code>方法给播放器设置了url，然后也没有做什么额外的工作了，设置进去的url，应该会在后面某个时候（在prepare_async）用于请求网络。</p><h3 id="3-5-setVideoSurface"><a href="#3-5-setVideoSurface" class="headerlink" title="3.5 _setVideoSurface()"></a>3.5 _setVideoSurface()</h3><pre><code class="c">static voidIjkMediaPlayer_setVideoSurface(JNIEnv *env, jobject thiz, jobject jsurface){    MPTRACE(&quot;%s\n&quot;, __func__);    IjkMediaPlayer *mp = jni_get_media_player(env, thiz);    JNI_CHECK_GOTO(mp, env, NULL, &quot;mpjni: setVideoSurface: null mp&quot;, LABEL_RETURN);    ijkmp_android_set_surface(env, mp, jsurface);LABEL_RETURN:    ijkmp_dec_ref_p(&amp;mp);    return;}</code></pre><pre><code class="c">void ijkmp_android_set_surface_l(JNIEnv *env, IjkMediaPlayer *mp, jobject android_surface){    if (!mp || !mp-&gt;ffplayer || !mp-&gt;ffplayer-&gt;vout)        return;    //将Surface与ffplayer-&gt;vout关联    SDL_VoutAndroid_SetAndroidSurface(env, mp-&gt;ffplayer-&gt;vout, android_surface);    //将Surface与ffplayer-&gt;pipeline关联    ffpipeline_set_surface(env, mp-&gt;ffplayer-&gt;pipeline, android_surface);}</code></pre><p>对于ffplayer-&gt;vout和ffplayer-&gt;pipeline的理解还不够，因此无法继续深入地分析了。</p><p>不过可以肯定的是，这是个函数是用于将c层的视频渲染器和java层设置进来的Surface（来自SurfaceView或者TextureView）。</p><p>Width, player.mVideoHeight,<br>                        player.mVideoSarNum, player.mVideoSarDen);<br>                break;</p><pre><code>        default:            DebugLog.e(TAG, &quot;Unknown message type &quot; + msg.what);        }    }}</code></pre><pre><code>到这里，从java到c和从c到java的事件通信和传送大概就是这些了，然而种类面涉及到一些细节例如：线程转换等，并没有去探究，注意,`message_loop()`方法是创建一个消息循环机制，那么回到`message_loop()`函数被使用的地方：``` cstatic voidIjkMediaPlayer_native_setup(JNIEnv *env, jobject thiz, jobject weak_this){    MPTRACE(&quot;%s\n&quot;, __func__);    //创建IjkMediaPlayer，并传入message_loop()方法作为参数    IjkMediaPlayer *mp = ijkmp_android_create(message_loop);    JNI_CHECK_GOTO(mp, env, &quot;java/lang/OutOfMemoryError&quot;, &quot;mpjni: native_setup: ijkmp_create() failed&quot;, LABEL_RETURN);    jni_set_media_player(env, thiz, mp);    ijkmp_set_weak_thiz(mp, (*env)-&gt;NewGlobalRef(env, weak_this));    ijkmp_set_inject_opaque(mp, ijkmp_get_weak_thiz(mp));    ijkmp_set_ijkio_inject_opaque(mp, ijkmp_get_weak_thiz(mp));    ijkmp_android_set_mediacodec_select_callback(mp, mediacodec_select_callback, ijkmp_get_weak_thiz(mp));LABEL_RETURN:    ijkmp_dec_ref_p(&amp;mp);}</code></pre><p><code>message_loop</code>这个函数作为参数被传递，在这里依然还没有调用，即没有开启循环读队列。那么猜想<code>message_loop</code>函数一定是被传递下去，在某个地方被调用了，并且需要在一个独立的线程中调用，就像模拟Android的<code>HandlerThread</code>类做的那样，一个独立的线程中开启了循环。</p><h4 id="3-3-2-创建IjkMediaPlayer-1"><a href="#3-3-2-创建IjkMediaPlayer-1" class="headerlink" title="3.3.2 创建IjkMediaPlayer"></a>3.3.2 创建IjkMediaPlayer</h4><p>依然看到上面的代码块，通过<code>ijkmp_android_create(message_loop)</code>方法创建了<code>IjkMediaPlayer</code>播放器结构体，在看具体创建代码之前，我们先看一下结构体：</p><pre><code class="c">//    ijkmedia/ijkplayer/ijkplayer_internal.hstruct IjkMediaPlayer {    volatile int ref_count;      //互斥锁，用于保证线程安全    pthread_mutex_t mutex;      //ffplayer，位于ijkmedia/ijkplayer/ff_ffplay_def.h，他会直接调用ffmpeg的方法了    FFPlayer *ffplayer;      //一个函数指针，指向的是谁？指向的其实就是刚才创建的message_loop，即消息循环函数    int (*msg_loop)(void*);      //消息机制线程    SDL_Thread *msg_thread;    SDL_Thread _msg_thread;        //播放器状态，例如prepared,resumed,error,completed等    int mp_state;      //字符串，就是一个播放url    char *data_source;      //弱引用    void *weak_thiz;    int restart;    int restart_from_beginning;    int seek_req;    long seek_msec;};</code></pre><p>结构体的说明如注释所示。</p><p>那么现在看创建播放器的函数：</p><pre><code class="c">//    ijkmedia/ijkplayer/android/ijkplayer_android.cIjkMediaPlayer *ijkmp_android_create(int(*msg_loop)(void*)){    //创建IjkMediaPlayer    IjkMediaPlayer *mp = ijkmp_create(msg_loop);    if (!mp)        goto fail;    //创建视频输出设备，会根据根据硬解还是软件，硬解用MediaCodec创建，软解用FFmpeg创建    mp-&gt;ffplayer-&gt;vout = SDL_VoutAndroid_CreateForAndroidSurface();    if (!mp-&gt;ffplayer-&gt;vout)        goto fail;    //暂时不太理解这个叫做”管道“的东西是什么    mp-&gt;ffplayer-&gt;pipeline = ffpipeline_create_from_android(mp-&gt;ffplayer);    if (!mp-&gt;ffplayer-&gt;pipeline)        goto fail;    //将创建的视频输出设备vout，赋值到ffplayer-&gt;pipeline中    ffpipeline_set_vout(mp-&gt;ffplayer-&gt;pipeline, mp-&gt;ffplayer-&gt;vout);    return mp;fail:    ijkmp_dec_ref_p(&amp;mp);    return NULL;}</code></pre><p>那么看到创建<code>IjkMediaPlayer</code>的函数</p><p>``` c<br>//    ijkmedia/ijkplayer/ff_ffplay.c<br>IjkMediaPlayer <em>ijkmp_create(int (*msg_loop)(void</em>))<br>{<br>    //分配内存<br>    IjkMediaPlayer *mp = (IjkMediaPlayer *) mallocz(sizeof(IjkMediaPlayer));<br>    if (!mp)<br>        goto fail;<br>    //创建IjkMediaPlayer内部的FFPlayer<br>    mp-&gt;ffplayer = ffp_create();<br>    if (!mp-&gt;ffplayer)<br>        goto fail;<br>    //注意：将msg_loop函数赋值给IjkMediaPlayer的函数引用，在创建的时候赋值，在另一处被调用。<br>    //在哪里被调用呢？在prepareAsync()里面，后面分析prepare方法的时候就会再见到消息循环函数了。<br>    mp-&gt;msg_loop = msg_loop;</p><pre><code>ijkmp_inc_ref(mp);pthread_mutex_init(&amp;mp-&gt;mutex, NULL);return mp;fail:ijkmp_destroy_p(&amp;mp);return NULL;</code></pre>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JNI创建变量和释放变量</title>
    <link href="/2019/12/29/ndk/JNI%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E5%92%8C%E9%87%8A%E6%94%BE%E5%8F%98%E9%87%8F/"/>
    <url>/2019/12/29/ndk/JNI%E5%88%9B%E5%BB%BA%E5%8F%98%E9%87%8F%E5%92%8C%E9%87%8A%E6%94%BE%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>jni中的数据传递就两种：c层传到java层；java层传到c层。</p><h3 id="1-当数据从java传递到c"><a href="#1-当数据从java传递到c" class="headerlink" title="1 当数据从java传递到c"></a>1 当数据从java传递到c</h3><h4 id="1-1-传递基本数据类型"><a href="#1-1-传递基本数据类型" class="headerlink" title="1.1 传递基本数据类型"></a>1.1 传递基本数据类型</h4><p>在Java层定义jni代码：</p><pre><code class="java">public static native void inputInt(int intData);</code></pre><p>c层实现：</p><pre><code class="c">JNIEXPORT void JNICALLJava_com_hwilliam_jnilearncmake_NDKTools_inputInt(JNIEnv *env, jclass clazz, jint int_data) {    int data = int_data;    LOGD(&quot;input int data from java = %d&quot;, data);}</code></pre><p>由于<code>jint</code>是</p><pre><code class="c">typedef int32_t  jint;     /* signed 32 bits */</code></pre><p>而</p><pre><code class="c">typedef __int32_t     int32_t;</code></pre><p>而</p><pre><code class="c">typedef int __int32_t;</code></pre><p>所以，<code>jint</code>就是<code>int</code>类型，所以直接用<code>int</code>类型接收就可以了。</p><p>其他的基本数据类型都是这样的，他们的映射关系定义在：</p><pre><code class="c">//    jni.h/* Primitive types that match up with Java equivalents. */typedef uint8_t  jboolean; /* unsigned 8 bits */typedef int8_t   jbyte;    /* signed 8 bits */typedef uint16_t jchar;    /* unsigned 16 bits */typedef int16_t  jshort;   /* signed 16 bits */typedef int32_t  jint;     /* signed 32 bits */typedef int64_t  jlong;    /* signed 64 bits */typedef float    jfloat;   /* 32-bit IEEE 754 */typedef double   jdouble;  /* 64-bit IEEE 754 */</code></pre><h4 id="1-2-传递引用数据类型"><a href="#1-2-传递引用数据类型" class="headerlink" title="1.2 传递引用数据类型"></a>1.2 传递引用数据类型</h4><p>在java层定义jni方法：</p><pre><code class="java">public static native void inputString(String stringData);</code></pre><p>在c层定义实现：</p><pre><code class="c">JNIEXPORT void JNICALLJava_com_hwilliam_jnilearncmake_NDKTools_inputString(JNIEnv *env, jclass clazz,                                                     jstring string_data) {    //获取java中的string_data，转换成c中的字符串    const char *string = (*env)-&gt;GetStringUTFChars(env, string_data, NULL);    LOGD(&quot;input string data from java = %s&quot;, string);    //释放java中的string_data的引用。    (*env)-&gt;ReleaseStringUTFChars(env, string_data, string);}</code></pre><h4 id="1-3-必要的释放"><a href="#1-3-必要的释放" class="headerlink" title="1.3 必要的释放"></a>1.3 必要的释放</h4><p>注意，从java传递基本数据类型的时候，是不需要释放引用的，因为基本数据类型在java层并不会导致内存泄漏。而对象的引用，才会导致内存泄漏。</p><p>当从java层传递一个引用数据类型（即一个java对象）到c层的时候，这个时候会把该对象的引用暴露给c层，让c层处理，即调用相应的<code>GetXXX</code>方法，例如传递<code>String</code>对象的时候，c层要调用<code>jni</code>函数来处理：<code>(*env)-&gt;GetStringUTFChars</code>，那么当处理完之后，必须手动释放调用c层对java层的该对象的引用，即调用对应的<code>(*env)-&gt;ReleaseXXX</code>函数。</p><p>即从java传递对象到c的时候，<code>(*env)-&gt;GetXXX</code>和<code>(*env)-&gt;ReleaseXXX</code>必须是成对出现的，否则就会造成内存泄漏。</p><h3 id="2-当数据从c传递到java"><a href="#2-当数据从c传递到java" class="headerlink" title="2 当数据从c传递到java"></a>2 当数据从c传递到java</h3><p>从c层传递数据到java层一般涉及到两种方式：</p><ol><li>java通过有返回值得jni方法调用进入到c层，然后通过该jni方法的返回值，c层返回数据到java层。数据是以同步调用的形式返回返回给java层的。</li><li>从c层主动调用java层的静态方法或者实例方法，以异步回调的方式将数据返回给java层。</li></ol><h4 id="2-1-传递基本数据类型"><a href="#2-1-传递基本数据类型" class="headerlink" title="2.1 传递基本数据类型"></a>2.1 传递基本数据类型</h4><h5 id="同步返回"><a href="#同步返回" class="headerlink" title="同步返回"></a>同步返回</h5><p>java定义Jni方法</p><pre><code class="java">public static native int getIntFromCSync();</code></pre><p>c层实现</p><pre><code class="c">JNIEXPORT jint JNICALLJava_com_hwilliam_jnilearncmake_NDKTools_getIntFromCSync(JNIEnv *env, jclass clazz) {    int data = 100;    jint data2Java = data;    return data2Java;}</code></pre><p>因为<code>jint</code>其实就是<code>int</code>型，所以可以直接用int来接收，并直接返回给Java。</p><h5 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h5><p>Java层：定义一个jni方法，用于发起异步回调，然后定义一个java层的回调方法，这里的回调的参数是基本类型int。</p><pre><code class="java">public static native void getIntFromCAsync();public static void onGetIntFromC(int dataFromC) {  LogUtils.d(dataFromC);}</code></pre><p>c层：实现jni方法，并通过<code>CallXXXMethod()</code>方法来回调java层的方法。</p><pre><code class="c">JNIEXPORT void JNICALLJava_com_hwilliam_jnilearncmake_NDKTools_getIntFromCAsync(JNIEnv *env, jclass clazz) {    jint data2Java = 200;    jmethodID onGetIntFromC = (*env)-&gt;GetStaticMethodID(env, clazz, &quot;onGetIntFromC&quot;, &quot;(I)V&quot;);    (*env)-&gt;CallStaticVoidMethod(env, clazz, onGetIntFromC, data2Java);}</code></pre><h4 id="2-2-传递引用数据类型"><a href="#2-2-传递引用数据类型" class="headerlink" title="2.2 传递引用数据类型"></a>2.2 传递引用数据类型</h4><h5 id="同步返回-1"><a href="#同步返回-1" class="headerlink" title="同步返回"></a>同步返回</h5><pre><code class="java">public static native String getStringFromCSync();</code></pre><pre><code class="c">JNIEXPORT jstring JNICALLJava_com_hwilliam_jnilearncmake_NDKTools_getStringFromCSync(JNIEnv *env, jclass clazz) {    char *string = &quot;abcdefg&quot;;    jstring result = (*env)-&gt;NewStringUTF(env, string);    return result;}</code></pre><h5 id="异步回调-1"><a href="#异步回调-1" class="headerlink" title="异步回调"></a>异步回调</h5><pre><code class="java">public static native void getStringFromCAsync();public static void onGetStringFromC(String dataFromC) {    LogUtils.d(dataFromC);}</code></pre><pre><code class="c">JNIEXPORT void JNICALLJava_com_hwilliam_jnilearncmake_NDKTools_getStringFromCAsync(JNIEnv *env, jclass clazz) {    //获取字符串    char *string = &quot;123456789&quot;;    jstring result = (*env)-&gt;NewStringUTF(env, string);    //获取要回调的java方法    jmethodID onGetStringFromC = (*env)-&gt;GetStaticMethodID(env, clazz, &quot;onGetStringFromC&quot;,&quot;(Ljava/lang/String;)V&quot;);    //回调    (*env)-&gt;CallStaticVoidMethod(env, clazz, onGetStringFromC, result);    //release    (*env)-&gt;DeleteLocalRef(env, result);}</code></pre><p>此外，当想要查找java方法对应的方法签名的时候，androidStudio可以很方便地用代码提示地方式自动生成方法签名：在方法签名参数位置先填上””，然后光标放过去，并按住alt+enter，就出现了提示：</p><p><img src="https://s1.ax1x.com/2020/06/01/t8V35j.png" srcset="/img/loading.gif" alt="t8V35j.png"></p><h4 id="2-3-必要的释放"><a href="#2-3-必要的释放" class="headerlink" title="2.3 必要的释放"></a>2.3 必要的释放</h4><p>这里用到了释放函数：<code>(*env)-&gt;DeleteLocalRef(env, jobject);</code>，该函数是用来释放在c层创建的java对象的局部引用。什么时候该使用这个函数来释放在c层创建的<code>jobject</code>对象呢？异步回调形式的<code>jni</code>函数。</p><p>那么为什么同步返回的<code>jni</code>函数不需要呢？</p><p>实际上，在c层调用jni函数<code>NewXXX()</code>函数来创建一个对象的时候，会把这个对象放入到当前<code>jni</code>函数特有的一段内存区域中，称为<strong>本地引用根的集合</strong>，每当在c层调用<code>NewXXX()</code>函数创建java对象的时候，都会把创建好的对象的引用保存一份在这个<strong>本地引用根的集合</strong>中。</p><blockquote><p>我认为这么做的原因是防止JVM在GC的时候把这个对象给干掉了，因为这个对象这个时候还在c层，没有返回给Java层，即java层是没有任何引用指向这个对象的。这种机制是为了保护这个在c层创建的java对象。</p></blockquote><p>而当从当前的<code>jni</code>函数返回的时候（或者在c层创建的一个附着到JVM的线程结束了，即从JVM脱离了），就会把这个<strong>本地引用根的集合</strong>释放掉，返回到Java层的那些对象就可以接着被java层去引用，去处理，而没有返回java层的对象，在这个时候已经是GC unreachable了，就会被干掉了。</p><p>但是！！！，一个<code>jin</code>方法可能并没有那么简单的逻辑，就创建两个对象就返回给Java了，很多时候，<code>jni</code>方法进入到c层之后，会在c层开启新的线程，而新的线程中又会去通过<code>NewXXX()</code>函数创建其他的java对象，并在c层主动发起回调，将该对象和其他可能的数据传到java层。这个时候，线程中创建的所有的java对象只有在线程结束的时候才会释放掉<strong>本地引用根的集合</strong>，如果不手动释放，那么这些对象在返回到java层之后，使用之后，c层也不会再去使用，就造成了内存泄漏了。</p><p>因此，最好的方法就是：在调用<code>NewXXX()</code>创建了Java对象之后，除非这个对象马上通过当前的jni函数返回到java（c层主动回调java函数的不算，必须是当前jni方法），否则使用完之后要调用<code>(*env)-&gt;DeleteLocalRef(env, jobject);</code>来释放这个引用。</p><hr><p>参考：<a href="https://www.ibm.com/support/knowledgecenter/SSYKE2_7.0.0/com.ibm.java.aix.70.doc/diag/understanding/jni_gc.html" target="_blank" rel="noopener">https://www.ibm.com/support/knowledgecenter/SSYKE2_7.0.0/com.ibm.java.aix.70.doc/diag/understanding/jni_gc.html</a></p><p>我自己对这个参考文档做了一些翻译：</p><h3 id="翻译参考文献："><a href="#翻译参考文献：" class="headerlink" title="翻译参考文献："></a>翻译参考文献：</h3><h4 id="JNI对象引用概览"><a href="#JNI对象引用概览" class="headerlink" title="JNI对象引用概览"></a>JNI对象引用概览</h4><p>关于GC如何找到JNI对象的引用的实现细节并没有在JNI文档中说明。但是，JNI文档的确指明了JNI对象所需要的一些可靠和可预见的表现。</p><h4 id="本地和全局引用"><a href="#本地和全局引用" class="headerlink" title="本地和全局引用"></a>本地和全局引用</h4><p>本地引用被限制在创建他们的栈和线程中，并且在创建他们的栈帧返回的时候就会被自动删除。</p><p>全局引用允许原生代码去将一个本地引用升级成一种可以被任何附着到JVM的线程访问的全局引用。</p><h4 id="全局引用和内存泄漏"><a href="#全局引用和内存泄漏" class="headerlink" title="全局引用和内存泄漏"></a>全局引用和内存泄漏</h4><p>全局引用不会自动被删除，所以开发者必须处理他们的内存管理。每一个全局引用都建立了一个GC root，并且让他的整个GCtree都可到达。因此，每一个被创建的GCroot必须被手动释放以防止内存泄漏。</p><p>内存泄漏最终导致OOM，这些错误很难处理，尤其是你没有实现JNI异常处理。</p><p>为了解决内存泄漏的问题，JNI提供了两个方法：</p><ul><li>NewWeakGlobalRef</li><li>DeleteWeakGlobalRef</li></ul><p>这些方法能用弱引用的方式来避免内存泄漏。</p><h4 id="本地引用和内存泄漏"><a href="#本地引用和内存泄漏" class="headerlink" title="本地引用和内存泄漏"></a>本地引用和内存泄漏</h4><p>在大多数情况下，GC对那些不在栈帧范围中的本地引用的自动的垃圾回收已经足够适用。这种自动GC回收会在原生线程(或原生方法)返回到java或者从JVM中脱离的时候发生。但是，如果不满足这种条件的时候，就可能会发生本地引用的内存泄漏。例如：当原生方法并没有返回到java或者一个线程创建了本地引用但是却并没有从JVM中脱离。</p><p>考虑以下代码的情况，原生代码在一个循环中不断地创建新的本地引用：</p><pre><code class="c">while ( &lt;condition&gt; ){   jobject myObj = (*env)-&gt;NewObject( env, clz, mid, NULL );   if ( NULL != myObj )   {      /* we know myObj is a valid local ref, so use it */      jclass myClazz = (*env)-&gt;GetObjectClass(env, myObj);      /* uses of myObj and myClazz, etc. but no new local refs */      /* Without the following calls, we would leak */      (*env)-&gt;DeleteLocalRef( env, myObj );       (*env)-&gt;DeleteLocalRef( env, myClazz );   }} /* end while */</code></pre><p>尽管<code>myObj</code>和<code>myClazz</code>变量在循环中每次都指向了新的对象，但是，用这些jni方法创建的每一个新的对象都在<strong>本地引用根的集合</strong>中被引用了。</p><p>这些引用必须被手动地移除，使用<code>DeleteLocalRef</code>方法。如果不调用这个方法，这些本地引用会一直保持着泄漏，直到这个方法返回到java或者线程从jvm中脱离。</p><h4 id="JNI弱全局引用"><a href="#JNI弱全局引用" class="headerlink" title="JNI弱全局引用"></a>JNI弱全局引用</h4><p>弱全局引用是一种特殊的全局引用。他们可以在任何线程中被使用，并且可以在jni方法之间被调用，并且不会作为GC root。GC会在任何时候将一个没有强引用的对象回收掉。</p><p>你必须小心地使用弱全局引用。如果该若全局引用被垃圾回收了，那么这个引用就指向了null，一个null引用只能被少部分JNI函数调用。去检查一个弱全局引用是否已经别回收掉了，使用<code>IsSameObject()</code>来和NULL对比。</p><p>大多数JNI函数对弱全局引用的调用都是不安全的，即使你测试过这个弱引用是非空的。因为这个弱全局引用可能在检测过后或者在你调用过程中又被回收了。你应该在使用弱全局引用之前，将他升级成一个强引用。例如使用：<code>NewLocalRef</code>或者<code>NewGlobalRef</code></p><p>弱全局引用的使用必须要调用<code>DeleteWeakGlobalRef</code>来释放。否则会导致缓慢的GC，最终还是会导致OOM。</p><h4 id="JNI引用管理"><a href="#JNI引用管理" class="headerlink" title="JNI引用管理"></a>JNI引用管理</h4><p>There are a set of platform-independent rules for JNI reference management</p><p>These rules are:</p><ol><li>JNI references are valid only in threads attached to a JVM.</li><li>A valid JNI local reference in native code must be obtained:<ol><li>As a parameter to the native code</li><li>As the return value from calling a JNI function</li></ol></li><li>A valid JNI global reference must be obtained from another valid JNI reference (global or local) by calling NewGlobalRef or NewWeakGlobalRef.</li><li>The null value reference is always valid, and can be used in place of any JNI reference (global or local).</li><li>JNI local references are valid only in the thread that creates them and remain valid only while their creating frame remains on the stack.</li></ol><h5 id="1-N2J转换"><a href="#1-N2J转换" class="headerlink" title="1 N2J转换"></a>1 N2J转换</h5><p>当原生代码在一个线程中调用java代码时，这个线程必须先附着到当前进程的JVM上。</p><p>每一个传递了对象应用的N2J（native to java）调用必须要通过jni方法获取有效的jobject对象才能传递到java，因此他们需要是有效的本地或者全局jni引用。任何从N2J方法返回的引用都是JNI本地引用。</p><h5 id="2-J2N调用"><a href="#2-J2N调用" class="headerlink" title="2 J2N调用"></a>2 J2N调用</h5><p>JVM必须确保任何从java到native传递的对象和在native中创建的新的java对象都是GC可到达的（否则在下一次GC的时候就对象就被回收了）。要满足这个GC的要求，JVM分配了一块小段特殊的内存称为：<strong>本地引用根的集合</strong>。</p><p><strong>本地引用根的集合</strong>在以下情况会被创建：</p><ul><li>一个线程被附着到JVM上时。</li><li>每一个J2N转换发生。（即对象从java传到c层，要防止这个对象被JVM意外回收，因此要放在<strong>本地引用根的集合</strong>）</li></ul><p>在原生代码中创建的新的对象都会被添加到这个J2N根集合中，除非你用<code>PushLocalFrame</code>JNI方法来创建一个新的本地栈。</p><p>默认的<strong>本地引用根的集合</strong>是足够大的，能够在每个J2N调用中容纳16个本地引用。</p><h5 id="3-J2N返回"><a href="#3-J2N返回" class="headerlink" title="3 J2N返回"></a>3 J2N返回</h5><p>当从原生方法返回到java时，对应的JNI本地引用，即由这次J2N方法创建的<strong>本地引用根的集合</strong>会被自动释放。</p><p>如果JNI本地引用是某个对象的唯一的引用，那么这个对象在从J2N方法返回的时候就不再GC可到达并且会自动触发他的垃圾回收。这种机制简化了JNI开发者的内存管理。</p>]]></content>
    
    
    <categories>
      
      <category>ndk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>理解ijkplayer（二）项目结构分析</title>
    <link href="/2019/11/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E4%BA%8C%EF%BC%89%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <url>/2019/11/30/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E4%BA%8C%EF%BC%89%E9%A1%B9%E7%9B%AE%E7%BB%93%E6%9E%84%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p><p>我是一名打算走音视频路线的android开发者。以此系列文章开始，记录我的音视频开发学习之路</p><p>ijkplayer系列文章目录：<br><a href="https://www.jianshu.com/writer#/notebooks/40971763/notes/56760993/preview" target="_blank" rel="noopener">理解ijkplayer（一）：开始</a></p><p><a href="https://www.jianshu.com/p/b5a2584e03f1" target="_blank" rel="noopener">理解ijkplayer（二）项目结构分析</a></p><p><a href="https://www.jianshu.com/p/0501be9cf4bf" target="_blank" rel="noopener">理解ijkplayer（三）从Java层开始初始化</a></p><p><a href="https://www.jianshu.com/p/f633da0db4dd" target="_blank" rel="noopener">理解ijkplayer（四）拉流</a></p><p><a href="https://www.jianshu.com/p/1e10507f18b6" target="_blank" rel="noopener">理解ijkplayer（五）解码、播放</a></p></blockquote><hr><h3 id="1-整体结构"><a href="#1-整体结构" class="headerlink" title="1. 整体结构"></a>1. 整体结构</h3><pre><code class="shell">.├── android/   #android项目的demo和so库的输出路径├── config/├── doc/├── extra/        #ijkplayer依赖的第三方库的源码,例如ffmpeg├── ijkmedia/ #ijkplayer源码├── ijkprof/├── ios/├── tools/├── COPYING.GPLv2├── COPYING.GPLv3├── COPYING.LGPLv2.1├── COPYING.LGPLv2.1.txt -&gt; COPYING.LGPLv2.1├── COPYING.LGPLv3├── MODULE_LICENSE_APACHE2├── NEWS.md├── NOTICE├── README.md├── compile-android-j4a.sh*├── init-android-exo.sh*├── init-android-j4a.sh*├── init-android-libsoxr.sh*├── init-android-libyuv.sh*├── init-android-openssl.sh*├── init-android-prof.sh*├── init-android-soundtouch.sh*├── init-android.sh*├── init-config.sh*├── init-ios-openssl.sh*├── init-ios.sh*└── version.sh*</code></pre><p>看源码只需要重点关注<code>/ijkmedia</code>和<code>extra/</code></p><h3 id="2-入口：ijkplayer-jni-c"><a href="#2-入口：ijkplayer-jni-c" class="headerlink" title="2. 入口：ijkplayer_jni.c"></a>2. 入口：ijkplayer_jni.c</h3><p><code>ijkmedia/ijkplayer/android/ijkplayer_jni.c</code></p><p>这是android的入口文件，用动态加载的方式声明了jni方法：</p><pre><code class="c">JNIEXPORT jint JNI_OnLoad(JavaVM *vm, void *reserved){  //.}</code></pre><p>在<code>g_methods</code>数组中动态注册了jni方法。</p><pre><code class="c">static JNINativeMethod g_methods[] = {    {        &quot;_setDataSource&quot;,        &quot;(Ljava/lang/String;[Ljava/lang/String;[Ljava/lang/String;)V&quot;,        (void *) IjkMediaPlayer_setDataSourceAndHeaders    },    { &quot;_setDataSourceFd&quot;,       &quot;(I)V&quot;,     (void *) IjkMediaPlayer_setDataSourceFd },    { &quot;_setDataSource&quot;,         &quot;(Ltv/danmaku/ijk/media/player/misc/IMediaDataSource;)V&quot;, (void *)IjkMediaPlayer_setDataSourceCallback },    { &quot;_setAndroidIOCallback&quot;,  &quot;(Ltv/danmaku/ijk/media/player/misc/IAndroidIO;)V&quot;, (void *)IjkMediaPlayer_setAndroidIOCallback },    { &quot;_setVideoSurface&quot;,       &quot;(Landroid/view/Surface;)V&quot;, (void *) IjkMediaPlayer_setVideoSurface },    { &quot;_prepareAsync&quot;,          &quot;()V&quot;,      (void *) IjkMediaPlayer_prepareAsync },    { &quot;_start&quot;,                 &quot;()V&quot;,      (void *) IjkMediaPlayer_start },    { &quot;_stop&quot;,                  &quot;()V&quot;,      (void *) IjkMediaPlayer_stop },    { &quot;seekTo&quot;,                 &quot;(J)V&quot;,     (void *) IjkMediaPlayer_seekTo },    { &quot;_pause&quot;,                 &quot;()V&quot;,      (void *) IjkMediaPlayer_pause },    { &quot;isPlaying&quot;,              &quot;()Z&quot;,      (void *) IjkMediaPlayer_isPlaying },    { &quot;getCurrentPosition&quot;,     &quot;()J&quot;,      (void *) IjkMediaPlayer_getCurrentPosition },    { &quot;getDuration&quot;,            &quot;()J&quot;,      (void *) IjkMediaPlayer_getDuration },    { &quot;_release&quot;,               &quot;()V&quot;,      (void *) IjkMediaPlayer_release },    { &quot;_reset&quot;,                 &quot;()V&quot;,      (void *) IjkMediaPlayer_reset },    { &quot;setVolume&quot;,              &quot;(FF)V&quot;,    (void *) IjkMediaPlayer_setVolume },    { &quot;getAudioSessionId&quot;,      &quot;()I&quot;,      (void *) IjkMediaPlayer_getAudioSessionId },    { &quot;native_init&quot;,            &quot;()V&quot;,      (void *) IjkMediaPlayer_native_init },    { &quot;native_setup&quot;,           &quot;(Ljava/lang/Object;)V&quot;, (void *) IjkMediaPlayer_native_setup },    { &quot;native_finalize&quot;,        &quot;()V&quot;,      (void *) IjkMediaPlayer_native_finalize },    { &quot;_setOption&quot;,             &quot;(ILjava/lang/String;Ljava/lang/String;)V&quot;, (void *) IjkMediaPlayer_setOption },    { &quot;_setOption&quot;,             &quot;(ILjava/lang/String;J)V&quot;,                  (void *) IjkMediaPlayer_setOptionLong },    { &quot;_getColorFormatName&quot;,    &quot;(I)Ljava/lang/String;&quot;,    (void *) IjkMediaPlayer_getColorFormatName },    { &quot;_getVideoCodecInfo&quot;,     &quot;()Ljava/lang/String;&quot;,     (void *) IjkMediaPlayer_getVideoCodecInfo },    { &quot;_getAudioCodecInfo&quot;,     &quot;()Ljava/lang/String;&quot;,     (void *) IjkMediaPlayer_getAudioCodecInfo },    { &quot;_getMediaMeta&quot;,          &quot;()Landroid/os/Bundle;&quot;,    (void *) IjkMediaPlayer_getMediaMeta },    { &quot;_setLoopCount&quot;,          &quot;(I)V&quot;,                     (void *) IjkMediaPlayer_setLoopCount },    { &quot;_getLoopCount&quot;,          &quot;()I&quot;,                      (void *) IjkMediaPlayer_getLoopCount },    { &quot;_getPropertyFloat&quot;,      &quot;(IF)F&quot;,                    (void *) ijkMediaPlayer_getPropertyFloat },    { &quot;_setPropertyFloat&quot;,      &quot;(IF)V&quot;,                    (void *) ijkMediaPlayer_setPropertyFloat },    { &quot;_getPropertyLong&quot;,       &quot;(IJ)J&quot;,                    (void *) ijkMediaPlayer_getPropertyLong },    { &quot;_setPropertyLong&quot;,       &quot;(IJ)V&quot;,                    (void *) ijkMediaPlayer_setPropertyLong },    { &quot;_setStreamSelected&quot;,     &quot;(IZ)V&quot;,                    (void *) ijkMediaPlayer_setStreamSelected },    { &quot;native_profileBegin&quot;,    &quot;(Ljava/lang/String;)V&quot;,    (void *) IjkMediaPlayer_native_profileBegin },    { &quot;native_profileEnd&quot;,      &quot;()V&quot;,                      (void *) IjkMediaPlayer_native_profileEnd },    { &quot;native_setLogLevel&quot;,     &quot;(I)V&quot;,                     (void *) IjkMediaPlayer_native_setLogLevel },    { &quot;_setFrameAtTime&quot;,        &quot;(Ljava/lang/String;JJII)V&quot;, (void *) IjkMediaPlayer_setFrameAtTime },};</code></pre><p>我们可以看到规则，每当java层调用jni方法例如：</p><table><thead><tr><th>java调用的jni方法</th><th>对应Ijkplayer内部的方法</th></tr></thead><tbody><tr><td>_setDataSource</td><td>IjkMediaPlayer_setDataSourceAndHeaders</td></tr><tr><td>_start</td><td>IjkMediaPlayer_start</td></tr></tbody></table><p>即Java层调用的<code>XXX</code>方法，对应在ijkplayer的c层是<code>IjkMediaPlayer_XXX</code>。</p><p>而<code>IjkMediaPlayer_XXX</code>方法全部生命在<code>ijkplayer_jni.c</code>文件中，也难怪后者有1200多行了。</p><h3 id="3-中转-调度：ijkplayer-c"><a href="#3-中转-调度：ijkplayer-c" class="headerlink" title="3. 中转,调度：ijkplayer.c"></a>3. 中转,调度：ijkplayer.c</h3><p>ijkmedia/ijkplayer/ijkplayer.c</p><p>我们拿一个jni方法来看下：</p><pre><code class="c">//ijkplayer_jni.cstatic voidIjkMediaPlayer_start(JNIEnv *env, jobject thiz){    MPTRACE(&quot;%s\n&quot;, __func__);      //获取IjkMediaPlayer对象（是个结构体，但是就是一个对象）    IjkMediaPlayer *mp = jni_get_media_player(env, thiz);    JNI_CHECK_GOTO(mp, env, &quot;java/lang/IllegalStateException&quot;, &quot;mpjni: start: null mp&quot;, LABEL_RETURN);        //跳转到了ijkplayer.c的函数了    ijkmp_start(mp);LABEL_RETURN:    ijkmp_dec_ref_p(&amp;mp);}</code></pre><p>Ijkplayer_jin.c的每一个Jni映射方法几乎都是这样，拿到一个IjkMediaPlayer对象，然后跳转到ijkplayer.c中的函数。</p><p>注意:Ijkplayer_jin.c是通过</p><pre><code class="c">#include &quot;ijkplayer_android.h&quot;</code></pre><p>而<code>ijkplayer_android.h</code>中，又</p><pre><code class="c">#include &quot;../ijkplayer.h&quot;</code></pre><p>所以，具备了调用ijkpalyer.h的能力的，而<code>ijkplayer.h</code>的实现是<code>ijkplayer.c</code>因此主要看后者就行了。</p><p>而在这一层映射中，函数命名也有对应关系：</p><table><thead><tr><th>ijkplayer_jin.c</th><th>ijkplayer.h / ijkpalyer.c</th></tr></thead><tbody><tr><td>IjkMediaPlayer_prepareAsync</td><td>ijkmp_prepare_async</td></tr><tr><td>IjkMediaPlayer_start</td><td>ijkmp_start</td></tr></tbody></table><h3 id="4-封装：ff-ffplay-c"><a href="#4-封装：ff-ffplay-c" class="headerlink" title="4. 封装：ff_ffplay.c"></a>4. 封装：ff_ffplay.c</h3><p>ijkplayer.c中的代码会调用到ff_ffplay.c中的代码，以及类似的ff_ffxxx.c中的代码：</p><p>即以ff开头的文件中的函数：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-b8c20a665cd7c027.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p></p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android的PopupWindow无法收到KeyEvent-KEYCODE_BACK的原因-md</title>
    <link href="/2019/11/26/View/android%E7%9A%84PopupWindow%E6%97%A0%E6%B3%95%E6%94%B6%E5%88%B0KeyEvent-KEYCODE_BACK%E7%9A%84%E5%8E%9F%E5%9B%A0-md/"/>
    <url>/2019/11/26/View/android%E7%9A%84PopupWindow%E6%97%A0%E6%B3%95%E6%94%B6%E5%88%B0KeyEvent-KEYCODE_BACK%E7%9A%84%E5%8E%9F%E5%9B%A0-md/</url>
    
    <content type="html"><![CDATA[<p>PopupWindow无法收到<code>KeyEvent.KEYCODE_BACK</code>的原因：</p><p>在创建的顶层<code>PopupDecorView</code>的<code>dispatchKeyEvent()</code>回调中，把该事件拦截了。</p><h3 id="1-PopupDecorView创建PopupDecorView"><a href="#1-PopupDecorView创建PopupDecorView" class="headerlink" title="1. PopupDecorView创建PopupDecorView"></a>1. PopupDecorView创建PopupDecorView</h3><p>代码：</p><pre><code class="java">//PopupWindow#showAtLocation()public void showAtLocation(IBinder token, int gravity, int x, int y) {    if (isShowing() || mContentView == null) {        return;    }    TransitionManager.endTransitions(mDecorView);    detachFromAnchor();    mIsShowing = true;    mIsDropdown = false;    mGravity = gravity;    final WindowManager.LayoutParams p = createPopupLayoutParams(token);      //创建顶层PopupDecorView    preparePopup(p);    p.x = x;    p.y = y;      //加入到WindowManger显示出来    invokePopup(p);}</code></pre><pre><code class="java">private void preparePopup(WindowManager.LayoutParams p) {    if (mContentView == null || mContext == null || mWindowManager == null) {        throw new IllegalStateException(&quot;You must specify a valid content view by &quot;                + &quot;calling setContentView() before attempting to show the popup.&quot;);    }    if (p.accessibilityTitle == null) {        p.accessibilityTitle = mContext.getString(R.string.popup_window_default_title);    }    // The old decor view may be transitioning out. Make sure it finishes    // and cleans up before we try to create another one.    if (mDecorView != null) {        mDecorView.cancelTransitions();    }    // When a background is available, we embed the content view within    // another view that owns the background drawable.    if (mBackground != null) {          //如果background不为空，把ContentView外封一层View，并给外封的View设置backgroud。        mBackgroundView = createBackgroundView(mContentView);        mBackgroundView.setBackground(mBackground);    } else {        mBackgroundView = mContentView;    }      //创建PopupDecorView    mDecorView = createDecorView(mBackgroundView);    // The background owner should be elevated so that it casts a shadow.    mBackgroundView.setElevation(mElevation);    // We may wrap that in another view, so we&#39;ll need to manually specify    // the surface insets.    p.setSurfaceInsets(mBackgroundView, true /*manual*/, true /*preservePrevious*/);    mPopupViewInitialLayoutDirectionInherited =            (mContentView.getRawLayoutDirection() == View.LAYOUT_DIRECTION_INHERIT);}</code></pre><pre><code class="java">private PopupDecorView createDecorView(View contentView) {    final ViewGroup.LayoutParams layoutParams = mContentView.getLayoutParams();    final int height;    if (layoutParams != null &amp;&amp; layoutParams.height == WRAP_CONTENT) {        height = WRAP_CONTENT;    } else {        height = MATCH_PARENT;    }    final PopupDecorView decorView = new PopupDecorView(mContext);      //加入我们设置的ContentView    decorView.addView(contentView, MATCH_PARENT, height);    decorView.setClipChildren(false);    decorView.setClipToPadding(false);    return decorView;}</code></pre><h3 id="2-PopupDecorView-dispatchKeyEvent"><a href="#2-PopupDecorView-dispatchKeyEvent" class="headerlink" title="2. PopupDecorView#dispatchKeyEvent"></a>2. PopupDecorView#dispatchKeyEvent</h3><p>看下PopupDecorView:</p><pre><code class="java">private class PopupDecorView extends FrameLayout{    @Overridepublic boolean dispatchKeyEvent(KeyEvent event) {      //...    if (event.getKeyCode() == KeyEvent.KEYCODE_BACK) {        if (getKeyDispatcherState() == null) {            return super.dispatchKeyEvent(event);        }        if (event.getAction() == KeyEvent.ACTION_DOWN &amp;&amp; event.getRepeatCount() == 0) {            final KeyEvent.DispatcherState state = getKeyDispatcherState();            if (state != null) {                state.startTracking(event, this);            }              //返回true            return true;        } else if (event.getAction() == KeyEvent.ACTION_UP) {            final KeyEvent.DispatcherState state = getKeyDispatcherState();            if (state != null &amp;&amp; state.isTracking(event) &amp;&amp; !event.isCanceled()) {                dismiss();                  //返回true                return true;            }        }        return super.dispatchKeyEvent(event);    } else {        return super.dispatchKeyEvent(event);    }    }  //...}</code></pre><p>可以看到，<code>PopupDecorView</code>本身并没有预留接口来给开发者去接管<code>KEYCODE_BACK</code>事件，遇到这个事件他一定会自己处理掉，所以你只能通过<code>OnDismissListener</code>接口和额外的flag变量来实现监控用户在PopupWindow上按下返回按钮。<br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>理解ijkplayer（一）：开始</title>
    <link href="/2019/11/23/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BC%80%E5%A7%8B/"/>
    <url>/2019/11/23/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/%E7%90%86%E8%A7%A3ijkplayer%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E5%BC%80%E5%A7%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>前言</p><p>我是一名打算走音视频路线的android开发者。以此系列文章开始，记录我的音视频开发学习之路</p><p>ijkplayer系列文章目录：<br><a href="https://www.jianshu.com/writer#/notebooks/40971763/notes/56760993/preview" target="_blank" rel="noopener">理解ijkplayer（一）：开始</a></p><p><a href="https://www.jianshu.com/p/b5a2584e03f1" target="_blank" rel="noopener">理解ijkplayer（二）项目结构分析</a></p><p><a href="https://www.jianshu.com/p/0501be9cf4bf" target="_blank" rel="noopener">理解ijkplayer（三）从Java层开始初始化</a></p><p><a href="https://www.jianshu.com/p/f633da0db4dd" target="_blank" rel="noopener">理解ijkplayer（四）拉流</a></p><p><a href="https://www.jianshu.com/p/1e10507f18b6" target="_blank" rel="noopener">理解ijkplayer（五）解码、播放</a></p></blockquote><hr><p>Ijkplayer源码：</p><p><a href="https://github.com/bilibili/ijkplayer" target="_blank" rel="noopener">https://github.com/bilibili/ijkplayer</a></p><p>学习ijkplayer需要掌握的技能：</p><ol><li>简单的c语言基础</li><li>android开发基础和java jni基础</li><li>linux或mac开发环境（windows环境下的cygwin连第一个ijkplayer的脚本都无法执行。）</li></ol><h3 id="1-开始"><a href="#1-开始" class="headerlink" title="1. 开始"></a>1. 开始</h3><p>按照ijkplayer的readme，将ijkplayer完整的编译并构建so库，理论上是没有问题的。但是我实际执行上还是遇到了一些问题，记录如下：</p><ol><li><p>sdk和ndk的环境变量配置：</p><p>可参考<a href="https://www.jianshu.com/p/c3561bb27f43" target="_blank" rel="noopener">mac开发环境配置</a>中的第5点</p></li><li><p>克隆ffmpeg太慢</p><p>在执行第一个脚本<code>./init-android.sh</code>的时候，会去克隆bilibili团队改造的 ffmpeg项目，但是因为某种已知的原因，克隆非常缓慢，解决方式是：将bilibili的ffmpeg项目导入到国内的git仓库，例如码云，然后修改脚本上的url地址指向码云的仓库，就能克隆下来了。</p><p>例如：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-cbd9d33614ef4318.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>如何将github仓库导入到码云上网一搜就知道了。</p></li><li><p>此时可以按照官网的教程执行<code>./init-android.sh</code>。执行完后，ffmpeg就拉下来了。</p></li></ol><h3 id="2-编译各个架构的so库"><a href="#2-编译各个架构的so库" class="headerlink" title="2. 编译各个架构的so库"></a>2. 编译各个架构的so库</h3><pre><code class="shell">cd android/contrib./compile-ffmpeg.sh clean./compile-ffmpeg.sh allcd .../compile-ijk.sh all</code></pre><p>按照上述的命令是编译所有架构的ffmpeg库并以之编译Ijkplayer的所有的so库。</p><p>那么如果要编译特定的架构，例如只要armv7a和arm64架构，则：</p><pre><code class="shell">./compile-ffmpeg.sh hUsage:  compile-ffmpeg.sh armv5|armv7a|arm64|x86|x86_64  compile-ffmpeg.sh all|all32  compile-ffmpeg.sh all64  compile-ffmpeg.sh clean  compile-ffmpeg.sh check</code></pre><p>(什么输入h会出现帮助信息？答案在<code>compile-ffmpeg.sh</code>脚本里面)</p><p>那么依次输入<code>./compile-ffmpeg.sh armv7a</code>编译..，等完成后再输入<code>./compile-ffmpeg.sh armv64</code>编译..。</p><p>后面再用相同的方式运行<code>./compile-ijk.sh</code>脚本即可。</p><h3 id="3-开始阅读源码"><a href="#3-开始阅读源码" class="headerlink" title="3. 开始阅读源码"></a>3. 开始阅读源码</h3><p>工具：</p><ol><li>Visual studio code</li><li>删掉编译ffmpeg带来的<code>build/</code>目录下对应架构的源码，否则在全局查找某个函数的时候，会显示多个搜索结果，看代码的时候就不方便了。<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>mac开发环境配置</title>
    <link href="/2019/11/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/11/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/mac%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="mac开发环境配置"><a href="#mac开发环境配置" class="headerlink" title="mac开发环境配置"></a>mac开发环境配置</h1><h3 id="1-安装Homebrew"><a href="#1-安装Homebrew" class="headerlink" title="1. 安装Homebrew"></a>1. 安装Homebrew</h3><ol><li><p>安装<code>xcode command line tool</code></p><p><a href="https://www.jianshu.com/p/bf6aa6f97fcb" target="_blank" rel="noopener">Xcode-select命令是什么</a></p><pre><code class="shell">xcode command line tool</code></pre></li><li><p>安装homebrew</p><pre><code class="shell">/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</code></pre><p>注：来自homebrew官网：<a href="https://brew.sh/" target="_blank" rel="noopener">https://brew.sh/</a></p></li><li><p>检查homebrew是否安装完成</p><pre><code class="shell">brew --version</code></pre><p>如果出现如下错误：<code>-bash: brew: command not found</code></p><p>则需要配置环境变量：</p><pre><code class="bash">$ cd ~$ ls -a  #查看是否存在.bash_profile文件。    #如果不存在-&gt;$ touch .bash_profile #创建.bash_profile    #如果存在-&gt; #执行下一步</code></pre><p>注意，这里是<code>.bash_profile</code>文件，名字不要输错了，因为unix系统在开机的时候会加载<code>.bash_profile</code>文件。</p></li></ol><hr><p>   <em>题外话，我找了一篇解释<a href="https://www.cnblogs.com/kevingrace/p/8072860.html" target="_blank" rel="noopener">不同的开机脚本的含义</a>的文章，概括如下</em></p><table><thead><tr><th>脚本</th><th>作用</th></tr></thead><tbody><tr><td>/etc/profile</td><td>此文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行.并从/etc/profile.d目录的配置文件中搜集shell的设置.</td></tr><tr><td>/etc/bashrc</td><td>为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该文件被读取.</td></tr><tr><td>~/.bash_profile</td><td>每个用户都可使用该文件输入专用于自己使用的shell信息,当用户登录时,该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的.bashrc文件.</td></tr><tr><td>~/.bashrc</td><td>该文件包含专用于你的bash shell的bash信息,当登录时以及每次打开新的shell时,该该文件被读取</td></tr><tr><td>~/.bash_logout</td><td>当每次退出系统(退出bash shell)时,执行该文件.</td></tr></tbody></table><hr><p>   继续编<code>.bash_profile</code></p><pre><code class="shell">   sudo vim .bash_profile  #以root身份来打开并创建.bash.profile</code></pre><p>   输入<code>i</code>进入编辑模式，用方向键移动到文件底部，并输入：</p><pre><code class="shell">   export PATH=/usr/local/bin:$PATH  #为PATH添加/usr/local/bin的路径</code></pre><p>   点击<code>esc</code>按键退出编辑模式，再输入<code>:wq</code>，回车：保存并退出vim</p><pre><code class="shell">   source .bash_profile   #更新配置后的环境变量</code></pre><p>   此时再输入<code>brew --version</code>就可以看到版本信息了。</p><ol start="4"><li><p>当用brew install 安装软件的时候，会出现brew一直卡在Updating Homebrew的情况，是因为默认homebrew是自动更新的，可以关闭：</p><pre><code class="shell">vim ~/.bash_profile# 新增一行export HOMEBREW_NO_AUTO_UPDATE=true</code></pre><p>或者更换更新地址。</p><p>卡住的时候也可以按<code>controll+c</code>来关闭这一次的更新。</p></li></ol><h3 id="2-安装jdk，配置jdk环境变量"><a href="#2-安装jdk，配置jdk环境变量" class="headerlink" title="2. 安装jdk，配置jdk环境变量"></a>2. 安装jdk，配置jdk环境变量</h3><p><a href="https://www.jianshu.com/p/d26380f47454" target="_blank" rel="noopener">https://www.jianshu.com/p/d26380f47454</a></p><h3 id="3-安装必备软件和工具"><a href="#3-安装必备软件和工具" class="headerlink" title="3. 安装必备软件和工具"></a>3. 安装必备软件和工具</h3><ol><li><p>让鼠标滚轮和windows保持一致</p><p>mac的鼠标和触摸板的方向有点不舒服，用这个可以调整成触摸板默认，而鼠标反向，达到和windows电脑一致的逻辑。</p><p><a href="https://pilotmoon.com/scrollreverser/" target="_blank" rel="noopener">https://pilotmoon.com/scrollreverser/</a></p></li><li><p>搜狗输入法</p><p>默认的输入法切换中英文需要按<code>caps lock</code>，且长按他切换大写。用了这个可以用<code>shift</code>来切换中英文，且点击切换大小写，保持和windows一致。</p><p><a href="https://pinyin.sogou.com/mac/" target="_blank" rel="noopener">https://pinyin.sogou.com/mac/</a></p></li><li><p>状态栏显示实时网速、内存、cpu等信息</p><p>MenuMeters</p></li><li><p>类似于ubuntu的在终端打开：go2shell</p><p><a href="https://zipzapmac.com/Go2Shell" target="_blank" rel="noopener">https://zipzapmac.com/Go2Shell</a></p></li></ol><h3 id="4-修改用户名和主机名"><a href="#4-修改用户名和主机名" class="headerlink" title="4. 修改用户名和主机名"></a>4. 修改用户名和主机名</h3><ol><li><p>修改主机名：</p><p>修改主机名（命令行里面看到的那个）</p><blockquote><p>sudo scutil –set HostName &lt;你的主机名&gt;</p></blockquote><p>修改共享名称（局域网里面看到的那个）</p><blockquote><p>sudo scutil –set ComputerName &lt;你的共享名&gt;</p></blockquote></li><li><p>修改用户名：</p><p>最好是完全按照apple官方文档上的来：</p><p><a href="https://support.apple.com/zh-cn/HT201548" target="_blank" rel="noopener">更改 macOS 用户帐户和个人文件夹的名称</a></p></li></ol><h3 id="5-设置android-ndk和sdk环境变量"><a href="#5-设置android-ndk和sdk环境变量" class="headerlink" title="5. 设置android ndk和sdk环境变量"></a>5. 设置android ndk和sdk环境变量</h3><pre><code class="shell">#设置androidsdk环境变量。 用于终端能够直接使用tools和platform-tools中的工具，如adbexport PATH=${PATH}:/Users/HWilliam/Library/Android/sdk/platform-toolsexport PATH=${PATH}:/Users/HWilliam/Library/Android/sdk/tools#设置ndk环境变量export ANDROID_NDK=/Users/HWilliam/ndk/android-ndk-r10eexport PATH=$ANDROID_NDK:$PATH</code></pre><h3 id="6-安装gradle"><a href="#6-安装gradle" class="headerlink" title="6. 安装gradle"></a>6. 安装gradle</h3><p><a href="https://gradle.org/install/" target="_blank" rel="noopener">https://gradle.org/install/</a></p><pre><code class="bash">$ brew install gradle</code></pre><p>安装gradle自动提示工具:<a href="https://github.com/gradle/gradle-completion" target="_blank" rel="noopener">https://github.com/gradle/gradle-completion</a></p><pre><code class="bash">$ brew install gradle-completion</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin协程（一）理解</title>
    <link href="/2019/11/09/Kotlin/Kotlin%E5%8D%8F%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%90%86%E8%A7%A3/"/>
    <url>/2019/11/09/Kotlin/Kotlin%E5%8D%8F%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>最近这段时间抽空学习了一下Kotlin协程相关的知识，在此做一个总结和梳理</p></blockquote><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><h4 id="kotlin协程是什么"><a href="#kotlin协程是什么" class="headerlink" title="kotlin协程是什么"></a>kotlin协程是什么</h4><p>一个名为<code>kotlinx.coroutines</code>包下的库， 是由 JetBrains 开发的功能丰富的协程库，方便大家利用协程来完成异步处理的开发。</p><h4 id="当我们创建协程（Coroutine）时，我们创建的是什么？"><a href="#当我们创建协程（Coroutine）时，我们创建的是什么？" class="headerlink" title="当我们创建协程（Coroutine）时，我们创建的是什么？"></a>当我们创建协程（Coroutine）时，我们创建的是什么？</h4><p>一种类似于<code>java.lang.Runnable</code>，但比<code>Runnable</code>功能要强大的多的对象。</p><pre><code class="kotlin">//launch函数是CoroutineScope的拓展函数，即launch{}函数需要该对象才能使用，以下代码不能直接使用launch(Dispatchers.IO) {    //这段代码块就是协程}</code></pre><p>上述代码创建了一个协程，并把该协程指定在<code>Dispatchers.IO</code>，意思是把这段协程代码发送到kotlin提供的用于执行io类任务的线程池中。</p><p>那么这个协程指的是什么？是一种类似于<code>java.lang.Runnable</code>的东西。<code>Runnable</code>是运行在某个线程中的代码块，协程本质上也是运行在某个线程中的代码块。</p><p>相似点在于：</p><ol><li><p>当一个线程在执行一个<code>Runnable</code>任务的时候，这个线程不能同时执行另一个<code>Runnable</code>。相似的，线程在某个时刻，只能运行一个协程任务，不可能一个线程同时运行多个协程任务。</p></li><li><p>我们在使用传统的线程池的时候，线程池内部他自己会构建若干个工作线程，当你调用<code>submit(Runnable)</code>方法的时候，你是将你的代码块发送到线程池中，让线程池内部自己分配工作线程去接住传入线程池的<code>Runnable()</code>对象。</p><p>协程是一样的，当你创建并启动一个协程，你必须直接（或者通过上下文来获取）指定一个线程或者线程池，来把你创建的协程代码块发送到对应的线程或线程池中让他们去执行或调度。他本质还是在用线程池去调度你启动的任务。所以传统线程池的执行原理依然不变。</p></li></ol><p>不同点在于：</p><ol><li>协程有挂起，而java线程池配合<code>Runnable</code>不具备这个功能（除非你自己手动实现）。协程挂起是什么？用<code>Runnable</code>的角度来理解就是：线程执行某个<code>Runnable</code>到一半，把<code>Runnable</code>移出了当前的线程执行上下文，那么当前的<code>Runnable</code>中执行的代码就暂时停止了，而原先的线程则腾出来可以运行别的Runnable去了，而<code>Runnable</code>（协程）中暂停的代码什么时候恢复继续？当协程从挂起恢复的时候，当挂起恢复时，协程又被线程捡起运行了。</li><li>协程相比起<code>Runnable</code>，有丰富的属性和方法，来让协程方便地开始，取消，在不同的线程之间跳转（单个Runnable无法在不同的线程间跳转，要实现线程切换，就得根据上个Runnable的回调再建一个Runnable并发射到要跳转的线程），等等。</li></ol><h2 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h2><h4 id="为什么要学协程？"><a href="#为什么要学协程？" class="headerlink" title="为什么要学协程？"></a>为什么要学协程？</h4><ol><li>一些开源项目，甚至谷歌自己的示例代码中的异步任务，用上了协程，不学看不懂。</li></ol><h4 id="为什么要用协程？"><a href="#为什么要用协程？" class="headerlink" title="为什么要用协程？"></a>为什么要用协程？</h4><ol><li>协程能带来比传统回调更简洁的异步处理代码，能用更短的代码实现相同的功能。代码越简洁，越不容易乱，越不容易出错，可读性越强。</li><li>这是一种新的编程思想和编写异步代码的风格，且是kotlin官方发布的，连google的开源项目也在用，这是一种趋势。</li></ol><h2 id="怎么样"><a href="#怎么样" class="headerlink" title="怎么样"></a>怎么样</h2><h4 id="怎么学？"><a href="#怎么学？" class="headerlink" title="怎么学？"></a>怎么学？</h4><p><a href="https://www.kotlincn.net/docs/reference/coroutines/basics.html" target="_blank" rel="noopener">官方教程</a></p><p><a href="https://github.com/Kotlin/kotlinx.coroutines" target="_blank" rel="noopener">coroutine的github地址</a>（包含API文档，视频介绍，如何依赖，等等）</p><p>更新中…</p><h4 id="怎么用？"><a href="#怎么用？" class="headerlink" title="怎么用？"></a>怎么用？</h4><p>更新中…<br></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>解释Kotlin协程官方文档：（一）基础：</title>
    <link href="/2019/11/05/Kotlin/%E8%A7%A3%E9%87%8AKotlin%E5%8D%8F%E7%A8%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%EF%BC%9A/"/>
    <url>/2019/11/05/Kotlin/%E8%A7%A3%E9%87%8AKotlin%E5%8D%8F%E7%A8%8B%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%EF%BC%9A%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%EF%BC%9A/</url>
    
    <content type="html"><![CDATA[<p>本系列文章用于解释kotlin官方文档中的示例代码。希望能帮助到你。</p><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>官方文档地址 <a href="https://www.kotlincn.net/docs/reference/coroutines/basics.html" target="_blank" rel="noopener">https://www.kotlincn.net/docs/reference/coroutines/basics.html</a> </p><h5 id="作用域构建器"><a href="#作用域构建器" class="headerlink" title="作用域构建器"></a>作用域构建器</h5><pre><code class="kotlin">import kotlinx.coroutines.*fun main() = runBlocking { // this: CoroutineScope    launch {         delay(200L)        println(&quot;Task from runBlocking&quot;)    }    coroutineScope { // 创建一个协程作用域        launch {            delay(500L)             println(&quot;Task from nested launch&quot;)        }        delay(100L)        println(&quot;Task from coroutine scope&quot;) // 这一行会在内嵌 launch 之前输出    }    println(&quot;Coroutine scope is over&quot;) // 这一行在内嵌 launch 执行完毕后才输出}</code></pre><p>程序的运行结果：</p><pre><code>Task from coroutine scopeTask from runBlockingTask from nested launchCoroutine scope is over</code></pre><p>解释：</p><pre><code class="kotlin">import kotlinx.coroutines.*//main方法一启动就创建一个协程，因为这个协程直接把主线程阻塞了，就叫CoroutineBlock吧fun main() = runBlocking { // this: CoroutineScope    //创建一个新的协程，叫做CoroutinebA吧 1    launch {         //挂起当前协程200ms 2        delay(200L)        println(&quot;Task from runBlocking&quot;)    }    //挂起当前协程 3    coroutineScope { // 创建一个协程作用域        //创建新一个新的协程,叫做CoroutineB吧 4        launch {            //挂起当前协程500ms 5            delay(500L)             println(&quot;Task from nested launch&quot;)        }        //挂起当前协程100ms 6        delay(100L)        println(&quot;Task from coroutine scope&quot;) // 这一行会在内嵌 launch 之前输出    }    println(&quot;Coroutine scope is over&quot;) // 这一行在内嵌 launch 执行完毕后才输出}</code></pre><p>我在上述代码中用数字做了标记，现在结合这些标记，逐行代码进行分析。</p><ol><li><p>1处，创建一个新的协程，叫他CoroutineA，并执行协程，立刻返回。</p></li><li><p>然后执行到3，<code>coroutineScpoe()</code>是一个Kotlin协程库中的挂起函数，此时挂起当前协程，当前协程是什么？当前协程正在执行<code>runBlocking{}</code>函数中的代码块，因此此时外部的CoroutineBlock协程被挂起，并调用3处创建的代码块。</p></li><li><p>此时走到4处，又创建了一个新的协程CoroutineB，因为不是挂起函数，所以创建协程后启动并从代码块返回。</p></li><li><p>此时走到6处，遇到挂起函数<code>delay()</code>，那么挂起当前的协程CoroutineBlock。</p></li><li><p>前面两个<code>launch()</code>方法启动了两个协程，分别是CoroutineA和CoroutineB，他们分别走到了 2处 和 5处。并各自调用了一个挂起函数<code>delay()</code>。</p></li><li><p>仔细数一数，此时挂起的协程已经有三个了：分别是<code>JobBlock</code>，<code>JobA</code>和<code>JobB</code>。但是根据他们挂起函数挂起的时间，那么从挂起函数恢复的先后顺序是6处，2处，5处。</p></li><li><p>于是根据挂起函数恢复的先后顺序，打印：</p><pre><code>Task from coroutine scopeTask from runBlockingTask from nested launch</code></pre></li><li><p>还是回到3个协程挂起恢复的地方，先是6处的协程CoroutineBlcok恢复，那么他打印完后，会再等待当前协程作用于创建的协程CoroutineB完成后，再从<code>coroutineScope()</code>方法返回。而当协程CoroutineB执行完后，已经打印完了3行内容。此时从3处的挂起处恢复。</p></li><li><p>继续执行协程CoroutineBlock，打印：</p><pre><code>Coroutine scope is over</code></pre></li></ol><p>这里我的疑问是：函数<code>coroutineScope()</code>创建了一个协程作用域并挂起，并等内部所有的子协程也完成了才立刻返回。</p><p>为什么要这么设计呢？是否有其他创建协程作用于的函数也是这样的功能呢？<br></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Gradle-常用工具脚本</title>
    <link href="/2019/11/05/Gradle/Gradle-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/"/>
    <url>/2019/11/05/Gradle/Gradle-%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E8%84%9A%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<blockquote><p>基于gradle 4.6</p></blockquote><p>本文记录一些常用的gradle工具脚本的写法，基于gradle4.6，不同版本的gradle应对照<a href="https://gradle.org/releases/" target="_blank" rel="noopener">官方文档不同版本</a>的DSL Reference参考对应的api的接口的使用。</p><h4 id="1-clean整个项目"><a href="#1-clean整个项目" class="headerlink" title="1. clean整个项目"></a>1. clean整个项目</h4><p>有的时候有一些操作需要对root project和其下面所有的child project进行一个clean，那么可以参考如下的脚本实现：</p><pre><code class="groovy">//该task定义在root Project下。task cleanAllProject(){    it.dependsOn(&quot;clean&quot;)    rootProject.subprojects{sub-&gt;        sub.afterEvaluate {            def cleanTask = it.tasks.findByName(&#39;clean&#39;)            if (cleanTask != null) {                dependsOn(cleanTask)            }        }    }    it.finalizedBy(&quot;&lt;task that follow this full clean&gt;&quot;)}</code></pre><h4 id="2-copy某个目录，或文件"><a href="#2-copy某个目录，或文件" class="headerlink" title="2. copy某个目录，或文件"></a>2. copy某个目录，或文件</h4><p>copy某个是比较简单的，这里例举copy某个目录，并排除掉指定的子目录。</p><pre><code class="groovy">//copy当前整个项目到buid目录下task copyDir(){    doLast{        copy{            from rootProject.projectDir            //destination路径是build/project，用$buildDir指定build路径            into &quot;$buildDir/project&quot;            //exclude排除指定的目录：/.gradle、 /.idea 、/.git            exclude &quot;**/.gradle/**&quot;            exclude &quot;**/.idea/**&quot;            exclude &quot;**/.git/**&quot;        }    }    it.finalizedBy(&quot;&lt;task that follow this full clean&gt;&quot;)}</code></pre><p>注意，根据文档，<code>exclude( )</code>方法的参数是一个<code>ANT style exclude pattern</code>，这是一种有语法的表达式。</p><p>thanks: </p><p><a href="https://stackoverflow.com/questions/2952196/learning-ant-path-style" target="_blank" rel="noopener">StackOverFlow : Learning Ant path style</a></p><p><a href="https://stackoverflow.com/questions/52768723/cannot-exclude-directories-for-a-gradle-copy-task" target="_blank" rel="noopener">StackOverFlow : Cannot exclude directories for a Gradle copy task</a></p><h4 id="3-zip，生成压缩文件"><a href="#3-zip，生成压缩文件" class="headerlink" title="3. zip，生成压缩文件"></a>3. zip，生成压缩文件</h4><p>实现这个操作我算是踩了一个小坑了。</p><p>我先去官网user mannel home的输入框搜索zip，并选择了</p><p>Creating archives(zip, tar, etc.)这一节内容：</p><p> <a href="https://docs.gradle.org/current/userguide/working_with_files.html#sec:creating_archives_example" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/working_with_files.html#sec:creating_archives_example</a> </p><p>他的示例代码是：</p><pre><code class="groovy">task packageDistribution(type: Zip) {    archiveFileName = &quot;my-distribution.zip&quot;    destinationDirectory = file(&quot;$buildDir/dist&quot;)    from &quot;$buildDir/toArchive&quot;}</code></pre><p>我拿去用的时候报错了，说是找不到属性<code>archiveFileName</code>，然后是我本地的gradle版本落后于官网的版本了。我本地的版本是4.6，而官网的教程是基于5.6.4的。于是我去查找了4.6的教程和DSL说明，4.6的版本的使用方法是：</p><pre><code class="groovy">task makeZip(type: Zip) {    from &quot;/要压缩的目录&quot;    archiveName = &quot;压缩包名字.zip&quot;    //指定生成压缩包的路径，要用file类型    File destinationFile = new File(&quot;$buildDir/zipProduction&quot;)    destinationDir = destinationFile}</code></pre><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="4-更新中。。。"><a href="#4-更新中。。。" class="headerlink" title="4. 更新中。。。"></a>4. 更新中。。。</h4><p></p>]]></content>
    
    
    <categories>
      
      <category>Gradle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>View#onKeyDown不调用</title>
    <link href="/2019/11/02/View/View#onKeyDown%E4%B8%8D%E8%B0%83%E7%94%A8/"/>
    <url>/2019/11/02/View/View#onKeyDown%E4%B8%8D%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>原因：当前View没有获得焦点。</p><p>只要当前的View获得了焦点，那么View的<code>onKeyDown()</code>，<code>onKeyUp()</code>，<code>setOnKeyListener()</code>等回调都会发生。</p><p>KeyEvent由操作系统接收用户输入产生，在应用层，到达顺序是：</p><p><code>ViewRootImpl</code>-&gt;<code>DecorView</code>-&gt;<code>Activity</code>-&gt;<code>ViewGroup</code>-&gt;<code>View</code></p><p>那么看ViewGroup的<code>dispatchOnKeyEvent()</code>方法：</p><pre><code class="java"> @Override public boolean dispatchKeyEvent(KeyEvent event) {     if (mInputEventConsistencyVerifier != null) {         mInputEventConsistencyVerifier.onKeyEvent(event, 1);     }     if ((mPrivateFlags &amp; (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS))             == (PFLAG_FOCUSED | PFLAG_HAS_BOUNDS)) {         if (super.dispatchKeyEvent(event)) {             return true;         }     } else if (mFocused != null &amp;&amp; (mFocused.mPrivateFlags &amp; PFLAG_HAS_BOUNDS)             == PFLAG_HAS_BOUNDS) {         //如果有子View获得了焦点，那么就把KeyEvent分发给子View处理。         if (mFocused.dispatchKeyEvent(event)) {             return true;         }     }     if (mInputEventConsistencyVerifier != null) {         mInputEventConsistencyVerifier.onUnhandledEvent(event, 1);     }     return false; }</code></pre><p>如果子View获得了焦点，则进入到子View的<code>dispatchKeyEvent()</code></p><pre><code class="java">public boolean dispatchKeyEvent(KeyEvent event) {    if (mInputEventConsistencyVerifier != null) {        mInputEventConsistencyVerifier.onKeyEvent(event, 0);    }    // Give any attached key listener a first crack at the event.    //noinspection SimplifiableIfStatement    ListenerInfo li = mListenerInfo;    //如果OnKeyListener不为空，且消费掉了该KeyEvent，则不再继续分发    if (li != null &amp;&amp; li.mOnKeyListener != null &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED            &amp;&amp; li.mOnKeyListener.onKey(this, event.getKeyCode(), event)) {        return true;    }    //在event.dispatch()中会调用onKeyDown和onKeyUp等方法    if (event.dispatch(this, mAttachInfo != null            ? mAttachInfo.mKeyDispatchState : null, this)) {        return true;    }    if (mInputEventConsistencyVerifier != null) {        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);    }    return false;}</code></pre><p>看下<code>KeyEvent#dispatch(Callback receiver, DispatcherState state, Object target)</code>方法</p><pre><code class="java">public final boolean dispatch(Callback receiver, DispatcherState state,        Object target) {    switch (mAction) {        case ACTION_DOWN: {            mFlags &amp;= ~FLAG_START_TRACKING;            if (DEBUG) Log.v(TAG, &quot;Key down to &quot; + target + &quot; in &quot; + state                    + &quot;: &quot; + this);            //这个receiver就是调用该方法的View自己啦~View调用自己的onKeyDown了。            boolean res = receiver.onKeyDown(mKeyCode, this);            //省略        }        case ACTION_UP:            //省略        case ACTION_MULTIPLE:            //省略    }    return false;}</code></pre><p>所以只要当前View获取了整个View tree中的焦点，则可以收到key事件。</p><p>我原先的需求是，Activity中有多个View组件，以及多个可能出现的Window，根据<code>onKeyDown()</code>来拦截用户点击返回按钮，一个一个地关闭Window和浮窗View之类的。当时的设想是每个View自己内部去重写onKeyDown()方法，然后根据自己的可见性来拦截BACK事件并隐藏。但是发现无法回调onKeyDown()方法。于是放弃，并还是采取在Activity中重写onKeyDown()并一个一个地判断关闭。</p><p>今天查了一番资料，发现是焦点的问题，因此还是可以把onKeyDown写到对应的每个View中的。</p><p>只是需要额外做点工作，就是在显示的时候记住当前的焦点View，并在隐藏的时候把焦点还回去，以便原先的那个View也能正常接收<code>onKeyDown()</code>方法，例如：</p><pre><code class="kotlin">private var lastFocusdView: View? = nullprivate fun initView(){    isFocusable = true    isFocusableInTouchMode = true    //...}private fun show(){    lastFocusdView = (context as Activity).currentFocus    requestFocus()    //do show}private fun hide(){    lastFocusdView?.requestFocus()    //do hide}</code></pre><p>参考：</p><p><a href="https://blog.csdn.net/Conan9715/article/details/78529055" target="_blank" rel="noopener">Activity dispatchTouchEvent事件分发的源头</a></p><p><a href="https://www.jianshu.com/p/2f28386706a0" target="_blank" rel="noopener">Android KeyEvent 点击事件分发处理流程（一）</a><br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JsonDeserializer和JsonSerializer可能引起无限循环调用导致StackOverFlow</title>
    <link href="/2019/10/26/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/JsonDeserializer%E5%92%8CJsonSerializer%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E8%B0%83%E7%94%A8%E5%AF%BC%E8%87%B4StackOverFlow/"/>
    <url>/2019/10/26/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/JsonDeserializer%E5%92%8CJsonSerializer%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E8%B0%83%E7%94%A8%E5%AF%BC%E8%87%B4StackOverFlow/</url>
    
    <content type="html"><![CDATA[<h3 id="1-两种自定义方式"><a href="#1-两种自定义方式" class="headerlink" title="1. 两种自定义方式"></a>1. 两种自定义方式</h3><p>Gson自定义序列化和反序列的方式有两种</p><ol><li>通过<code>GsonBuilder</code>来注册适配器。</li><li>用<code>@JsonAdapter</code>注解来为类型或者属性指定适配器。</li></ol><p>其中，以注解的方式用<code>@JsonAdapter</code>来实现自定义序列化或反序列化，gson的github的wiki页是没有的，但是参照这个类的注释，也很容易就能实现。</p><h3 id="2-例子"><a href="#2-例子" class="headerlink" title="2. 例子"></a>2. 例子</h3><p>场景：</p><p>首先，正常的json字符串是这样的结构：</p><pre><code class="json">{    &quot;family&quot;:{        &quot;Dad&quot;:&quot;a&quot;,        &quot;Mon&quot;:&quot;b&quot;    },    &quot;gender&quot;:&quot;male&quot;,    &quot;home&quot;:&quot;Shenzhen&quot;,    &quot;name&quot;:&quot;William&quot;}</code></pre><p>该json中包含两个json对象，一个是外部对象，一个是family对象。那么用类似<code>GsonFormat</code>之类的插件，就会生成两个类。</p><pre><code class="kotlin">data class Person(    val family: Family?,    val gender: String,    val home: String,    val name: String) {    data class Family(        val dad: String,        val mon: String    )}</code></pre><p>但是，有时候服务器会不合理地返回一个这样的数据：</p><pre><code class="json">{  &quot;family&quot;: &quot;&quot;,  &quot;gender&quot;: &quot;male&quot;,  &quot;home&quot;: &quot;Shenzhen&quot;,  &quot;name&quot;: &quot;William&quot;}</code></pre><p>即family这个本应该是json对象的地方，返回了空字符串。</p><p>那么当用Gson反序列化的时候，会报这样的错误：</p><pre><code>Exception in thread &quot;main&quot; com.google.gson.JsonSyntaxException: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at line 2 column 14 path $.family    at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:226)    at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$1.read(ReflectiveTypeAdapterFactory.java:131)    at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:222)    at com.google.gson.Gson.fromJson(Gson.java:932)    at com.google.gson.Gson.fromJson(Gson.java:897)    at com.google.gson.Gson.fromJson(Gson.java:846)    at com.google.gson.Gson.fromJson(Gson.java:817)    at william.MainKtKt.main(MainKt.kt:10)Caused by: java.lang.IllegalStateException: Expected BEGIN_OBJECT but was STRING at line 2 column 14 path $.family    at com.google.gson.stream.JsonReader.beginObject(JsonReader.java:386)    at com.google.gson.internal.bind.ReflectiveTypeAdapterFactory$Adapter.read(ReflectiveTypeAdapterFactory.java:215)    ... 7 more</code></pre><p>即解析family这个key的时候，本来期望是得到一个对象，但是得到了一个String，即json字符串和你定义的对应的实体类不符合。</p><p>那么这个时候可以通过自定义反序列化策略，来在规避gson在反序列化过程中，遇到本应该返回对象，却返回了字符串而引起的错误。</p><pre><code class="kotlin">class CustomFamilyDeserializer : JsonDeserializer&lt;Family&gt; {    override fun deserialize(json: JsonElement, typeOfT: Type?, context: JsonDeserializationContext): Family? {        return if (!json.isJsonObject) {            //如果这个json不是一个jsonObject，那么返回一个null，让gson去把Family属性映射成null即可。            null        } else {                        //如果是jsonObject，那么就用gson继续解析即可。            Gson().fromJson(json, typeOfT)            //如果用context直接解析，会导致栈溢出            //context.deserialize(json, typeOfT)        }    }}</code></pre><p>上面的是一个自定义的<code>JsonDeserializer</code>实现。</p><p>使用：</p><ol><li><p>GsonBuilder</p><pre><code class="kotlin">val gson :Gson = getGsonBuilder()    .registerTypeAdapter(Person.Family::class.java, Person.Family.CustomFamilyDeserializer())    .create()//json字符串val jsonOfPerson=&quot;&quot;val person :Person =gson.fromJson(jsonOfPerson,Person::class.java)</code></pre></li><li><p>@JsonAdapter</p><p>直接在Family属性处加上注解</p><pre><code class="kotlin">data class Person(    @JsonAdapter(Family.CustomFamilyDeserializer::class)    val family: Family?,    val gender: String,    val home: String,    val name: String) {    data class Family(        val dad: String,        val mon: String    ) {        class CustomFamilyDeserializer : JsonDeserializer&lt;Family&gt; {            override fun deserialize(json: JsonElement, typeOfT: Type?, context: JsonDeserializationContext): Family? {                return if (!json.isJsonObject) {                    null                } else {                    //用当前上下文解析，也不会引起栈溢出                    context.deserialize(json, typeOfT)                    //新构建一个Gson对象，也不会引起栈溢出                    //Gson().fromJson(json, typeOfT)                }            }        }    }}</code></pre><p>然后直接解析就行</p><pre><code class="kotlin">val jsonOfPerson=&quot;&quot;val person :Person =gson.fromJson(jsonOfPerson,Person::class.java)</code></pre></li></ol><h3 id="3-JsonAdapter"><a href="#3-JsonAdapter" class="headerlink" title="3. @JsonAdapter"></a>3. @JsonAdapter</h3><pre><code class="java">@Retention(RetentionPolicy.RUNTIME)@Target({ElementType.TYPE, ElementType.FIELD})public @interface JsonAdapter {  /** Either a {@link TypeAdapter} or {@link TypeAdapterFactory}, or one or both of {@link JsonDeserializer} or {@link JsonSerializer}. */  Class&lt;?&gt; value();  /** false, to be able to handle {@code null} values within the adapter, default value is true. */  boolean nullSafe() default true;}</code></pre><p>jsonAdapter的处理目标是<code>类型</code>和<code>变量</code>。</p><p>当他用在变量上（即如上面的例子的用法）时，可以在回调中，无论用context上下文或者新建一个Gson对象，来解析当前json，都不会造成无限循环调用的问题。</p><p>而当他作用在类型上时，在回调中，无论用context上下文或者新建一个Gson对象，来解析当前json，都会造成异常。所以，当该注解用在类型上时，回调中一定不能对同样的类型再用Gson去解析。</p><h3 id="4-GsonBuilder"><a href="#4-GsonBuilder" class="headerlink" title="4. GsonBuilder"></a>4. GsonBuilder</h3><p>用GsonBuilder的时候，是通过<code>registerTypeAdapter</code>方法注册一个序列化器或反序列化器，那么只要在回调用你不要用当前Gson上下文，创建另一个Gson对象，来进行解析，就不会有任何的问题。</p><blockquote><p>结论：</p><p>最好不要在JsonSerializer或JsonDeserializer实现中对当前的类型的对象再用gson解析，因为很可能会引起无限循环地去调用该解析器。如果实在要用，则在GsonBuilder的时候新建一个Gson，或者用@JsonAdapter的时候注解打到变量上而不是类上。</p></blockquote><p></p>]]></content>
    
    
    <categories>
      
      <category>第三方库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用javah命令生成-h头文件</title>
    <link href="/2019/10/20/ndk/%E7%94%A8javah%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90-h%E5%A4%B4%E6%96%87%E4%BB%B6/"/>
    <url>/2019/10/20/ndk/%E7%94%A8javah%E5%91%BD%E4%BB%A4%E7%94%9F%E6%88%90-h%E5%A4%B4%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-配置JDK环境变量"><a href="#1-配置JDK环境变量" class="headerlink" title="1. 配置JDK环境变量"></a>1. 配置JDK环境变量</h3><p>因为要用到javah的命令，所以需要配置jdk的环境变量，配置成功后，在命令行输入<code>javah</code></p><pre><code class="shell">C:\Users\Administratorλ javah用法:  javah [options] &lt;classes&gt;其中, [options] 包括:  -o &lt;file&gt;                输出文件 (只能使用 -d 或 -o 之一)  -d &lt;dir&gt;                 输出目录  -v  -verbose             启用详细输出  -h  --help  -?           输出此消息  -version                 输出版本信息  -jni                     生成 JNI 样式的标头文件 (默认值)  -force                   始终写入输出文件  -classpath &lt;path&gt;        从中加载类的路径  -cp &lt;path&gt;               从中加载类的路径  -bootclasspath &lt;path&gt;    从中加载引导类的路径&lt;classes&gt; 是使用其全限定名称指定的(例如, java.lang.Object)。</code></pre><p>他会输出javah命令的用法</p><h3 id="2-用命令生成头文件"><a href="#2-用命令生成头文件" class="headerlink" title="2. 用命令生成头文件"></a>2. 用命令生成头文件</h3><p>确保输入命令所在的目录下存在含有<code>native</code>方法的class<strong>全路径文件</strong>，即<code>.class</code>文件需要在一个如下所示的路径中：</p><pre><code class="shell">└─com    └─hwilliam        └─jnilearn                JNIMethod.class</code></pre><p>（注意，这里需要确保输入javah命令的目录下是包含类的完整路径的，不能直接只有一个.class文件，那样会报找不到类文件的错误）</p><p>输入pwd查看当前工作目录</p><pre><code class="shell">λ pwdC:\AndroidProject\JNILearn\app\build\intermediates\javac\debug\classes</code></pre><p>那么此时输入命令：</p><pre><code class="shell">$ javah com.hwilliam.jnilearn.JNIMethod</code></pre><p>则在当前目录生成了文件：</p><p><code>com_hwilliam_jnilearn_JNIMethod.h</code></p><p></p>]]></content>
    
    
    <categories>
      
      <category>ndk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在AndroidStudio中使用其他的terminal程序</title>
    <link href="/2019/10/18/%E5%8A%A0%E5%BF%AB%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%9C%A8AndroidStudio%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E7%9A%84terminal%E7%A8%8B%E5%BA%8F/"/>
    <url>/2019/10/18/%E5%8A%A0%E5%BF%AB%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%9C%A8AndroidStudio%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%85%B6%E4%BB%96%E7%9A%84terminal%E7%A8%8B%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<p>默认的termianl程序是windows自带的cmd，用起来十分的不方便，不支持shell的命令。<br>AS支持对默认termianl的一个切换，在这里我切换成cmder。</p><ol><li>安装cmder</li><li>配置cmder的目录到系统环境变量：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-8d9a02fba0e2ecd6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li><li>将系统环境变量写入到AS的terminal设置中，让AS启动terminal的时候去启动cmder：<br><code>&quot;cmd.exe&quot; /k &quot;&quot;%CMDER_ROOT%\vendor\init.bat&quot;&quot;</code></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/7177220-105044f1661284cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>关闭AS的terminal，重新打开一个即可。</p><p>thanks：<a href="https://github.com/cmderdev/cmder/issues/282" target="_blank" rel="noopener">https://github.com/cmderdev/cmder/issues/282</a></p><p></p>]]></content>
    
    
    <categories>
      
      <category>加快开发效率的工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>快速启搭建Android项目所需要的库</title>
    <link href="/2019/10/14/%E5%8A%A0%E5%BF%AB%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%BF%AB%E9%80%9F%E5%90%AF%E6%90%AD%E5%BB%BAAndroid%E9%A1%B9%E7%9B%AE%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E5%BA%93/"/>
    <url>/2019/10/14/%E5%8A%A0%E5%BF%AB%E5%BC%80%E5%8F%91%E6%95%88%E7%8E%87%E7%9A%84%E5%B7%A5%E5%85%B7/%E5%BF%AB%E9%80%9F%E5%90%AF%E6%90%AD%E5%BB%BAAndroid%E9%A1%B9%E7%9B%AE%E6%89%80%E9%9C%80%E8%A6%81%E7%9A%84%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>工具类</p><pre><code class="groovy">implementation &#39;com.blankj:utilcode:1.25.9&#39;// if u use AndroidX, use the followingimplementation &#39;com.blankj:utilcodex:1.25.9&#39;</code></pre><p>权限请求</p><pre><code class="groovy">//for androidximplementation &quot;com.hwilliamgo:fastpermission-x:1.0.0&quot;</code></pre><p>持续更新…<br></p>]]></content>
    
    
    <categories>
      
      <category>加快开发效率的工具</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Gradle自定义插件和发布</title>
    <link href="/2019/09/24/Gradle/Gradle%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%92%8C%E5%8F%91%E5%B8%83/"/>
    <url>/2019/09/24/Gradle/Gradle%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%92%8C%E5%8F%91%E5%B8%83/</url>
    
    <content type="html"><![CDATA[<h1 id="Gradle自定义插件和发布"><a href="#Gradle自定义插件和发布" class="headerlink" title="Gradle自定义插件和发布"></a>Gradle自定义插件和发布</h1><p>这篇文章讲解的是如何自定义gradle插件，并以本地依赖和远程依赖的方式来集成。</p><p>本文大体结构和内容基于：gradle官网的教程：<a href="https://docs.gradle.org/current/userguide/custom_plugins.html#sec:working_with_files_in_custom_tasks_and_plugins" target="_blank" rel="noopener">开发自定义gradle插件</a></p><p>约定俗成的说法：</p><ol><li>插件消费者项目：使用对应插件的项目。</li><li>开发插件的项目：独立的，用来开发gradle插件的项目。</li></ol><p>开始：</p><p>自定义gradle插件的三种形式：</p><ol><li>直接在项目中写一个插件，并由build.gradle直接应用来使用。</li><li>在独立的项目中开发插件，并以本地依赖的形式集成。</li><li>在独立的项目中开发插件，并以远程依赖的形式集成。</li></ol><h3 id="1-直接在项目中写插件并应用"><a href="#1-直接在项目中写插件并应用" class="headerlink" title="1 直接在项目中写插件并应用"></a>1 直接在项目中写插件并应用</h3><h3 id="2-在独立的项目中开发一个插件，本地依赖"><a href="#2-在独立的项目中开发一个插件，本地依赖" class="headerlink" title="2 在独立的项目中开发一个插件，本地依赖"></a>2 在独立的项目中开发一个插件，本地依赖</h3><h4 id="2-1-新建一个独立的java类项目"><a href="#2-1-新建一个独立的java类项目" class="headerlink" title="2.1 新建一个独立的java类项目"></a>2.1 新建一个独立的java类项目</h4><p>用idea或者android studio新建一个module或者新建一个project都可以，只要是能够轻易打出jar包的项目即可。</p><h5 id="2-1-1-build-gradle中引入gradle-api的依赖"><a href="#2-1-1-build-gradle中引入gradle-api的依赖" class="headerlink" title="2.1.1 build.gradle中引入gradle api的依赖"></a>2.1.1 build.gradle中引入gradle api的依赖</h5><p>首先，自定义插件类的编写，需要实现<code>org.gradle.api.Plugin</code>接口，这个不是jdk的类，而是gradle提供的接口，因此必须对gradle的api做一个依赖。</p><p>那么在项目的<code>build.gradle</code>中写入：</p><pre><code class="groovy">plugins {    id &#39;groovy&#39;}dependencies {    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    //我们需要实现gradle的Plugin&lt;T&gt;接口，来做自定义插件，因此依赖gradle api    implementation gradleApi()    //依赖gradle提供的groovy sdk，在编写自定义插件的时候，用groovy更快。    implementation localGroovy()}sourceCompatibility = &quot;7&quot;targetCompatibility = &quot;7&quot;</code></pre><p>我的例子并没有用到groovy，所以去掉上面的<code>localGroovy</code>，并将<code>groovy</code>插件换成<code>java</code>插件也可以。</p><h5 id="2-1-2-创建并配置-properties文件。"><a href="#2-1-2-创建并配置-properties文件。" class="headerlink" title="2.1.2 创建并配置.properties文件。"></a>2.1.2 创建并配置.properties文件。</h5><p>其次，我们写出来的插件最终作为jar包被插件消费者项目引用，那么插件消费者项目要如何在jar包中找到我们<code>org.gradle.Plugin</code>接口的实现类呢？以及我们在哪里定义我们的插件的id呢？</p><p>那么，需要在路径：<code>src/main/resources/META-INF/gradle-plugins/</code>下，创建一个<code>aa.bb.cc.properties</code>名字的文件，里面容为：</p><pre><code class="properties">implementation-class=你的Plugin&lt;T&gt;接口实现类的全路径名，例如：aa.bb.cc.MyPlugin</code></pre><p>那么此时，消费者项目能够找到插件接口实现类，并且，<code>properties</code>文件的名字就作为你的插件id。</p><h5 id="2-1-3-写一个简单的插件，生成一个task"><a href="#2-1-3-写一个简单的插件，生成一个task" class="headerlink" title="2.1.3 写一个简单的插件，生成一个task"></a>2.1.3 写一个简单的插件，生成一个task</h5><pre><code class="java">package com.william.customplugin;import org.gradle.api.Action;import org.gradle.api.Plugin;import org.gradle.api.Project;import org.gradle.api.Task;/** * date: 2019/9/6 0006 * * @author hwj * description 插件 */public class GreetingPlugin implements Plugin&lt;Project&gt; {    @Override    public void apply(Project project) {        project.task(&quot;hello&quot;, new Action&lt;Task&gt;() {            @Override            public void execute(Task task) {                task.doLast(new Action&lt;Task&gt;() {                    @Override                    public void execute(Task task) {                        System.out.println(&quot;task hello---doLast&quot;);                    }                });            }        });    }}</code></pre><p>以上，所有的代码编写工作完成了。</p><p>贴出此时项目的结构：</p><pre><code class="shell">/customPlugin│  .gitignore│  build.gradle│└─src    └─main        ├─java        │  └─com        │      └─william        │          └─customplugin        │                  GreetingPlugin.java        │        └─resources            └─META-INF                └─gradle-plugins                        com.william.customplugin.properties</code></pre><h4 id="2-2-构建项目的产物：jar包"><a href="#2-2-构建项目的产物：jar包" class="headerlink" title="2.2  构建项目的产物：jar包"></a>2.2  构建项目的产物：jar包</h4><p>注意，在这一步，有两种实现方案：</p><ol><li>直接用build类型的gradle脚本打出一个jar包，然后将jar包复制粘贴到插件消费者项目。</li><li>用gradle的<code>maven</code>或者<code>maven-publish</code>插件，来将打包的jar包发布到指定的本地路径中。</li></ol><p>我们先看第一种方式：</p><h5 id="2-2-1-用build类型的gradle脚本打包"><a href="#2-2-1-用build类型的gradle脚本打包" class="headerlink" title="2.2.1 用build类型的gradle脚本打包"></a>2.2.1 用build类型的gradle脚本打包</h5><p>执行</p><pre><code class="shell">/customPlugin$ gradlew build</code></pre><p>构建产物在：<code>./build/libs/customPlugin.jar</code></p><p>此时拿到了jar包。其中包含了我们写的<code>org.gradle.Plugin</code>接口的实现类。</p><h5 id="2-2-2-用maven类型的脚本打包并发布在指定的本地路径"><a href="#2-2-2-用maven类型的脚本打包并发布在指定的本地路径" class="headerlink" title="2.2.2 用maven类型的脚本打包并发布在指定的本地路径"></a>2.2.2 用maven类型的脚本打包并发布在指定的本地路径</h5><p>打开插件开发项目，我们需要发布一个maven类型的软件包。gradle为maven类型的软件包发布提供了两种插件：<code>maven</code>和<code>maven-publish</code>，前者已经被废弃，现在最新的是后者，我们这里用后者插件来实现构件一个maven类型的软件包。</p><p>我们参考的是<a href="https://docs.gradle.org/current/userguide/publishing_overview.html" target="_blank" rel="noopener"><code>maven-publish</code>文档</a>的最简单的发版配置：</p><pre><code class="groovy">group = &#39;org.example&#39;version = &#39;1.0&#39;publishing {    publications {        myLibrary(MavenPublication) {            from components.java        }    }    repositories {        maven {            name = &#39;myRepo&#39;            url = &quot;file://${buildDir}/repo&quot;        }    }}</code></pre><p>将上述的配置移植到我们的插件开发项目的build.gradle中，如下：</p><pre><code class="groovy">plugins {    id &#39;groovy&#39;    id &#39;maven-publish&#39;}group = &quot;com.william.customplugin&quot;version = &quot;1.0&quot;publishing {    publications {        myLibrary(MavenPublication) {            from components.java        }    }    //仓库配置    repositories {        maven {            //name这个属性是用来指定仓库名字的，貌似在这里没什么用，注释掉。            //name = &#39;myRepo&#39;            //指定发布仓库的路径            url = &quot;./build/repo&quot;        }    }}dependencies {    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    implementation gradleApi()    implementation localGroovy()}sourceCompatibility = &quot;7&quot;targetCompatibility = &quot;7&quot;</code></pre><p>接下来就是执行一个task，来构建并发布了。</p><p><code>maven-publish</code>脚本带来了task <code>publish</code>，他会执行所有的发布任务。而我们这里只有一个发布任务，所以执行他就好了。</p><pre><code class="shell">gradlew publish===&gt;14:45:49: Executing task &#39;publish&#39;...Executing tasks: [publish] in project C:\AndroidProject\KotlinSimpleTest\customPlugin&gt; Task :customPlugin:generatePomFileForMyLibraryPublication&gt; Task :customPlugin:compileJava UP-TO-DATE&gt; Task :customPlugin:compileGroovy NO-SOURCE&gt; Task :customPlugin:processResources UP-TO-DATE&gt; Task :customPlugin:classes UP-TO-DATE&gt; Task :customPlugin:jar UP-TO-DATE&gt; Task :customPlugin:publishMyLibraryPublicationToMavenRepository&gt; Task :customPlugin:publishBUILD SUCCESSFUL in 4s5 actionable tasks: 2 executed, 3 up-to-date14:45:53: Task execution finished &#39;publish&#39;.</code></pre><p>OK，现在跑去<code>./build/repo</code>下面找我们的软件包吧。</p><pre><code>├─repo│  └─com│      └─william│          └─customplugin│              └─customPlugin│                  │  maven-metadata.xml│                  │  maven-metadata.xml.md5│                  │  maven-metadata.xml.sha1│                  ││                  └─1.0│                          customPlugin-1.0.jar│                          customPlugin-1.0.jar.md5│                          customPlugin-1.0.jar.sha1│                          customPlugin-1.0.pom│                          customPlugin-1.0.pom.md5│                          customPlugin-1.0.pom.sha1</code></pre><p>输出的整个包多了很多东西。我们用普通的<code>build</code>命令打出来的jar包，只有一个单独的jar包，而用<code>maven-publish</code>插件打出来的包，囊括了完整的全路径名，带有pom文件用于描述依赖，带有maven元数据等等，这是一个完整的、可用于分发的软件了~</p><h4 id="2-3-在插件消费者项目中使用插件"><a href="#2-3-在插件消费者项目中使用插件" class="headerlink" title="2.3 在插件消费者项目中使用插件"></a>2.3 在插件消费者项目中使用插件</h4><h5 id="2-3-1-直接使用本地的jar包中的插件。"><a href="#2-3-1-直接使用本地的jar包中的插件。" class="headerlink" title="2.3.1 直接使用本地的jar包中的插件。"></a>2.3.1 直接使用本地的jar包中的插件。</h5><p>拿到jar包后，把他放在一个可以被找到的路径，我把他放在了插件消费者项目的根目录的<code>gradle_plugin_libs/</code>目录下。</p><pre><code>└─gradle_plugin_libs        customPlugin.jar</code></pre><p>一般来说，安卓项目都采用的是gradle的multi-project-build组织类型，所以我打算在根目录下让gradle对我的脚本进行一个依赖，以便子项目不需要再自己去声明对脚本的依赖。</p><p>即<code>rootProject/build.gradle</code>下：</p><pre><code class="groovy">buildscript{    repositories{        //...    }    dependencies{        classpath &#39;com.android.tools.build:gradle:3.4.1&#39;        //...        //注意，之类不能用classpath，因为classpath指定的是以标准的maven格式构建的软件包。        //我们这里是直接用jar的，classpath识别不了，会报错。因此用classpath files()        classpath files (&#39;./gradle_plugin_libs/customPlugin.jar&#39;)    }}//..</code></pre><p>随意地找一个项目的构建脚本，写上：<code>apply plugin: &#39;com.william.customplugin&#39;</code>。（注意，插件Id是properties文件的名字）</p><p>执行命令：<code>gradlew hello</code>–&gt;  输出： task hello—doLast</p><p>大功告成~</p><h5 id="2-3-2-使用本地maven仓库下的jar包中的插件"><a href="#2-3-2-使用本地maven仓库下的jar包中的插件" class="headerlink" title="2.3.2 使用本地maven仓库下的jar包中的插件"></a>2.3.2 使用本地maven仓库下的jar包中的插件</h5><p>将2.2.2节构建出的软件包整个复制到<code>gradle_plugin_libs/</code>中。</p><p>修改根目录构建脚本：<code>rootProject/build.gradle</code></p><pre><code class="groovy">buildscript{    repositories{        //...        //指定一个maven仓库的路径        maven {            url uri(&#39;./gradle_plugin_libs&#39;)        }    }    dependencies{        //...        //用标准的classpath方法，来找到我们的插件        classpath(&#39;com.william.customplugin:customPlugin:1.0&#39;)    }}//..</code></pre><p>执行<code>gradlew hello</code>，输出和上一节一样。</p><p>大功告成~</p><h4 id="2-4-如何测试插件？"><a href="#2-4-如何测试插件？" class="headerlink" title="2.4 如何测试插件？"></a>2.4 如何测试插件？</h4><p>待补充</p><h3 id="3-在独立的项目中开发一个插件，远程依赖"><a href="#3-在独立的项目中开发一个插件，远程依赖" class="headerlink" title="3 在独立的项目中开发一个插件，远程依赖"></a>3 在独立的项目中开发一个插件，远程依赖</h3><p>上面我们对插件进行了本地依赖的方式来使用，现在我们将我们的插件打出的软件包上传到远程仓库上，让别的开发者也能快速地集成。</p><h4 id="3-1-新建一个独立的java类项目"><a href="#3-1-新建一个独立的java类项目" class="headerlink" title="3.1 新建一个独立的java类项目"></a>3.1 新建一个独立的java类项目</h4><p>我们就用上述的那个插件开发项目，不用再新建了。</p><h4 id="3-2-将构建的jar包上传到一个远程仓库"><a href="#3-2-将构建的jar包上传到一个远程仓库" class="headerlink" title="3.2 将构建的jar包上传到一个远程仓库"></a>3.2 将构建的jar包上传到一个远程仓库</h4><p>远程仓库有两个类型：</p><ol><li>大家所熟知的中央仓库：例如<code>mavenCentral</code>，<code>jcenter</code>，<code>jitpack</code></li><li>普通的远程仓库</li></ol><p>他们本质上都是一样的，只是那3个中央仓库是用的人最多的。</p><p>我们现在通过<code>bintray</code>这个软件包发行平台，来上传并管理我们的软件包。</p><p><code>bintray</code>用于上传maven类型的软件包有3种方式，我们的其中一种是通过gradle的方式：<a href="https://github.com/bintray/gradle-bintray-plugin。" target="_blank" rel="noopener">https://github.com/bintray/gradle-bintray-plugin。</a><br>这是bintray官方开发的上传插件，专门用于打包和上传maven类型的软件包到bintray上面，选项多，可自定义程度高，使用复杂。</p><p>在github上有一个快捷方便的第三方开发者开发的插件：<a href="https://github.com/novoda/bintray-release" target="_blank" rel="noopener">https://github.com/novoda/bintray-release</a></p><p>只需要一个代码块就能完成bintray上传的配置，这里我们用这个简单的插件来做演示，当然大家可以根据自己业务的需求选择负责度和功能性更高的官方插件。</p><h5 id="3-2-1-创建bintray账号"><a href="#3-2-1-创建bintray账号" class="headerlink" title="3.2.1 创建bintray账号"></a>3.2.1 创建bintray账号</h5><p>在这一步，要完成的事项如下：</p><ol><li>创建bintray账号</li><li>创建一个要上传该软件包的仓库</li><li>在上述仓库下创建一个package，即创建一个软件包，软件包需要和你后面上传的软件包名字相同。（我很纳闷为什么一定要创建了一个包才能上传，不能上传的时候没有包bintray就自己创建吗，真是奇怪，我在这一步停滞了很久…）</li></ol><h5 id="3-2-2-配置bintray上传脚本"><a href="#3-2-2-配置bintray上传脚本" class="headerlink" title="3.2.2 配置bintray上传脚本"></a>3.2.2 配置bintray上传脚本</h5><pre><code class="groovy">plugins {    id &#39;groovy&#39;}dependencies {    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    implementation gradleApi()    implementation localGroovy()}sourceCompatibility = &quot;7&quot;targetCompatibility = &quot;7&quot;//以上是默认的内容，以下是上传脚本的配置，可以说是非常简洁了。//应用插件apply plugin: &#39;com.novoda.bintray-release&#39;//上传配置publish {    userOrg = &quot;huangwilliam33333&quot;//组织，如果没有创建组织，就直接填写用户名。    groupId = &#39;com.william&#39;//group    artifactId = &#39;customPlugin&#39;//module    publishVersion = &#39;1.0&#39;//版本    desc = &#39;自定义测试用的插件&#39;//描述    website = &#39;htttp://www.baidu.com&#39;//网站，随便填    bintrayUser = &quot;huangwilliam33333&quot;//用户名    bintrayKey = &quot;xxx&quot;//bintray秘钥    dryRun = false//如果这个是true，则只是运行，而不会上传，要配置成false}</code></pre><p>执行<code>gradlew clean build bintrayUpload</code></p><p>上传成功。</p><h4 id="3-3-在另一个项目中依赖这个远程仓库，并使用该插件"><a href="#3-3-在另一个项目中依赖这个远程仓库，并使用该插件" class="headerlink" title="3.3 在另一个项目中依赖这个远程仓库，并使用该插件"></a>3.3 在另一个项目中依赖这个远程仓库，并使用该插件</h4><p>到插件消费者项目中：</p><p>我们还是在根目录应用插件：</p><pre><code class="groovy">buildscript {    ext.kotlin_version = &#39;1.3.41&#39;    repositories {        google()        jcenter()        //因为还没有将软件包加入到Jcenter，所以要指明maven地址        maven{            url  &quot;https://dl.bintray.com/huangwilliam33333/maven&quot;        }    }    dependencies {        classpath &#39;com.android.tools.build:gradle:3.5.0&#39;        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files        classpath &#39;com.novoda:bintray-release:0.9.1&#39;        //依赖插件        classpath(&#39;com.william:customPlugin:1.0&#39;)    }}</code></pre><p>插件的使用和前面一样。</p><h4 id="3-4-如何测试插件"><a href="#3-4-如何测试插件" class="headerlink" title="3.4 如何测试插件"></a>3.4 如何测试插件</h4><p>待补充</p><p>参考资料：</p><p><a href="https://github.com/novoda/bintray-release" target="_blank" rel="noopener">bintray第三方简易上传插件</a></p><p><a href="https://github.com/bintray/gradle-bintray-plugin" target="_blank" rel="noopener">bintray官方上传插件</a></p><p><a href="https://www.jianshu.com/p/9f81d5b5a451" target="_blank" rel="noopener">讲到了bintray创建了仓库后还要创建软件包才能上传</a></p><p><a href="https://stackoverflow.com/questions/35302414/adding-local-plugin-to-a-gradle-project" target="_blank" rel="noopener">https://stackoverflow.com/questions/35302414/adding-local-plugin-to-a-gradle-project</a></p><p><a href="https://docs.gradle.org/current/userguide/publishing_overview.html" target="_blank" rel="noopener">gradle官方文档：publishing artifact</a></p><p><a href="https://docs.gradle.org/current/userguide/publishing_maven.html#publishing_maven" target="_blank" rel="noopener">gradle官方文档：maven publish plugin</a><br>��到插件消费者项目。<br>2. 用gradle的<code>maven</code>或者<code>maven-publish</code>插件，来将打包的jar包发布到指定的本地路径中。</p><p>我们先看第一种方式：</p><h5 id="2-2-1-用build类型的gradle脚本打包-1"><a href="#2-2-1-用build类型的gradle脚本打包-1" class="headerlink" title="2.2.1 用build类型的gradle脚本打包"></a>2.2.1 用build类型的gradle脚本打包</h5><p>执行</p><pre><code class="shell">/customPlugin$ gradlew build</code></pre><p>构建产物在：<code>./build/libs/customPlugin.jar</code></p><p>此时拿到了jar包。其中包含了我们写的<code>org.gradle.Plugin</code>接口的实现类。</p><h5 id="2-2-2-用maven类型的脚本打包并发布在指定的本地路径-1"><a href="#2-2-2-用maven类型的脚本打包并发布在指定的本地路径-1" class="headerlink" title="2.2.2 用maven类型的脚本打包并发布在指定的本地路径"></a>2.2.2 用maven类型的脚本打包并发布在指定的本地路径</h5><p>打开插件开发项目，我们需要发布一个maven类型的软件包。gradle为maven类型的软件包发布提供了两种插件：<code>maven</code>和<code>maven-publish</code>，前者已经被废弃，现在最新的是后者，我们这里用后者插件来实现构件一个maven类型的软件包。</p><p>我们参考的是<a href="https://docs.gradle.org/current/userguide/publishing_overview.html" target="_blank" rel="noopener"><code>maven-publish</code>文档</a>的最简单的发版配置：</p><pre><code class="groovy">group = &#39;org.example&#39;version = &#39;1.0&#39;publishing {    publications {        myLibrary(MavenPublication) {            from components.java        }    }    repositories {        maven {            name = &#39;myRepo&#39;            url = &quot;file://${buildDir}/repo&quot;        }    }}</code></pre><p>将上述的配置移植到我们的插件开发项目的build.gradle中，如下：</p><pre><code class="groovy">plugins {    id &#39;groovy&#39;    id &#39;maven-publish&#39;}group = &quot;com.william.customplugin&quot;version = &quot;1.0&quot;publishing {    publications {        myLibrary(MavenPublication) {            from components.java        }    }    //仓库配置    repositories {        maven {            //name这个属性是用来指定仓库名字的，貌似在这里没什么用，注释掉。            //name = &#39;myRepo&#39;            //指定发布仓库的路径            url = &quot;./build/repo&quot;        }    }}dependencies {    implementation fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    implementation gradleApi()    implementation localGroovy()}sourceCompatibility = &quot;7&quot;targetCompatibility = &quot;7&quot;</code></pre><p>接下来就是执行一个task，来构建并发布了。</p><p><code>maven-publish</code>脚本带来了task <code>publish</code>，他会执行所有的发布任务。而我们这里只有一个发布任务，所以执行他就好了。</p><pre><code class="shell">gradlew publish===&gt;14:45:49: Executing task &#39;publish&#39;...Executing tasks: [publish] in project C:\AndroidProject\KotlinSimpleTest\customPlugin&gt; Task :customPlugin:generatePomFileForMyLibraryPublication&gt; Task :customPlugin:compileJava UP-TO-DATE&gt; Task :customPlugin:compileGroovy NO-SOURCE&gt; Task :customPlugin:processResources UP-TO-DATE&gt; Task :customPlugin:classes UP-TO-DATE&gt; Task :customPlugin:jar UP-TO-DATE&gt; Task :customPlugin:publishMyLibraryPublicationToMavenRepository&gt; Task :customPlugin:publishBUILD SUCCESSFUL in 4s5 actionable tasks: 2 executed, 3 up-to-date14:45:53: Task execution finished &#39;publish&#39;.</code></pre><p>OK，现在跑去<code>./build/repo</code>下面找我们的软件包吧。</p><pre><code>├─repo│  └─com│      └─william│          └─customplugin│              └─customPlugin│                  │  maven-metadata.xml│                  │  maven-metadata.xml.md5│                  │  maven-metadata.xml.sha1│                  ││                  └─1.0│                          customPlugin-1.0.jar│                          customPlugin-1.0.jar.md5│                          customPlugin-1.0.jar.sha1│                          customPlugin-1.0.pom│                          customPlugin-1.0.pom.md5│                          customPlugin-1.0.pom.sha1</code></pre><p>输出的整个包多了很多东西<del>，我们用普通的<code>build</code>命令打出来的jar包，只有一个单独的jar包，而用<code>maven-publish</code>插件打出来的包，囊括了完整的全路径名，带有pom文件用于描述依赖，带有maven元数据等等，这是一个完整的、可用于分发的软件了</del></p><h4 id="2-3-在插件消费者项目中使用插件-1"><a href="#2-3-在插件消费者项目中使用插件-1" class="headerlink" title="2.3 在插件消费者项目中使用插件"></a>2.3 在插件消费者项目中使用插件</h4><h5 id="2-3-1-直接使用本地的jar包中的插件。-1"><a href="#2-3-1-直接使用本地的jar包中的插件。-1" class="headerlink" title="2.3.1 直接使用本地的jar包中的插件。"></a>2.3.1 直接使用本地的jar包中的插件。</h5><p>拿到jar包后，把他放在一个可以被找到的路径，我把他放在了插件消费者项目的根目录的<code>gradle_plugin_libs/</code>目录下。</p><pre><code>└─gradle_plugin_libs        customPlugin.jar</code></pre><p>一般来说，安卓项目都采用的是gradle的multi-project-build组织类型，所以我打算在根目录下让gradle对我的脚本进行一个依赖，以便子项目不需要再自己去声明对脚本的依赖。</p><p>即<code>rootProject/build.gradle</code>下：</p><pre><code class="groovy">buildscript{    repositories{        //...    }    dependencies{        classpath &#39;com.android.tools.build:gradle:3.4.1&#39;        //...        //注意，之类不能用classpath，因为classpath指定的是以标准的maven格式构建的软件包。        //我们这里是直接用jar的，classpath识别不了，会报错。因此用classpath files()        classpath files (&#39;./gradle_plugin_libs/customPlugin.jar&#39;)    }}//..</code></pre><p>随意地找一个项目的构建脚本，写上：<code>apply plugin: &#39;com.william.customplugin&#39;</code>。（注意，插件Id是properties文件的名字）</p><p>执行命令：<code>gradlew hello</code>–&gt;  输出： task hello—doLast</p><p>大功告成~</p><h5 id="2-3-2-使用本地maven仓库下的jar包中的插件-1"><a href="#2-3-2-使用本地maven仓库下的jar包中的插件-1" class="headerlink" title="2.3.2 使用本地maven仓库下的jar包中的插件"></a>2.3.2 使用本地maven仓库下的jar包中的插件</h5><p>将2.2.2节构建出的软件包整个复制到<code>gradle_plugin_libs/</code>中。</p><p>修改根目录构建脚本：<code>rootProject/build.gradle</code></p><pre><code class="groovy">buildscript{    repositories{        //...        //指定一个maven仓库的路径        maven {            url uri(&#39;./gradle_plugin_libs&#39;)        }    }    dependencies{        //...        //用标准的classpath方法，来找到我们的插件        classpath(&#39;com.william.customplugin:customPlugin:1.0&#39;)    }}//..</code></pre><p>执行<code>gradlew hello</code>，输出和上一节一样。</p><p>大功告成~</p><h4 id="2-4-如何测试插件？-1"><a href="#2-4-如何测试插件？-1" class="headerlink" title="2.4 如何测试插件？"></a>2.4 如何测试插件？</h4><p>待补充</p><h3 id="3-在独立的项目中开发一个插件，远程依赖-1"><a href="#3-在独立的项目中开发一个插件，远程依赖-1" class="headerlink" title="3 在独立的项目中开发一个插件，远程依赖"></a>3 在独立的项目中开发一个插件，远程依赖</h3><p>上面我们对插件进行了本地依赖的方式来使用，现在我们将我们的插件打出的软件包上传到远程仓库上，让别的开发者也能快速地集成。</p><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4>]]></content>
    
    
    <categories>
      
      <category>Gradle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu-打开管理员权限的文件浏览器</title>
    <link href="/2019/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ubuntu-%E6%89%93%E5%BC%80%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E7%9A%84%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <url>/2019/09/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ubuntu-%E6%89%93%E5%BC%80%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E7%9A%84%E6%96%87%E4%BB%B6%E6%B5%8F%E8%A7%88%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>我用在使用VMWare创建ubuntu16的虚拟机的时候，配置AndroidStudio环境时，遇到了无法写入<code>/~/.android</code>的错误，我用文件浏览器打开，发现该文件居然没有访问权限。（我以前装转系统的16和18没遇到过），因此我需要修改该文件的读写权限，但是当前模式无法修改，因为该文件属于root用户。<br>因此我需要以root身份打开文件浏览器修改该文件的读写权限。<br>执行：</p><pre><code class="bash">$ sudo nautilus</code></pre><p>弹出的文件浏览器可以执行最高权限的读写操作。<br></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ndk：还用不用armeabi</title>
    <link href="/2019/08/27/ndk/ndk%EF%BC%9A%E8%BF%98%E7%94%A8%E4%B8%8D%E7%94%A8armeabi/"/>
    <url>/2019/08/27/ndk/ndk%EF%BC%9A%E8%BF%98%E7%94%A8%E4%B8%8D%E7%94%A8armeabi/</url>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/28926101/is-it-safe-to-support-only-armeabi-v7a-for-android-4-and-above/28926267#28926267" target="_blank" rel="noopener">https://stackoverflow.com/questions/28926101/is-it-safe-to-support-only-armeabi-v7a-for-android-4-and-above/28926267#28926267</a></p><p><a href="https://android.stackexchange.com/questions/34958/what-are-the-minimum-hardware-specifications-for-android" target="_blank" rel="noopener">https://android.stackexchange.com/questions/34958/what-are-the-minimum-hardware-specifications-for-android</a></p><p><a href="https://www.reddit.com/r/androiddev/comments/5u64yh/which_abi_should_the_app_support/" target="_blank" rel="noopener">https://www.reddit.com/r/androiddev/comments/5u64yh/which_abi_should_the_app_support/</a></p><ol><li>安卓4.0之后之后安卓官方源码不再支持armeabi。（我们的minSdk是4.1）</li><li>安卓4.4之后强制要求armv7处理器。</li><li>根据报告： <a href="https://androidbycode.wordpress.com/tag/armeabi-v7a/" target="_blank" rel="noopener">https://androidbycode.wordpress.com/tag/armeabi-v7a/</a>。在2015年（4年前了），7998台设备中仅有12台设备是armeabi。<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>ndk</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>C语言学习笔记</title>
    <link href="/2019/08/12/C/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/08/12/C/C%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-C的预处理器"><a href="#1-C的预处理器" class="headerlink" title="1. C的预处理器"></a>1. C的预处理器</h2><h3 id="h头文件"><a href="#h头文件" class="headerlink" title=".h头文件"></a>.h头文件</h3><pre><code class="c">//文件名：main.c#include &lt;stdio.h&gt;int main(void){    ...}</code></pre><p><code>#include</code>是C语言的预处理指令，C语言编译器在编译前会对源码进行预处理工作。他的作用就是把所有头文件中的内容，完全copy进入当前的<code>.c</code>文件中。</p><p>一般头文件中定义一些常量或者函数，而其函数实现在另一个文件中。那么，编译完成之后，C的连接器就会将这个<code>main.c</code>文件中用到的其他库中的文件给提取出来，一起和当前的<code>main.c</code>文件组合成一个二进制的可执行文件<code>xxx.exe</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-a4adc197d23d3697.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><h3 id="defin定义常量"><a href="#defin定义常量" class="headerlink" title="#defin定义常量"></a>#defin定义常量</h3><p>通用格式：<code>#define NAME value</code>（没有=号，结尾没有分号）</p><p>在编译程序的时候，程序中所有引用<code>NAME</code>变量的地方都会被替换成<code>value</code>，该过程称为：编译时替换。程序在运行时，所有替换均已完成，这样定义的常量叫做明示常量。</p><h2 id="2-数据类型"><a href="#2-数据类型" class="headerlink" title="2. 数据类型"></a>2. 数据类型</h2><h3 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h3><p>C99添加了<code>_Bool</code>类型，因为C语言用1表示true，用0表示false，所以<code>_Bool</code>也是一种整数类型。</p><p>此外，凡是非0的int类型，都可以表示true，而整数0表示false。示例代码：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(void) {    int a = 3 &gt; 1;    int b = 3 &lt; 1;    printf(&quot;%d&quot;, a);    printf(&quot;\n&quot;);    printf(&quot;%d&quot;, b);    printf(&quot;\n&quot;);    int c = 3;    if (c) {        printf(&quot;凡是非0的整数，都视为true&quot;);    }    printf(&quot;\n&quot;);    int d = 0;    if (!d) {        printf(&quot;而整数0刚好表示false&quot;);    }}打印：10凡是非0的整数，都视为true而整数0刚好表示false</code></pre><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。且char数组中的最后一个元素一定是空字符<code>\0，</code>标志着字符串的结束。</p><p>那么如果<code>char stringA[40]</code>的字符串变量<code>stringA</code>，只能放下39个字符。</p><p>注意，C语言中声明数组的方式和java不一样，Java中可以用<code>int[] a</code>的方式声明数组变量，而C中一定要用<code>int a[]</code>的方式来声明。</p><p>那么单个字符的字符串和字符的区别是什么？</p><p>例如<code>‘X’</code>和<code>&quot;X&quot;</code>的区别？区别在于，字符串类型的“X”是用数组来存储的，最后会有一个空字符<code>\0</code>，即会占两个字符的空间。</p><h2 id="3-指针"><a href="#3-指针" class="headerlink" title="3. 指针"></a>3. 指针</h2><h3 id="3-1-定义"><a href="#3-1-定义" class="headerlink" title="3.1 定义"></a>3.1 定义</h3><h4 id="取变量的指针：-amp"><a href="#取变量的指针：-amp" class="headerlink" title="取变量的指针：&amp;"></a>取变量的指针：&amp;</h4><p>后面跟一个变量名时，&amp;给出该变量的地址（或指针）。</p><p>&amp;取出的地址可以直接赋值给指针，那么就可以这样写：</p><pre><code class="c">int value=10;int *pointerOfValue=&amp;value;</code></pre><p>那么变量<code>pointerOfValue</code>就是指向<code>value</code>变量的指针。那么&amp;可以直接理解为取一个变量的指针。</p><p>注意，一个变量的指针只能读不能写，因为一个变量的内存地址（指针）是唯一的，你只能读取，你不能写入。</p><h4 id="取指针指向的变量："><a href="#取指针指向的变量：" class="headerlink" title="取指针指向的变量：*"></a>取指针指向的变量：*</h4><p>后面跟一个指针变量或者地址时，*给出存储在指针指向地址上的值。</p><p>*运算符是直接作用在指针变量上的，返回指针指向的值：</p><pre><code class="c">int valueB=*pointerOfValue;</code></pre><p>例如这个<code>valueB</code>，此时就等于10。</p><p>注意，*运算符可以用来被指针变量用来读值，当然也能用来写入新的值。</p><h3 id="3-2-指针变量声明"><a href="#3-2-指针变量声明" class="headerlink" title="3.2 指针变量声明"></a>3.2 指针变量声明</h3><pre><code class="c">//pi变量是指向int类型变量的指针变量。int *pi;、//pc变量是指向char类型变量的指针变量。char *pc;//同上float *pf, *pg;</code></pre><p>注意：<code>int *pi</code>声明了一个<code>pi</code>变量，他本身的类型不是int类型的，他是指针类型，不是基本数据类型了，只是他这样声明表示指向的int类型的内存地址。例如两个指针不能相乘，但是两个整型可以相乘，而且打印的时候，指针类型的变量也要用<code>%p</code>来转换。</p><p>示例：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(void) {    int a = 10;    int *addressOfA = &amp;a;    int valueOfA = *addressOfA;    printf(&quot;%p&quot;, addressOfA);    printf(&quot;\n&quot;);    printf(&quot;%d&quot;, valueOfA);    return 0;}</code></pre><p>打印：</p><pre><code>0x7fff0431fba810</code></pre><h3 id="3-3-指针实战"><a href="#3-3-指针实战" class="headerlink" title="3.3 指针实战"></a>3.3 指针实战</h3><p>原则：如果一个函数要计算或者处理值，那么就直接传递变量的值；如果一个函数要改变主调函数的变量，那么就传递那个变量的引用。</p><p>在面向对象语言如<code>Java</code>或者<code>Kolin</code>中，要在被调函数中改变主调函数的变量，只能通过return语句来实现。而c语言则可以用指针来实现，如下示例：</p><pre><code class="c">#include &lt;stdio.h&gt;void interchange(int *u, int *v);//u和v都是指针，那么通过*运算符就可以读写所指向的变量实际的值。void interchange(int *u, int *v) {    int temp;    temp = *u;    *u = *v;    *v = temp;}int main(void) {    int x = 5, y = 10;    printf(&quot;原先x=%d ,y=%d&quot;, x, y);    interchange(&amp;x, &amp;y);    printf(&quot;\n&quot;);    printf(&quot;现在x= %d,y=%d&quot;, x, y);    return 0;}</code></pre><p>打印：</p><pre><code>原先x=5 ,y=10现在x= 10,y=5</code></pre><p>在许多语言中， 地址都归计算机管， 对程序员隐藏。 然而在 C 中， 可以通过&amp;运算符访问地址， 通过*运算符获得地址上的值</p><h3 id="3-4-指针和数组"><a href="#3-4-指针和数组" class="headerlink" title="3.4 指针和数组"></a>3.4 指针和数组</h3><h4 id="3-4-1-数组变量就是一个指针变量"><a href="#3-4-1-数组变量就是一个指针变量" class="headerlink" title="3.4.1 数组变量就是一个指针变量"></a>3.4.1 数组变量就是一个指针变量</h4><p>例如：</p><pre><code class="c">int intArray[SIZE];</code></pre><p>声明了一个<code>SIZE</code>大小的数组变量，而该数组变量<code>intArray</code>实际上是一个指针变量。该指针变量所指向的值是数组的第一个元素的值，即<code>intArray[0]</code>，而<code>intArrya[0]</code>的元素的指针变量就是数组所代表的指针变量。</p><p>例如：</p><pre><code class="c">//以下语句成立。注：&amp; 表示取变量的指针intArray=&amp;intArray[0];</code></pre><h4 id="3-4-2-指针加1，指针的值递增它所指向的类型的大小。"><a href="#3-4-2-指针加1，指针的值递增它所指向的类型的大小。" class="headerlink" title="3.4.2 指针加1，指针的值递增它所指向的类型的大小。"></a>3.4.2 指针加1，指针的值递增它所指向的类型的大小。</h4><p>例如：</p><pre><code class="c">//声明intint value = 999;//取999变量的指针int *pointerOfInt = &amp;value;//为指针加1pointerOfInt += 1;//打印此时指针所代表的值printf(&quot;----%d&quot;, *pointerOfInt);</code></pre><p>输出：<code>----0</code></p><p>即，当指针加一的时候，指针会顺延着在内存地址上，增加一个单位的所指向的变量的类型的大小的长度。例如这里是int，那么指针加一的时候，指针就往后移动4个字节的大小。</p><p>而数组刚好代表的是一段连续的内存地址，那么当拿到数组第一个元素的指针，又知道了数组的大小，则可以直接使用指针来访问数组了。（得益于数组在内存上是连续的，链表就不行了。）</p><p>如下例子演示了如何使用指针来操纵数组，以及如何把数组直接当成一个指针来使用：</p><pre><code class="c">#include &lt;stdio.h&gt;#define SIZE 4int main(){    //声明数组    int intArray[SIZE];    //遍历，为每个数组分配变量    for (int i = 0; i &lt; SIZE; i++)    {        intArray[i] = 100 + i;    }    //声明指针    int *pointer;    //指针指向数组    pointer = intArray;    //从指针中取出指向的数组intArray的每个元素    for (int i = 0; i &lt; SIZE; i++)    {        int valueTakeFromPointer = *(pointer + i);        printf(&quot;value taken from pointer = %d \n&quot;, valueTakeFromPointer);    }    printf(&quot;------------------------\n&quot;);    //同理，由于数组本身就是指针，那么直接操作数组也可以。    for (int i = 0; i &lt; SIZE; i++)    {        int valueTakeFromPointer = *(intArray + i);        printf(&quot;value taken from pointer = %d \n&quot;, valueTakeFromPointer);    }    return 0;}</code></pre><p>打印：</p><pre><code class="c">@&quot;value taken from pointer = 100 \r\n&quot;@&quot;value taken from pointer = 101 \r\n&quot;@&quot;value taken from pointer = 102 \r\n&quot;@&quot;value taken from pointer = 103 \r\n&quot;@&quot;------------------------\r\n&quot;@&quot;value taken from pointer = 100 \r\n&quot;@&quot;value taken from pointer = 101 \r\n&quot;@&quot;value taken from pointer = 102 \r\n&quot;@&quot;value taken from pointer = 103 \r\n&quot;</code></pre><h4 id="3-4-3-二级指针"><a href="#3-4-3-二级指针" class="headerlink" title="3.4.3 二级指针"></a>3.4.3 二级指针</h4><p>二级指针表示：指向指针的指针</p><p>由于指针变量实际上可以表示一个数组，那么指针的指针，实际上可以用来表示指针的数组。</p><p>以下内容来自知乎：</p><p>在C语言中，二级指针有什么用处？</p><ul><li><strong>指针的数组</strong>，尤其是指向 struct 的指针的数组，比如</li></ul><pre><code class="c">typedef struct {...} Record;typedef struct {    size_t length;    Record **records;} RecordList;</code></pre><ul><li><strong>指针的引用</strong>，比如拿来改指针变量</li><li><strong>值类型的二维数组</strong></li></ul><blockquote><p>作者：Belleve<br>链接：<a href="https://www.zhihu.com/question/19831228/answer/130917500" target="_blank" rel="noopener">https://www.zhihu.com/question/19831228/answer/130917500</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="4-存储类别、链接、和内存管理"><a href="#4-存储类别、链接、和内存管理" class="headerlink" title="4 存储类别、链接、和内存管理"></a>4 存储类别、链接、和内存管理</h2><h3 id="4-1-作用域"><a href="#4-1-作用域" class="headerlink" title="4.1 作用域"></a>4.1 作用域</h3><ol><li><p>块作用域</p></li><li><p>函数作用域</p></li><li><p>函数原型作用域</p></li><li><p>文件作用域</p><p>文件作用域的变量也叫全局变量，存在于整个程序的运行周期。</p><pre><code class="c">#include &lt;stdio.h&gt;//units变量就是文件作用域的变量。int units=0;int main(void){    ...}</code></pre></li></ol><h3 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><p>c的变量有三种链接属性：</p><ol><li><p>外部链接。</p><p>可以被外部的文件所使用。</p><pre><code class="c">int a=1;int main(void){}</code></pre></li><li><p>内部链接。</p><p>只能在当前的文件中使用。</p><pre><code class="c">static int a=1;int main(void){}</code></pre></li><li><p>无连接。</p><p>块作用域，函数作用域，函数原型作用域的变量，都是无连接的。</p></li></ol><h3 id="4-3-存储期"><a href="#4-3-存储期" class="headerlink" title="4.3 存储期"></a>4.3 存储期</h3><ol><li><p>静态存储期</p><p>静态存储期的对象在程序执行的期间一直存在。文件作用域的变量具有静态存储期。</p></li><li><p>线程存储期</p><p>线程存储期的对象，从被声明时到线程结束都一直存在。以关键字_Thread_local声明一个对象时，每个线程都将获得该变量的私有备份。</p></li><li><p>自动存储期</p><p>块作用域的变量通常有自动存储期。进入块时为变量分配内存，退出块时释放刚才分配的内存。</p><p>一般在方法块中声明的变量都是自动存储期的，但是块作用域变量也能具有静态存储期。例如：</p><pre><code class="c">void more(int number){    int index;    static int ct=0;    //...    return 0;}</code></pre><p>上述代码中，变量ct存储在静态内存中，它从程序被载入到程序结束期间都存在，。但是他的作用域在more()函数中，那么只有执行more的时候，程序才能用ct来访问他所指定的对（但是， 该函数可以给其他函数提供该存储<br>区的地址以便间接访问该对象， 例如通过指针形参或返回值）。</p></li><li><p>动态分配存储期</p></li></ol><h3 id="4-4-5种存储类"><a href="#4-4-5种存储类" class="headerlink" title="4.4 5种存储类"></a>4.4 5种存储类</h3><p><img src="https://upload-images.jianshu.io/upload_images/7177220-ad48776eedd5fc15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><h3 id="4-5-块作用域的静态变量"><a href="#4-5-块作用域的静态变量" class="headerlink" title="4.5 块作用域的静态变量"></a>4.5 块作用域的静态变量</h3><ol><li>静态变量分为两种：①文件类变量：直接定义在文件里面的变，拥有全局声明周期。②用static关键字作前缀的变量，当他定义在文件中时，他是仅该文件可见的全局变量；当他定义在块或者方法里面时，他是当前块中可见的全局变量。</li><li>静态变量的初始化在程序被载入内存时已经执行完毕，他们只在编译的时候被初始化一次。（因此在方法中的静态变量之初始化一次，在运行时不会重复初始化的）</li></ol><h3 id="4-6-外部链接的静态变量"><a href="#4-6-外部链接的静态变量" class="headerlink" title="4.6 外部链接的静态变量"></a>4.6 外部链接的静态变量</h3><p>外部链接的静态变量具有文件作用域、 外部链接和静态存储期</p><p>当然， 为了指出该函数使用了外部变量， 可以在函数中用关键字extern再次声明。 如果一个源代码文件使用的外部变量定义在另一个源代码文件中， 则必须用extern在该文件中声明该变量。<br>   printf(“%d”, b);<br>    printf(“\n”);</p><pre><code>int c = 3;if (c) {    printf(&quot;凡是非0的整数，都视为true&quot;);}printf(&quot;\n&quot;);int d = 0;if (!d) {    printf(&quot;而整数0刚好表示false&quot;);}</code></pre><p>}</p><p>打印：<br>1<br>0<br>凡是非0的整数，都视为true<br>而整数0刚好表示false</p><pre><code>### 字符串类型C语言没有专门用于存储字符串的变量类型，字符串都被存储在char类型的数组中。且char数组中的最后一个元素一定是空字符`\0，`标志着字符串的结束。那么如果`char stringA[40]`的字符串变量`stringA`，只能放下39个字符。注意，C语言中声明数组的方式和java不一样，Java中可以用`int[] a`的方式声明数组变量，而C中一定要用`int a[]`的方式来声明。那么单个字符的字符串和字符的区别是什么？例如`‘X’`和`&quot;X&quot;`的区别？区别在于，字符串类型的“X”是用数组来存储的，最后会有一个空字符`\0`，即会占两个字符的空间。## 3. 指针### 3.1 定义#### 取变量的指针：&amp;后面跟一个变量名时，&amp;给出该变量的地址（或指针）。&amp;取出的地址可以直接赋值给指针，那么就可以这样写：``` cint value=10;int *pointerOfValue=&amp;value;</code></pre><p>那么变量<code>pointerOfValue</code>就是指向<code>value</code>变量的指针。那么&amp;可以直接理解为取一个变量的指针。</p><p>注意，一个变量的指针只能读不能写，因为一个变量的内存地址（指针）是唯一的，你只能读取，你不能写入。</p><h4 id="取指针指向的变量：-1"><a href="#取指针指向的变量：-1" class="headerlink" title="取指针指向的变量：*"></a>取指针指向的变量：*</h4><p>后面跟一个指针变量或者地址时，*给出存储在指针指向地址上的值。</p><p>*运算符是直接作用在指针变量上的，返回指针指向的值：</p><pre><code class="c">int valueB=*pointerOfValue;</code></pre><p>例如这个<code>valueB</code>，此时就等于10。</p><p>注意，*运算符可以用来被指针变量用来读值，当然也能用来写入新的值。</p><h3 id="3-2-指针变量声明-1"><a href="#3-2-指针变量声明-1" class="headerlink" title="3.2 指针变量声明"></a>3.2 指针变量声明</h3><pre><code class="c">//pi变量是指向int类型变量的指针变量。int *pi;、//pc变量是指向char类型变量的指针变量。char *pc;//同上float *pf, *pg;</code></pre><p>注意：<code>int *pi</code>声明了一个<code>pi</code>变量，他本身的类型不是int类型的，他是指针类型，不是基本数据类型了，只是他这样声明表示指向的int类型的内存地址。例如两个指针不能相乘，但是两个整型可以相乘，而且打印的时候，指针类型的变量也要用<code>%p</code>来转换。</p><p>示例：</p><pre><code class="c">#include &lt;stdio.h&gt;int main(void) {    int a = 10;    int *addressOfA = &amp;a;    int valueOfA = *addressOfA;    printf(&quot;%p&quot;, addressOfA);    printf(&quot;\n&quot;);    printf(&quot;%d&quot;, valueOfA);    return 0;}</code></pre><p>打印：</p><pre><code>0x7fff0431fba810</code></pre><h3 id="3-3-指针实战-1"><a href="#3-3-指针实战-1" class="headerlink" title="3.3 指针实战"></a>3.3 指针实战</h3><p>原则：如果一个函数要计算或者处理值，那么就直接传递变量的值；如果一个函数要改变主调函数的变量，那么就传递那个变量的引用。</p><p>在面向对象语言如<code>Java</code>或者<code>Kolin</code>中，要在被调函数中改变主调函数的变量，只能通过return语句来实现。而c语言则可以用指针来实现，如下示例：</p><pre><code class="c">#include &lt;stdio.h&gt;void interchange(int *u, int *v);//u和v都是指针，那么通过*运算符就可以读写所指向的变量实际的值。void interchange(int *u, int *v) {    int temp;    temp = *u;    *u = *v;    *v = temp;}int main(void) {    int x = 5, y = 10;    printf(&quot;原先x=%d ,y=%d&quot;, x, y);    interchange(&amp;x, &amp;y);    printf(&quot;\n&quot;);    printf(&quot;现在x= %d,y=%d&quot;, x, y);    return 0;}</code></pre><p>打印：</p><pre><code>原先x=5 ,y=10现在x= 10,y=5</code></pre><p>在许多语言中， 地址都归计算机管， 对程序员隐藏。 然而在 C 中， 可以通过&amp;运算符访问地址， 通过*运算符获得地址上的值</p><h3 id="3-4-指针和数组-1"><a href="#3-4-指针和数组-1" class="headerlink" title="3.4 指针和数组"></a>3.4 指针和数组</h3><h4 id="3-4-1-数组变量就是一个指针变量-1"><a href="#3-4-1-数组变量就是一个指针变量-1" class="headerlink" title="3.4.1 数组变量就是一个指针变量"></a>3.4.1 数组变量就是一个指针变量</h4><p>例如：</p><pre><code class="c">int intArray[SIZE];</code></pre><p>声明了一个<code>SIZE</code>大小的数组变量，而该数组变量<code>intArray</code>实际上是一个指针变量。该指针变量所指向的值是数组的第一个元素的值，即<code>intArray[0]</code>，而<code>intArrya[0]</code>的元素的指针变量就是数组所代表的指针变量。</p><p>例如：</p><pre><code class="c">//以下语句成立。注：&amp; 表示取变量的指针intArray=&amp;intArray[0];</code></pre><h4 id="3-4-2-指针加1，指针的值递增它所指向的类型的大小。-1"><a href="#3-4-2-指针加1，指针的值递增它所指向的类型的大小。-1" class="headerlink" title="3.4.2 指针加1，指针的值递增它所指向的类型的大小。"></a>3.4.2 指针加1，指针的值递增它所指向的类型的大小。</h4><p>例如：</p><pre><code class="c">//声明intint value = 999;//取999变量的指针int *pointerOfInt = &amp;value;//为指针加1pointerOfInt += 1;//打印此时指针所代表的值printf(&quot;----%d&quot;, *pointerOfInt);</code></pre><p>输出：<code>----0</code></p><p>即，当指针加一的时候，指针会顺延着在内存地址上，增加一个单位的所指向的变量的类型的大小的长度。例如这里是int，那么指针加一的时候，指针就往后移动4个字节的大小。</p><p>而数组刚好代表的是一段连续的内存地址，那么当拿到数组第一个元素的指针，又知道了数组的大小，则可以直接使用指针来访问数组了。（得益于数组在内存上是连续的，链表就不行了。）</p><p>如下例子演示了如何使用指针来操纵数组，以及如何把数组直接当成一个指针来使用：</p><pre><code class="c">#include &lt;stdio.h&gt;#define SIZE 4int main(){    //声明数组    int intArray[SIZE];    //遍历，为每个数组分配变量    for (int i = 0; i &lt; SIZE; i++)    {        intArray[i] = 100 + i;    }    //声明指针    int *pointer;    //指针指向数组    pointer = intArray;    //从指针中取出指向的数组intArray的每个元素    for (int i = 0; i &lt; SIZE; i++)    {        int valueTakeFromPointer = *(pointer + i);        printf(&quot;value taken from pointer = %d \n&quot;, valueTakeFromPointer);    }    printf(&quot;------------------------\n&quot;);    //同理，由于数组本身就是指针，那么直接操作数组也可以。    for (int i = 0; i &lt; SIZE; i++)    {        int valueTakeFromPointer = *(intArray + i);        printf(&quot;value taken from pointer = %d \n&quot;, valueTakeFromPointer);    }    return 0;}</code></pre><p>打印：</p><pre><code class="c">@&quot;value taken from pointer = 100 \r\n&quot;@&quot;value taken from pointer = 101 \r\n&quot;@&quot;value taken from pointer = 102 \r\n&quot;@&quot;value taken from pointer = 103 \r\n&quot;@&quot;------------------------\r\n&quot;@&quot;value taken from pointer = 100 \r\n&quot;@&quot;value taken from pointer = 101 \r\n&quot;@&quot;value taken from pointer = 102 \r\n&quot;@&quot;value taken from pointer = 103 \r\n&quot;</code></pre><h4 id="3-4-3-二级指针-1"><a href="#3-4-3-二级指针-1" class="headerlink" title="3.4.3 二级指针"></a>3.4.3 二级指针</h4><p>二级指针表示：指向指针的指针</p><p>由于指针变量实际上可以表示一个数组，那么指针的指针，实际上可以用来表示指针的数组。</p><p>以下内容来自知乎：</p><p>在C语言中，二级指针有什么用处？</p><ul><li><strong>指针的数组</strong>，尤其是指向 struct 的指针的数组，比如</li></ul><pre><code class="c">typedef struct {...} Record;typedef struct {    size_t length;    Record **records;} RecordList;</code></pre><ul><li><strong>指针的引用</strong>，比如拿来改指针变量</li><li><strong>值类型的二维数组</strong></li></ul><blockquote><p>作者：Belleve<br>链接：<a href="https://www.zhihu.com/question/19831228/answer/130917500" target="_blank" rel="noopener">https://www.zhihu.com/question/19831228/answer/130917500</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote><h2 id="4-存储类别、链接、和内存管理-1"><a href="#4-存储类别、链接、和内存管理-1" class="headerlink" title="4 存储类别、链接、和内存管理"></a>4 存储类别、链接、和内存管理</h2><h3 id="4-1-作用域-1"><a href="#4-1-作用域-1" class="headerlink" title="4.1 作用域"></a>4.1 作用域</h3><ol><li><p>块作用域</p></li><li><p>函数作用域</p></li><li><p>函数原型作用域</p></li><li><p>文件作用域</p><p>文件作用域的变量也叫全局变量，存在于整个程序的运行周期。</p><pre><code class="c">#include &lt;stdio.h&gt;//units变量就是文件作用域的变量。int units=0;int main(void){    ...}</code></pre></li></ol><h3 id="4-2-链接-1"><a href="#4-2-链接-1" class="headerlink" title="4.2 链接"></a>4.2 链接</h3><p>c的变量有三种链接属性：</p><ol><li><p>外部链接。</p><p>可以被外部的文件所使用。</p><pre><code class="c">int a=1;int main(void){}</code></pre></li><li><p>内部链接。</p><p>只能在当前的文件中使用。</p><pre><code class="c">static int a=1;int main(void){}</code></pre></li><li><p>无连接。</p><p>块作用域，函数作用域，函数原型作用域的变量，都是无连接的。</p></li></ol><h3 id="4-3-存储期-1"><a href="#4-3-存储期-1" class="headerlink" title="4.3 存储期"></a>4.3 存储期</h3><ol><li><p>静态存储期</p><p>静态存储期的对象在程序执行的期间一直存在。文件作用域的变量具有静态存储期。</p></li><li><p>线程存储期</p><p>线程存储期的对象，从被声明时到线程结束都一直存在。以关键字_Thread_local声明一个对象时，每个线程都将获得该变量的私有备份。</p></li><li><p>自动存储期</p><p>块作用域的变量通常有自动存储期。进入块时为变量分配内存，退出块时释放刚才分配的内存。</p><p>一般在方法块中声明的变量都是自动存储期的，但是块作用域变量也能具有静态存储期。例如：</p><pre><code class="c">void more(int number){    int index;    static int ct=0;    //...    return 0;}</code></pre><p>上述代码中，变量ct存储在静态内�</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>IjkPlayer的-&quot;dns_cache_clear&quot;</title>
    <link href="/2019/08/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/IjkPlayer%E7%9A%84-%22dns_cache_clear%22/"/>
    <url>/2019/08/12/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%BC%80%E5%8F%91/IjkPlayer%E7%9A%84-%22dns_cache_clear%22/</url>
    
    <content type="html"><![CDATA[<p>今天遇到了一个在IjkPlayer播放中途切换拉流协议播放失败的问题。</p><p>http-flv协议的拉流地址切换到rtmp协议的拉流地址，播放失败，并报-10000的错误。</p><p>而销毁再重建播放器，则可以播放成功。</p><p>上ijkplayer的issue上面查了同样的几个问题，发现开启如下的选项可以解决问题：</p><pre><code class="java">ijkPlayer.setOption(IjkMediaPlayer.OPT_CATEGORY_FORMAT, &quot;dns_cache_clear&quot;, 1);</code></pre><p>大致原因是：</p><p>rtmp的url为：</p><pre><code>rtmp://abc</code></pre><p>http-flv的url为：</p><pre><code class="java">https:abc.flv</code></pre><p>这两个url指向了相同的ip地址，但是不同的端口号，https的端口号是443，rtmp的端口号是1935。而Ijkplayer应该是对请求的缓存策略有bug，只用了ip地址作为缓存池的key，正确的做法应该是（ip地址+端口号）。</p><p>有人已经改了c层的代码，用ip+port作为key，来解决了缓存的bug。<a href="https://patchwork.ffmpeg.org/patch/10543/mbox/" target="_blank" rel="noopener">https://patchwork.ffmpeg.org/patch/10543/mbox/</a></p><p>而我用的另一种解决方式就是取消掉缓存，就可以解决这个问题。</p><p>参考：</p><p><a href="https://github.com/bilibili/ijkplayer/issues/3990" target="_blank" rel="noopener">http重定向到rtmp，ijkplayer无法播放视频</a></p><p><a href="https://github.com/bilibili/ijkplayer/issues/4810" target="_blank" rel="noopener">cannot play hls after playing rtsp stream</a></p><p><a href="https://github.com/bilibili/ijkplayer/issues/3700" target="_blank" rel="noopener">dns cache 功能有bug，应该以hostname+portstr为key</a></p><p><a href="https://github.com/bilibili/ijkplayer/issues/4510" target="_blank" rel="noopener">ijkplayer对同一个目标ip会复用tcp链接吗？</a><br></p>]]></content>
    
    
    <categories>
      
      <category>音视频开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Https扫盲</title>
    <link href="/2019/08/08/%E7%BD%91%E7%BB%9C/Https%E6%89%AB%E7%9B%B2/"/>
    <url>/2019/08/08/%E7%BD%91%E7%BB%9C/Https%E6%89%AB%E7%9B%B2/</url>
    
    <content type="html"><![CDATA[<p>理解 HTTPS 前需要理解这些概念：明文、密文、密码、密钥、对称加密、非对称加密、摘要、数字签名、数字证书</p><h4 id="密码cipher"><a href="#密码cipher" class="headerlink" title="密码cipher"></a>密码cipher</h4><p>密码学中的密码（cipher）和我们日常生活中所说的密码不太一样，计算机术语『密码 cipher』是一种用于加密或者解密的算法，而我们日常所使用的『密码 password』是一种口令，它是用于认证用途的一组文本字符串，这里我们要讨论的是前者：cipher。</p><h4 id="密钥-key"><a href="#密钥-key" class="headerlink" title="密钥 key"></a>密钥 key</h4><p>密钥是一种参数，它是在使用密码（cipher）算法过程中输入的参数。同一个明文在相同的密码算法和不同的密钥计算下会产生不同的密文。很多知名的密码算法都是公开的，密钥才是决定密文是否安全的重要参数，通常密钥越长，破解的难度越大，比如一个 8 位的密钥最多有 256 种情况，使用穷举法，能非常轻易的破解，知名的 DES 算法使用 56 位的密钥，目前已经不是一种安全的加密算法了，主要还是因为 56 位的密钥太短，在数小时内就可以被破解。密钥分为对称密钥与非对称密钥。</p><h4 id="明文-密文"><a href="#明文-密文" class="headerlink" title="明文 / 密文"></a>明文 / 密文</h4><p>明文（plaintext）是加密之前的原始数据，密文是通过密码（cipher）运算后得到的结果成为密文（ciphertext）</p><h4 id="对称密钥"><a href="#对称密钥" class="headerlink" title="对称密钥"></a>对称密钥</h4><p>对称密钥（Symmetric-key algorithm）又称为共享密钥加密，对称密钥在加密和解密的过程中使用的密钥是相同的，常见的对称加密算法有 DES、3DES、AES、RC5、RC6。对称密钥的优点是计算速度快，但是他也有缺点，密钥需要在通讯的两端共享，让彼此知道密钥是什么对方才能正确解密，如果所有客户端都共享同一个密钥，那么这个密钥就像万能钥匙一样，可以凭借一个密钥破解所有人的密文了，如果每个客户端与服务端单独维护一个密钥，那么服务端需要管理的密钥将是成千上万，这会给服务端带来噩梦</p><h4 id="非对称密钥"><a href="#非对称密钥" class="headerlink" title="非对称密钥"></a>非对称密钥</h4><p>非对称密钥（public-key cryptography），又称为公开密钥加密，服务端会生成一对密钥，一个私钥保存在服务端，仅自己知道，另一个是公钥，公钥可以自由发布供任何人使用。客户端的明文通过公钥加密后的密文需要用私钥解密。非对称密钥在加密和解密的过程的使用的密钥是不同的密钥，加密和解密是不对称的，所以称之为非对称加密。与对称密钥加密相比，非对称加密无需在客户端和服务端之间共享密钥，只要私钥不发给任何用户，即使公钥在网上被截获，也无法被解密，仅有被窃取的公钥是没有任何用处的。常见的非对称加密有 RSA，非对称加解密的过程：</p><ol><li>服务端生成配对的公钥和私钥</li><li>私钥保存在服务端，公钥发送给客户端</li><li>客户端使用公钥加密明文传输给服务端</li><li>服务端使用私钥解密密文得到明文</li></ol><h4 id="数字签名（Digital-Signature）"><a href="#数字签名（Digital-Signature）" class="headerlink" title="数字签名（Digital Signature）"></a>数字签名（Digital Signature）</h4><p>数据在浏览器和服务器之间传输时，有可能在传输过程中被冒充的盗贼把内容替换了，那么如何保证数据是真实服务器发送的而不被调包呢，同时如何保证传输的数据没有被人篡改呢，要解决这两个问题就必须用到数字签名，数字签名就如同日常生活的中的签名一样，一旦在合同书上落下了你的大名，从法律意义上就确定是你本人签的字儿，这是任何人都没法仿造的，因为这是你专有的手迹，任何人是造不出来的。那么在计算机中的数字签名怎么回事呢？数字签名就是用于验证传输的内容是不是真实服务器发送的数据，发送的数据有没有被篡改过，它就干这两件事，是非对称加密的一种应用场景。不过他是反过来用私钥来加密，通过与之配对的公钥来解密。</p><p>第一步：服务端把报文经过 Hash 处理后生成摘要信息 Digest，摘要信息使用私钥 private-key 加密之后就生成签名，服务器把签名连同报文一起发送给客户端。<br>第二步：客户端接收到数据后，把签名提取出来用 public-key 解密，如果能正常的解密出来 Digest2，那么就能确认是对方发的。<br>第三步：客户端把报文 Text 提取出来做同样的 Hash 处理，得到的摘要信息 Digest1，再与之前解密出来的 Digist2 对比，如果两者相等，就表示内容没有被篡改，否则内容就是被人改过了。因为只要文本内容哪怕有任何一点点改动都会 Hash 出一个完全不一样的摘要信息出来。</p><h4 id="数字证书（Certificate-Authority）"><a href="#数字证书（Certificate-Authority）" class="headerlink" title="数字证书（Certificate Authority）"></a>数字证书（Certificate Authority）</h4><p>证书中心用他的私钥对服务端的公钥和其他信息加密，生成了数字证书。</p><p>而客户端用本地内置的“收信人的证书颁发机构列表”中的公钥，对服务端返回的数字证书解密，得到了服务端的公钥。此时服务端和客户端两端用相同的公钥进行加密和解密，两边的通信都是安全可靠的。</p><p>数字证书简称 CA，它由权威机构给某网站颁发的一种认可凭证，这个凭证是被大家（浏览器）所认可的，为什么需要用数字证书呢，难道有了数字签名还不够安全吗？有这样一种情况，就是浏览器无法确定所有的真实服务器是不是真的是真实的，举一个简单的例子：A 厂家给你们家安装锁，同时把钥匙也交给你，只要钥匙能打开锁，你就可以确定钥匙和锁是配对的，如果有人把钥匙换了或者把锁换了，你是打不开门的，你就知道肯定被窃取了，但是如果有人把锁和钥匙替换成另一套表面看起来差不多的，但质量差很多的，虽然钥匙和锁配套，但是你却不能确定这是否真的是 A 厂家给你的，那么这时候，你可以找质检部门来检验一下，这套锁是不是真的来自于 A 厂家，质检部门是权威机构，他说的话是可以被公众认可的（呵呵）。</p><p>同样的， 因为如果有人（张三）用自己的公钥把真实服务器发送给浏览器的公钥替换了，于是张三用自己的私钥执行相同的步骤对文本 Hash、数字签名，最后得到的结果都没什么问题，但事实上浏览器看到的东西却不是真实服务器给的，而是被张三从里到外（公钥到私钥）换了一通。那么如何保证你现在使用的公钥就是真实服务器发给你的呢？我们就用数字证书来解决这个问题。数字证书一般由数字证书认证机构（Certificate Authority）颁发，证书里面包含了真实服务器的公钥和网站的一些其他信息，数字证书机构用自己的私钥加密后发给浏览器，浏览器使用数字证书机构的公钥解密后得到真实服务器的公钥。这个过程是建立在被大家所认可的证书机构之上得到的公钥，所以这是一种安全的方式。<br></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin泛型</title>
    <link href="/2019/07/30/Kotlin/Kotlin%E6%B3%9B%E5%9E%8B/"/>
    <url>/2019/07/30/Kotlin/Kotlin%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Kotlin的泛型比Java更加强大，保障虚拟机运行安全的基础上，功能更加完善。我看了几次泛型都没有记住，回过头来重新梳理总结一番。</p></blockquote><h3 id="定义父类和子类"><a href="#定义父类和子类" class="headerlink" title="定义父类和子类"></a>定义父类和子类</h3><pre><code class="kot">package williaminterface Parent {}interface Parent2 {}open class Person : Parent, Parent2 {}class Child : Person() {}class Child2 : Person() {}</code></pre><h3 id="用Java演示"><a href="#用Java演示" class="headerlink" title="用Java演示"></a>用Java演示</h3><pre><code class="java">//list1中的元素是Person的子类，但是具体是哪一种不好说。List&lt;? extends Person&gt; list1 = new ArrayList&lt;&gt;();//由于不知道具体是Person的哪一个实现类，因此不能往里面添加，只能取出来，起码能确定取出来的一定是Person类型的。Person number = list1.get(0);//list2中的元素都是Person的父类。List&lt;? super Person&gt; list2 = new ArrayList&lt;&gt;();//由于不知道具体是哪一个父类，因此取出来无法指定具体的引用类型，无法取出来。//但是却可以往里面添加Person的子类型，因为即使是子类型，也将会在List中被当做Person这个父类型来安全地被操作。list2.add(new Person());list2.add(new Child());/*总结：一个类用 ? extends T 指定泛型，那么这个泛型只能被输出。（取出来知道是T的子类）一个类用 ? super T   指定泛型，那么这个泛型只能被输入。（可以放T的子类进去） */</code></pre><h3 id="用Kotlin演示"><a href="#用Kotlin演示" class="headerlink" title="用Kotlin演示"></a>用Kotlin演示</h3><p>用Kotlin完成上面Java做的同样的事情。</p><pre><code class="kotlin">val outList: ArrayList&lt;out Person&gt; = ArrayList()val person: Person = outList.get(0)val inList: ArrayList&lt;in Person&gt; = ArrayList()inList.add(Child())inList.add(Child2())/*************Java做不到，而Kotlin可以做到的事情********************///Person的子类一定更是Parent的子类。用更加抽象的Parent引用，没有任何问题//输出的类型越来越抽象，安全。val parentOutList: ArrayList&lt;out Parent&gt; = outList//Person的父类一定更加是Child的父类。输入更加具体的Child类，没有任何问题//输入的类型越来越具体，安全。val childInList: ArrayList&lt;in Child&gt; = inList</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android修改应用包名和ApplicationId：实战和理解</title>
    <link href="/2019/07/25/Android/Android%E4%BF%AE%E6%94%B9%E5%BA%94%E7%94%A8%E5%8C%85%E5%90%8D%E5%92%8CApplicationId%EF%BC%9A%E5%AE%9E%E6%88%98%E5%92%8C%E7%90%86%E8%A7%A3/"/>
    <url>/2019/07/25/Android/Android%E4%BF%AE%E6%94%B9%E5%BA%94%E7%94%A8%E5%8C%85%E5%90%8D%E5%92%8CApplicationId%EF%BC%9A%E5%AE%9E%E6%88%98%E5%92%8C%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>今天遇到了一个需求是，要改应用的applicationId然后上架，那么我以前的做法是将应用的包名一起给改了，让包名和applicationId统一。但是我今天想了一下，是否可以不改包名，只改appId，那么后期就不用维护两套差异比较大的代码了，毕竟改了包名，包的结构会发生改变，那么git分支合并就会有比较多的冲突了。</p><p><strong>结论</strong>：可以只改build.gradle中的applicationId来改包名，因为后者会覆盖掉Manifest文件中的<package>，但是有使用的限制场景（文末指出了限制场景）。</p><h3 id="1-理解Manifest中定义的包名和gradle中定义的applicationId的差异"><a href="#1-理解Manifest中定义的包名和gradle中定义的applicationId的差异" class="headerlink" title="1. 理解Manifest中定义的包名和gradle中定义的applicationId的差异"></a>1. 理解Manifest中定义的包名和gradle中定义的applicationId的差异</h3><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>在gradle构建apk的最后一步时，会将build.gradle中的applicationId，覆盖AndroidManifest.xml中定义的<package>，这样应用的ID就以gradle中指定的为准。而Manifest中指定的<package>，则影响的是真正的Java类目录，包括编译时的类目录和编译后生成的apk中的class文件的类路径。</p><h4 id="1-1-Manifest中的包名"><a href="#1-1-Manifest中的包名" class="headerlink" title="1.1 Manifest中的包名"></a>1.1 Manifest中的包名</h4><h5 id="1-1-1-打包前后的表现"><a href="#1-1-1-打包前后的表现" class="headerlink" title="1.1.1 打包前后的表现"></a>1.1.1 打包前后的表现</h5><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;          package=&quot;com.william.changepackage&quot;&gt;    &lt;application            android:allowBackup=&quot;true&quot;            android:icon=&quot;@mipmap/ic_launcher&quot;            android:label=&quot;@string/app_name&quot;            android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;            android:supportsRtl=&quot;true&quot;            android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>Manifest中的包名指的就是package=””中的内容，在创建一个项目的时候，就会指定这个值，并且这个值默认是和gradle中定义的applicationId是一致的。</p><pre><code class="groovy">android {    //...    defaultConfig {        applicationId &quot;com.william.changepackage&quot;         //...    }    //...}</code></pre><p>那么看看此时的项目结构：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-1bc8484aec790c40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>打一个debug包看看：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-5b88e27cc6d00233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p><code>BuildConfig</code>类和<code>R.java</code>类都是生成在<code>/包名/</code>路径下的。</p><p>而apk中，合并了的最终的Manifest:</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:versionCode=&quot;1&quot;    android:versionName=&quot;1.0&quot;    android:compileSdkVersion=&quot;28&quot;    android:compileSdkVersionCodename=&quot;9&quot;    package=&quot;com.william.changepackage&quot;    platformBuildVersionCode=&quot;28&quot;    platformBuildVersionName=&quot;9&quot;&gt;    &lt;uses-sdk        android:minSdkVersion=&quot;16&quot;        android:targetSdkVersion=&quot;28&quot; /&gt;    &lt;application        android:theme=&quot;@ref/0x7f0c0005&quot;        android:label=&quot;@ref/0x7f0b0027&quot;        android:icon=&quot;@ref/0x7f0a0000&quot;        android:debuggable=&quot;true&quot;        android:testOnly=&quot;true&quot;        android:allowBackup=&quot;true&quot;        android:supportsRtl=&quot;true&quot;        android:roundIcon=&quot;@ref/0x7f0a0001&quot;        android:appComponentFactory=&quot;android.support.v4.app.CoreComponentFactory&quot;&gt;        &lt;activity            android:name=&quot;com.william.changepackage.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action                    android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category                    android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>注意，这里的<code>MainActivity</code>的声明，在编写的时候是没有加上包名前缀的，合并成最终的Manifest加上了，加的就是类路径，也就是Manifest合并前的<package>。</p><h5 id="1-1-2-存在的意义"><a href="#1-1-2-存在的意义" class="headerlink" title="1.1.2 存在的意义"></a>1.1.2 存在的意义</h5><p>Manifest中的<package>存在的意义是，<code>BuildConfig.java</code>，<code>R.java</code>等文件，都是在编译期生成的，那么这些文件生成了要放在哪里？放在我们的类路径中让我们的类能引用到<code>R.java</code>中定义的资源变量。那么<code>R.java</code>就需要被指明一个路径来生成，这就是<package>的意义，如果把<pakcage>随便写一个路径，然后打包，会遇到：</p><pre><code>项目路径\changePackage\app\src\main\java\com\william\changepackage\MainActivity.kt: (10, 24): Unresolved reference: R</code></pre><p>意思是<code>MainActivity.java</code>没办法引用到<code>R.java</code>了，因为<code>R.java</code>生成在了一个<code>MainActivity.java</code>无法识别的路径（即乱写的那个路径）。无法打包。</p><h5 id="1-1-3-书写规则"><a href="#1-1-3-书写规则" class="headerlink" title="1.1.3 书写规则"></a>1.1.3 书写规则</h5><p>项目的类路径是什么，Manifest的<package>就怎么写，两边保持一致。</p><h4 id="1-2-gradle中的applicationId"><a href="#1-2-gradle中的applicationId" class="headerlink" title="1.2 gradle中的applicationId"></a>1.2 gradle中的applicationId</h4><p>applicationId就是用来表明应用ID的，就是应用市场上面的appId，应用区分于别的应用的唯一标志。</p><p>他与类路径无任何关系，你指定什么都不会影响类路径。</p><h5 id="1-2-1-完全修改applicationId"><a href="#1-2-1-完全修改applicationId" class="headerlink" title="1.2.1 完全修改applicationId"></a>1.2.1 完全修改applicationId</h5><p>我把</p><pre><code class="groovy">android {    //...    defaultConfig {        applicationId &quot;com.william.changepackage&quot;         //...    }    //...}</code></pre><p>改成了</p><pre><code class="groovy">android {    //...    defaultConfig {        applicationId &quot;how.are.you&quot;         //...    }    //...}</code></pre><p>编译-&gt;打包-&gt;检查apk：</p><p>先看apk中的manifest文件：</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:versionCode=&quot;1&quot;    android:versionName=&quot;1.0&quot;    android:compileSdkVersion=&quot;28&quot;    android:compileSdkVersionCodename=&quot;9&quot;    package=&quot;how.are.you&quot;    platformBuildVersionCode=&quot;28&quot;    platformBuildVersionName=&quot;9&quot;&gt;    &lt;uses-sdk        android:minSdkVersion=&quot;16&quot;        android:targetSdkVersion=&quot;28&quot; /&gt;    &lt;application        android:theme=&quot;@ref/0x7f0c0005&quot;        android:label=&quot;@ref/0x7f0b0027&quot;        android:icon=&quot;@ref/0x7f0a0000&quot;        android:debuggable=&quot;true&quot;        android:testOnly=&quot;true&quot;        android:allowBackup=&quot;true&quot;        android:supportsRtl=&quot;true&quot;        android:roundIcon=&quot;@ref/0x7f0a0001&quot;        android:appComponentFactory=&quot;android.support.v4.app.CoreComponentFactory&quot;&gt;        &lt;activity            android:name=&quot;com.william.changepackage.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action                    android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category                    android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><ol><li><package>的确被覆盖成了how.are.you。</li><li><code>MainActivity</code>的声明依然保留的是原本的类路径的前缀，而不是新的how.are.you.MainActivity。（改成新的了就会出问题了不是吗）</li></ol><p>查看一下classes.dex</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-319ce6452fe0af06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>类路径没有改变，依然是编译前类路径什么样现在类路径还是什么样。</p><h5 id="1-2-2-存在的意义"><a href="#1-2-2-存在的意义" class="headerlink" title="1.2.2 存在的意义"></a>1.2.2 存在的意义</h5><p>以前用Eclispse开发的时候，不用build.gradle，那时候的包名就等同于应用名。没有却别。</p><p>但是后来AndroidStudio开发，引入了gradle这个高级的构建系统，gradle支持applicationId，因为你可以这样操作：</p><pre><code class="groovy">android {    defaultConfig {        applicationId &quot;com.example.myapp&quot;    }    productFlavors {        free {            applicationIdSuffix &quot;.free&quot;        }        pro {            applicationIdSuffix &quot;.pro&quot;        }    }}</code></pre><p>来对免费和付费版app发布不同的应用到应用商店。</p><p>或者用</p><pre><code class="groovy">android {    ...    buildTypes {        debug {            applicationIdSuffix &quot;.debug&quot;        }    }}</code></pre><p>这样debug和release包的appID不一样，那么就可以同时在一个设备装发布版和调试版应用了。</p><h5 id="1-2-3-书写规则"><a href="#1-2-3-书写规则" class="headerlink" title="1.2.3 书写规则"></a>1.2.3 书写规则</h5><ul><li>必须至少包含两段（一个或多个圆点）。</li><li>每段必须以字母开头。</li><li>所有字符必须为字母数字或下划线 [a-zA-Z0-9_]</li></ul><h3 id="2-applicationId的限制"><a href="#2-applicationId的限制" class="headerlink" title="2. applicationId的限制"></a>2. applicationId的限制</h3><p>Android文档中提示：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-6d225361d587e5e6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>我点进到<a href="https://issuetracker.google.com/issues/37102241" target="_blank" rel="noopener">问题211768</a>：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-a96b5f1885783872.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-4af40e2e13595575.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>当WebView加载<code>file:///android_res/URLS</code>这种资源的时候，他的工作方式是，通过查找app的package name来找到R.java文件，从而引用res/下的资源，然而，当applicationId和package不同时，后者会在生成apk之前被覆盖掉，导致WebView查找不到这个资源，无法正常工作。</p><p>所幸，这个WebView的bug被部分地修复了，只要你的applicatIionId和包名拥有相同的前缀，那么就能被识别到。（我猜是他会从左到右根据”.”分隔符去查找R.java资源文件）</p><p>所以，最保险的做法是，applicationId的前缀和包名完全相同。</p><p>如果要和包名不一样，那么就保证应用中的WebView不要用<code>file:///android_res/URLS</code>这种方式去引用资源，可以放在assets目录中。<br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Package-Name-vs--Application-ID-–-Styling-Android</title>
    <link href="/2019/07/25/%E5%A4%96%E6%96%87%E6%90%AC%E8%BF%90/Package-Name-vs--Application-ID-%E2%80%93-Styling-Android/"/>
    <url>/2019/07/25/%E5%A4%96%E6%96%87%E6%90%AC%E8%BF%90/Package-Name-vs--Application-ID-%E2%80%93-Styling-Android/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文地址 <a href="https://blog.stylingandroid.com/package-name-vs-application-id/" target="_blank" rel="noopener">https://blog.stylingandroid.com/package-name-vs-application-id/</a></p></blockquote><p>All Android developers should understand that the Package Name that we choose for our app is very important. I’m referring to the Package Name of the application itself (which gets declared in the Manifest) rather than the Java package name (although often they will be identical. It was only recently, when I was tackling a somewhat obscure issue as part of my day job, that I realised that there is actually a subtle, but important, difference between the Package Name and the Application ID. In this article we’ll look at the difference between the two.  </p><p><a href="https://i2.wp.com/blog.stylingandroid.com/wp-content/uploads/2017/02/box.png?ssl=1" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/7177220-f2945e2ab187c3f2.25&resize=150,150&ssl=1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></a>Let’s begin with a reminder of the basics. The Package Name is, as we’ve already mentioned, defined as part of the Manifest and represents the identity of any given app both on an individual device, and on the Google Play store (or any other app store for that matter). Therefore your package name has to be unique. However it is sometimes useful to be able to produce separate APKs with different identities (e.g. different IDs for debug &amp; release builds so that they can be published as distinct entities in Fabric Beta). To facilitate this we can control the <code>applicationId</code> in our <code>build.gradle</code> and this enables us have distinct package names. We can see this in a simple project. The common Manifest is defined like this:</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  xmlns:tools=&quot;http://schemas.android.com/tools&quot;  package=&quot;com.stylingandroid.packagename&quot;&gt;  &lt;application    android:allowBackup=&quot;false&quot;    android:icon=&quot;@mipmap/ic_launcher&quot;    android:label=&quot;@string/app_name&quot;    android:supportsRtl=&quot;true&quot;    android:theme=&quot;@style/AppTheme&quot;    tools:ignore=&quot;GoogleAppIndexingWarning&quot;&gt;    &lt;activity android:name=&quot;.MainActivity&quot;&gt;      &lt;intent-filter&gt;        &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;        &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;      &lt;/intent-filter&gt;    &lt;/activity&gt;  &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>We have a base package name of <code>com.stylingandroid.packagename</code>. Next we have our <code>build.gradle</code>:</p><pre><code class="groovy">apply plugin: &#39;com.android.application&#39;android {    compileSdkVersion 25    buildToolsVersion &quot;25.0.0&quot;    defaultConfig {        applicationId &quot;com.stylingandroid.packagename&quot;        minSdkVersion 23        targetSdkVersion 25        versionCode 1        versionName &quot;1.0&quot;    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile(&#39;proguard-android.txt&#39;), &#39;proguard-rules.pro&#39;            applicationIdSuffix &quot;.release&quot;        }        debug {            applicationIdSuffix &quot;.debug&quot;        }    }}dependencies {    compile &#39;com.android.support:appcompat-v7:25.1.0&#39;}</code></pre><p>Here we add a distinct suffix to the <code>applicationId</code> for both debug and release builds. It is possible to override the entire <code>applicationId</code> (i.e. replace the whole of the package name with the <code>applicationId</code>, but we’ll just add a suffix here.</p><p>If we now compare the two Manifests which get added to the two APKs we can see how distinct package names are specified in each Manifest:</p><p><a href="https://i2.wp.com/blog.stylingandroid.com/wp-content/uploads/2017/02/Debug-vs.-Release-manifest.png?ssl=1" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/7177220-c917a2a94c30301b.25&resize=708,198&ssl=1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></a></p><p>There should be nothing here that should be surprising to the vast majority of Android developers, but from here on it is important to understand the difference between the Package Name – which gets declared up-front in the base Manifest; and the application ID – which gets declared in our <code>build.gradle</code>. The package name controls much of what occurs during the build, but the application ID only gets applied right at the very end. For proof of this, take a look <a href="https://developer.android.com/studio/build/application-id.html#change_the_package_name" target="_blank" rel="noopener">here</a>, specifically the final note which states:</p><blockquote><p>Although you may have a different name for the manifest package and the Gradle applicationId, the build tools copy the application ID into your APK’s final manifest file at the <strong>end</strong> of the build</p></blockquote><p>(The emphasis of the word <strong>end</strong> is mine)</p><p>So why is this important? Let’s begin by adding some code to our main <em>Activity</em> firstly a simple layout containing two _TextView_s:</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  xmlns:tools=&quot;http://schemas.android.com/tools&quot;  android:layout_width=&quot;match_parent&quot;  android:layout_height=&quot;match_parent&quot;  android:paddingTop=&quot;@dimen/padding_vertical&quot;  android:paddingBottom=&quot;@dimen/padding_vertical&quot;  android:paddingStart=&quot;@dimen/padding_horizontal&quot;  android:paddingEnd=&quot;@dimen/padding_horizontal&quot;  android:orientation=&quot;vertical&quot;  tools:context=&quot;com.stylingandroid.packagename.MainActivity&quot;&gt;  &lt;TextView    android:id=&quot;@+id/package_name&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;  &lt;TextView    android:id=&quot;@+id/application_id&quot;    android:layout_width=&quot;wrap_content&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/LinearLayout&gt;</code></pre><p>To the <em>Activity</em> itself we’ll add some code to set these to the package name &amp; the applicationId:</p><pre><code class="java">package com.stylingandroid.packagename;import android.app.Activity;import android.os.Bundle;import android.widget.TextView;public class MainActivity extends Activity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        TextView packageNameTextView = (TextView) findViewById(R.id.package_name);        TextView applicationIdTextView = (TextView) findViewById(R.id.application_id);        packageNameTextView.setText(getString(R.string.package_name, BuildConfig.class.getPackage().toString()));        applicationIdTextView.setText(getString(R.string.application_id, BuildConfig.APPLICATION_ID));    }}</code></pre><p>The three highlighted lines actually explain what happens during the build.</p><p>The first thing to note is the Java package name of <em>MainActivity</em> itself. As is normal we have matched this to the package name which we initially defined in the Manifest (shown earlier).</p><p>Secondly, when we come to reference our <em>BuildConfig</em>, we don’t need to fully qualify the package name, or import the package. That is because the <code>BuildConfig.java</code> and <code>R.java</code> both got generated in the package name that was specified <em>originally</em> in the Manifest – <code>com.stylingandroid.packagename</code>.</p><p>Thirdly, although the package name has not been set in the Manifest at the point when our code is compiled, we can still gain access to the final application ID for the current build flavor via the <em>BuildConfig.APPLICATION_ID</em> constant.</p><p>If we run this code it confirms this:</p><p><a href="https://i0.wp.com/blog.stylingandroid.com/wp-content/uploads/2017/02/app.png?ssl=1" target="_blank" rel="noopener"><img src="https://upload-images.jianshu.io/upload_images/7177220-4478359c4f97ea01.25&resize=708,530&ssl=1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></a></p><p>This won’t cause anyone any issues in the vast majority of cases but if, for example, you are generating code from an annotation processor, it can be important to understand when to use the package name over the applicationId and vice versa.</p><p>So, why is it left so late to set the applicationID? The simple reason is that it would cause no end of problems if it was set earlier in the process. If the <code>BuildConfig.java</code> and <code>R.java</code> files was set to the applicationId rather than the package name, then the code which referenced these would need to have different imports for different build variants – in other words you would need to have separate source sets (with huge amounts of duplication) for your different build flavors in order to access these. This would have some quite profound implications for the maintainability of our code.</p><p>As I have said, an understanding of precisely how this all works is not necessary for developers to be able to write android apps. But if, like me, you encounter some issues with generating code in the correct java package then this can be invaluable. When I was searching for information on this, the only thing I could find was the page on the official documentation (which I quoted and linked to earlier), so it seemed worth sharing what I learned. Apologies to anyone expecting the usual UI/UX-centric subject matter but hopefully this will be of interest to many as us developers are an inquisitive bunch!</p><p>The source code for this article is available <a href="https://github.com/StylingAndroid/PackageName" target="_blank" rel="noopener">here</a>.</p><p>© 2017, <a href="https://blog.stylingandroid.com/" target="_blank" rel="noopener">Mark Allison</a>. All rights reserved.<br></p>]]></content>
    
    
    <categories>
      
      <category>外文搬运</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Gradle：Task-#-finalizedBy()</title>
    <link href="/2019/07/19/Gradle/Gradle%EF%BC%9ATask-#-finalizedBy()/"/>
    <url>/2019/07/19/Gradle/Gradle%EF%BC%9ATask-#-finalizedBy()/</url>
    
    <content type="html"><![CDATA[<h1 id="Gradle：Task-finalizedBy"><a href="#Gradle：Task-finalizedBy" class="headerlink" title="Gradle：Task # finalizedBy()"></a>Gradle：Task # finalizedBy()</h1><blockquote><p>这篇文章对Gradle的Task对象的finalizedBy()方法做一个介绍</p></blockquote><h3 id="1-官方文档"><a href="#1-官方文档" class="headerlink" title="1 官方文档"></a>1 官方文档</h3><p>接口说明：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-c14619bc3420d618.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>使用示例：</p><p><a href="https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:finalizer_tasks" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/more_about_tasks.html#sec:finalizer_tasks</a></p><p>官方对这个方法只有只言片语的介绍，以下是我自己的理解。</p><h3 id="2-概述"><a href="#2-概述" class="headerlink" title="2 概述"></a>2 概述</h3><p><code>Task # finalizedBy(Object ... paths)</code></p><p>为当前的task添加一个或若干个当前task结束后立马执行的task，且添加的task的执行顺序为无序。</p><h3 id="3-实例"><a href="#3-实例" class="headerlink" title="3 实例"></a>3 实例</h3><pre><code class="gro">task A {    finalizedBy &quot;B&quot;    finalizedBy &quot;C&quot;    finalizedBy &quot;D&quot;    finalizedBy &quot;E&quot;    doLast {        println &quot;A&quot;    }}task B {    doLast {        println &quot;B&quot;    }}task C {    doLast {        println &quot;C&quot;    }}task D {    doLast {        println &quot;D&quot;    }}task E {    doLast {        println &quot;E&quot;    }}</code></pre><p>执行命令：gradlew A</p><p>打印：</p><blockquote><p>Task :A<br>A</p></blockquote><blockquote><p>Task :E<br>E</p></blockquote><blockquote><p>Task :D<br>D</p></blockquote><blockquote><p>Task :C<br>C</p></blockquote><blockquote><p>Task :B<br>B</p></blockquote><p>打印出来的结果的确表明，finalizedBy()添加的后续执行的task的执行顺序是不确定的。</p><p>无序的原因：</p><p>这里要看一下gradle的源码，<code>Task</code>的实现类是<code>AbstractTask</code></p><p>，<code>finalizedBy()</code>源码为：</p><pre><code class="java">@Overridepublic Task finalizedBy(final Object... paths) {    taskMutator.mutate(&quot;Task.finalizedBy(Object...)&quot;, new Runnable() {        public void run() {            finalizedBy.add(paths);        }    });    return this;}</code></pre><p><code>finalizedBy</code>变量为<code>DefaultTaskDependency finalizedBy</code>。</p><p>查看他的add方法：</p><pre><code class="java">//DefaultTaskDependency public DefaultTaskDependency add(Object... values) {    for (Object value : values) {        addValue(value);    }    return this;}</code></pre><pre><code class="java">private void addValue(Object dependency) {    if (dependency == null) {        throw new InvalidUserDataException(&quot;A dependency must not be empty&quot;);    }    getMutableValues().add(dependency);}</code></pre><pre><code class="java">public Set&lt;Object&gt; getMutableValues() {    if (mutableValues == null) {        mutableValues = new TaskDependencySet();    }    return mutableValues;}</code></pre><p>即<code>finalizedBy</code>是往一个Set类型的容器里面去添加task的，而Set在取的时候是无序的，所以后面执行就是无序的。</p><h3 id="4-结论"><a href="#4-结论" class="headerlink" title="4 结论"></a>4 结论</h3><ol><li>finalizedBy(Object … paths)方法的参数显示的是Object类型，但实际上用的时候要传递String类型字符串。</li><li>finalizedBy()添加的task在执行的时候是无序的。</li><li>finalizedBy()方法不能在Task执行的时候调用，即不能在doLast{}和doFirst{}里面调用，只能在Task构造的时候调用。<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>Gradle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android-7-0</title>
    <link href="/2019/07/12/AndroidSDK%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97/Android-7-0/"/>
    <url>/2019/07/12/AndroidSDK%E9%80%82%E9%85%8D%E6%8C%87%E5%8D%97/Android-7-0/</url>
    
    <content type="html"><![CDATA[<p>理论上所有的Android版本行为变更都可以在官网查到（自备梯子），这里仅贴一些额外需要注意的地方。</p><h3 id="FileProvider"><a href="#FileProvider" class="headerlink" title="FileProvider"></a>FileProvider</h3><p>FileProvider在Manifest里面的生命的<authorities>块不需要用包名，只要名字独特即可，这样在开发sdk的时候就可以避免和用户的FileProvider冲突。<br><img src="https://upload-images.jianshu.io/upload_images/7177220-96ad862cbb55fc86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p></p>]]></content>
    
    
    <categories>
      
      <category>AndroidSDK适配指南</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java中被阉割的闭包在Kotlin中的表现如何？</title>
    <link href="/2019/07/06/Kotlin/Java%E4%B8%AD%E8%A2%AB%E9%98%89%E5%89%B2%E7%9A%84%E9%97%AD%E5%8C%85%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%A6%82%E4%BD%95%EF%BC%9F/"/>
    <url>/2019/07/06/Kotlin/Java%E4%B8%AD%E8%A2%AB%E9%98%89%E5%89%B2%E7%9A%84%E9%97%AD%E5%8C%85%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%8E%B0%E5%A6%82%E4%BD%95%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-闭包概述"><a href="#1-闭包概述" class="headerlink" title="1 闭包概述"></a>1 闭包概述</h3><p>闭包，Clousure。在Java中表现为Lambda表达式，在Koltin中表现为函数类型变量（或者也叫做Lambda表达式）。</p><p>其定义：<a href="https://www.zhihu.com/question/21395848/answer/110829597" target="_blank" rel="noopener">java为什么匿名内部类的参数引用时final？ - 胖胖的回答</a></p><ol><li><p>一个依赖于自由变量的函数 </p></li><li><p>处在含有这些自由变量的一个外围环境</p></li><li><p>这个函数能够访问外围环境里的自由变量</p></li></ol><h3 id="2-Kotlin和Java的闭包对比"><a href="#2-Kotlin和Java的闭包对比" class="headerlink" title="2 Kotlin和Java的闭包对比"></a>2 Kotlin和Java的闭包对比</h3><p>在java8中，java中的闭包类型依然不能直接地修改外部环境的变量的引用，因此就有了众所周知的：匿名内部类的实例对外部环境的变量的访问，都需要让外部环境的变量加上<code>final</code>关键字。</p><p>在Kotin中，这一点被改进了，Kotlin中的闭包是功能健全的闭包。</p><h3 id="3-代码"><a href="#3-代码" class="headerlink" title="3 代码"></a>3 代码</h3><p>下面用简单的代码来对比java和kotlin的闭包类型变量在访问外部环境变量时的差异。</p><p>先定义了一个类型：鸟</p><pre><code class="kotlin">class Bird(private val wordToSing: String) {    fun sing() {        log(&quot;I sing $wordToSing&quot;)    }}</code></pre><h4 id="3-1-Kotlin"><a href="#3-1-Kotlin" class="headerlink" title="3.1 Kotlin"></a>3.1 Kotlin</h4><pre><code class="kotlin">fun main() {    var bird: Bird? = Bird(&quot;i &#39;m a testing bird.&quot;)    val fun1 = {        bird?.sing()        bird = null    }    val fun2 = {        if (bird != null) {            log(&quot;bird is alive&quot;)        } else {            log(&quot;bird is destroyed&quot;)        }    }    fun2()    fun1()    fun2()}</code></pre><p>在上述代码中，有两个闭包：<code>fun1</code>和<code>fun2</code>，他们的外部环境是<code>main()</code>函数，外部环境中的变量是<code>var bird</code>变量，那么两个闭包中都自由地对这个外部变量进行了读写。跑上述代码，打印：</p><pre><code>bird is aliveI sing i &#39;m a testing bird.bird is destroyed</code></pre><h4 id="3-2-Java"><a href="#3-2-Java" class="headerlink" title="3.2 Java"></a>3.2 Java</h4><pre><code class="java">public class Test {    public static void main(String[] args) {        Bird bird = new Bird(&quot;i &#39;m a testing bird&quot;);        Runnable fun1 = () -&gt; {            bird.sing();            bird = null;        };        Runnable fun2 = () -&gt; {            if (bird != null) {                UtilsKt.log(&quot;bird is alive&quot;);            } else {                UtilsKt.log(&quot;bird is destroyed&quot;);            }        };        fun2.run();        fun1.run();        fun2.run();    }}</code></pre><p>用了和<code>Kotlin</code>完全一样的逻辑，编译期就报错了，IDEA提示我<code>variable used in a lambda expression should be final or effectively final</code>。</p><p>但是，给<code>bird</code>变量加上final之后，在<code>fun1</code>函数里面对<code>bird=null</code>的赋值语句就出错了，因为final引用是没办法二次赋值的。</p><p>所以Java里面的闭包，对外部变量只能读，不能写（但是可以修改这个外部变量的属性）。</p><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><p>Kotlin的闭包设计更强大。<br></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>LiveData的onActive()和onInactive()</title>
    <link href="/2019/06/13/Android-Jetpack/LiveData%E7%9A%84onActive()%E5%92%8ConInactive()/"/>
    <url>/2019/06/13/Android-Jetpack/LiveData%E7%9A%84onActive()%E5%92%8ConInactive()/</url>
    
    <content type="html"><![CDATA[<blockquote><p>看文档的时候对LiveData()的onInactive()回调产生了疑问，遂看源码，记录之。</p></blockquote><h3 id="1-关系"><a href="#1-关系" class="headerlink" title="1. 关系"></a>1. 关系</h3><p><img src="https://upload-images.jianshu.io/upload_images/7177220-e1ef03486cbaad2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>概述：LiveData和Observer互相持有，LiveData将其持有的数据的变动，转发给所有注册过来的Observer。</p><h3 id="2-onActive-和-onInactive"><a href="#2-onActive-和-onInactive" class="headerlink" title="2. onActive 和 onInactive()"></a>2. onActive 和 onInactive()</h3><pre><code class="java">/** * Called when the number of active observers change to 1 from 0. * &lt;p&gt; * This callback can be used to know that this LiveData is being used thus should be kept * up to date. */protected void onActive() {}/** * Called when the number of active observers change from 1 to 0. * &lt;p&gt; * This does not mean that there are no observers left, there may still be observers but their * lifecycle states aren&#39;t {@link Lifecycle.State#STARTED} or {@link Lifecycle.State#RESUMED} * (like an Activity in the back stack). * &lt;p&gt; * You can check if there are observers via {@link #hasObservers()}. */protected void onInactive() {}</code></pre><p>这里对<code>onInactive()</code>方法的注释产生了疑问。</p><p>因为他与<code>onActive()</code>的注释并不完全对应，而是多了一句话：</p><p>这不表示该LiveData没有任何Observer了，任然有可能有LiveData，只是他们的状态不是Lifecycle.State#STARTE或Lifecycle.State#RESUMED，就像一个Activity在回退栈中。</p><h3 id="3-LiveData-ObserverWrapper（翻译：观察者封装器）"><a href="#3-LiveData-ObserverWrapper（翻译：观察者封装器）" class="headerlink" title="3. LiveData.ObserverWrapper（翻译：观察者封装器）"></a>3. LiveData.ObserverWrapper（翻译：观察者封装器）</h3><p>这两个回调只在一个方法中被调用，即<code>LiveData.ObserverWrapper</code>这个抽象非静态内部类。</p><pre><code class="java">private abstract class ObserverWrapper {    final Observer&lt;T&gt; mObserver;    //当前是否活跃状态。    boolean mActive;    int mLastVersion = START_VERSION;    ObserverWrapper(Observer&lt;T&gt; observer) {        mObserver = observer;    }    abstract boolean shouldBeActive();    boolean isAttachedTo(LifecycleOwner owner) {        return false;    }    void detachObserver() {    }    //Observer的状态改变回调    void activeStateChanged(boolean newActive) {        //如果新的状态等于原有的状态，直接返回。        if (newActive == mActive) {            return;        }        // immediately set active state, so we&#39;d never dispatch anything to inactive        // owner        //新状态赋值给旧状态        mActive = newActive;        //原先是否是活跃状态，取决于LiveData的mActiveCount        boolean wasInactive = LiveData.this.mActiveCount == 0;        //根据新状态，修改LiveData的mActiveCount        LiveData.this.mActiveCount += mActive ? 1 : -1;        //如果原先是非活跃，而新的状态是活跃        if (wasInactive &amp;&amp; mActive) {            onActive();//1        }        //如果原先是活跃，而新的状态是非活跃        if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) {            onInactive();//2        }        //如果新的状态是活跃，那么发射value，即会调用上层设置的onChanged()回调。        if (mActive) {            dispatchingValue(this);        }    }}</code></pre><p>通过以上叙述可知，<code>onActive()</code>和<code>onInactive()</code>都来自Observer的<code>activeStateChange()</code>，这个<code>activeStateChange()</code>方法不是给开发者调用的，他自己也不会调用自己，他由Observer所注册到的LiveData在适当的时机调用。</p><h3 id="4-LiveData-ObserverWrapper-activeStateChange"><a href="#4-LiveData-ObserverWrapper-activeStateChange" class="headerlink" title="4. LiveData.ObserverWrapper#activeStateChange()"></a>4. LiveData.ObserverWrapper#activeStateChange()</h3><p><img src="https://upload-images.jianshu.io/upload_images/7177220-db2c2c73986225e2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>有四个地方会调用。</p><ol><li><p>considerNotify</p><pre><code class="java">private void considerNotify(ObserverWrapper observer) {    if (!observer.mActive) {        return;    }    //调用observer的shouldBeActive（）方法确认当前observer是否是活跃的    if (!observer.shouldBeActive()) {        observer.activeStateChanged(false);        return;    }    if (observer.mLastVersion &gt;= mVersion) {        return;    }    observer.mLastVersion = mVersion;    //noinspection unchecked    observer.mObserver.onChanged((T) mData);}</code></pre><p>此处的observer的shouldBeActive()的实现稍后分析。</p></li><li><p>来自observeForever()，永久注册，注册了的观察者不再受制于<code>LifecycleOwner</code>的自动解除注册机制。</p></li><li><p>移除观察者，都被移除了，当然这个Observer就不再活跃了。</p></li><li><p>来自<code>LifecycleBoundObserver</code>。但是注意，此处调用的参数依然是借助了shouldBeActive()方法，可以说第一点很像。</p></li></ol><h3 id="5-LifecycleBoundObserver（翻译：生命周期绑定了的观察者）"><a href="#5-LifecycleBoundObserver（翻译：生命周期绑定了的观察者）" class="headerlink" title="5. LifecycleBoundObserver（翻译：生命周期绑定了的观察者）"></a>5. LifecycleBoundObserver（翻译：生命周期绑定了的观察者）</h3><pre><code class="java">//1. 继承ObserverWrapper------------&gt;对Observer的进一步封装//2. 实现GenericLifecycleObserver---&gt;具有生命周期感知能力class LifecycleBoundObserver extends ObserverWrapper implements GenericLifecycleObserver {    @NonNull final LifecycleOwner mOwner;    LifecycleBoundObserver(@NonNull LifecycleOwner owner, Observer&lt;T&gt; observer) {        super(observer);        mOwner = owner;    }    //借助LifecycleOwner的获取当前状态的方法来实现了shouldBeActive()    //用isAtLeast(STARTED)，例如只有在Activity的onStart()和onStop()回调之间，这个Observer    //才是活跃的。    @Override    boolean shouldBeActive() {        return mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);    }    @Override    public void onStateChanged(LifecycleOwner source, Lifecycle.Event event) {        if (mOwner.getLifecycle().getCurrentState() == DESTROYED) {            //绑定的LifecycleOwner是DESSTROYED，就移除自己（观察者）。这样LiveData的观察者            //就一个一个全部自己把自己从LiveData移除了。            removeObserver(mObserver);            return;        }        //借助LifecycleOwnwer的onStateChanged回调调用activeStateChanged()        activeStateChanged(shouldBeActive());    }    @Override    boolean isAttachedTo(LifecycleOwner owner) {        return mOwner == owner;    }    @Override    void detachObserver() {        mOwner.getLifecycle().removeObserver(this);    }}</code></pre><p>通过这个LifecycleBoundObserver的shouldBeActive()方法的实现，解答了LiveData的onInactive()方法的注释了。回到ObserverWrapper的activeStateChanged()方法看下：</p><pre><code class="java">void activeStateChanged(boolean newActive) {    if (newActive == mActive) {        return;    }    mActive = newActive;    boolean wasInactive = LiveData.this.mActiveCount == 0;    //此处，每当一个Observer是非活跃的时候，mActiveCount就-1。    LiveData.this.mActiveCount += mActive ? 1 : -1;    if (wasInactive &amp;&amp; mActive) {        onActive();    }    //当减到最后一个,mActiveCount=0了，就调用onInactive()了。    if (LiveData.this.mActiveCount == 0 &amp;&amp; !mActive) {        onInactive();    }    if (mActive) {        dispatchingValue(this);    }}</code></pre><p>而此处引起activeStateChanged（false）调用的原因，则可能是因为绑定的LifecycleOwner的生命周期不再是STARTED或者RESUMED了。</p><h3 id="6-LiveData的mVersion属性"><a href="#6-LiveData的mVersion属性" class="headerlink" title="6. LiveData的mVersion属性"></a>6. LiveData的mVersion属性</h3><p>这里有一个问题需要注意，就是mVersion这个属性的作用。</p><p>疑问：</p><p>activeStateChanged（）会在每当LifecycleOwner对象的生命状态发生改变时都调用，那么如果是活跃状态，就会走到dispatchingValue(this)这个方法，就会去回调到最上层开发者设置的onChanged()回调？</p><p>这样可不太好啊，每次Activity从后台返回，都会调用一下onChanged()吗？事实不是这样的，通过打断点debug，从后台返回虽然改变了Activity生命状态，但是没有回调onChanged()。这符合Observer的onChanged()方法的注释</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-a686064513976af9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>只有data改变了，才会回调。</p><p>那么明明因为LifecycleOwner的生命状态改变而调用了–&gt;activeStateChanged()—&gt;dispatchingValue()—&gt;considerNotify()。为什么不回调onChanged()?</p><pre><code class="java">private void considerNotify(ObserverWrapper observer) {    if (!observer.mActive) {        return;    }    if (!observer.shouldBeActive()) {        observer.activeStateChanged(false);        return;    }    //对比observer的版本和LiveData的版本，如果LiveData的版本不大于Observer,    //返回，不再调用onChanged（）    if (observer.mLastVersion &gt;= mVersion) {        return;    }    //否则，让Observer的版本与LiveData同步，接着调用onChanged()    observer.mLastVersion = mVersion;    //noinspection unchecked    observer.mObserver.onChanged((T) mData);}</code></pre><p>而LiveData的mVersion属性的惟一的写入的地方是：</p><pre><code class="java">@MainThreadprotected void setValue(T value) {    assertMainThread(&quot;setValue&quot;);    mVersion++;//自增    mData = value;    dispatchingValue(null);}</code></pre><p>即mVersion属性保证了：设置了一次value，调用一次onChanged()的正确逻辑。<br></p>]]></content>
    
    
    <categories>
      
      <category>Android-Jetpack</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Kotlin笔记</title>
    <link href="/2019/05/25/Kotlin/Kotlin%E7%AC%94%E8%AE%B0/"/>
    <url>/2019/05/25/Kotlin/Kotlin%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Kotlin与Java的差异"><a href="#Kotlin与Java的差异" class="headerlink" title="Kotlin与Java的差异"></a>Kotlin与Java的差异</h1><h3 id="1-对象的初始化时的顺序"><a href="#1-对象的初始化时的顺序" class="headerlink" title="1. 对象的初始化时的顺序"></a>1. 对象的初始化时的顺序</h3><p>   在java中，<code>初始化代码块</code> -&gt; <code>构造函数</code></p><p>   在kotlin中，<code>主构造函数</code> -&gt; <code>初始化代码块</code> -&gt; <code>次构造函数</code></p><p>   由于Kotlin中主构造函数在初始化代码块之前，因此初始化代码块可以使用主代码块传入的参数。</p><p>   在kotlin中，所有的次构造器都会先调用主构造器（若不存在，也会隐式调用），而初始化代码块会放在主构造函数之后执行，因此次构造函数执行之前，初始化代码块是执行完了的。</p><h3 id="2-访问控制符"><a href="#2-访问控制符" class="headerlink" title="2. 访问控制符"></a>2. 访问控制符</h3><p>   private：只能在类的内部或者文件内部被访问</p><p>   internal：internal成员可在类的内部、文件的内部、同一个模块被访问</p><p>   protected：可在类的内部或者、文件内部、子类中被访问</p><p>   public：在任意地方被访问</p><p>   与java的差异在于：</p><ol><li><p>Kotlin取消了java的默认的包访问权限，引入internal模块访问权限</p></li><li><p>Kotlin取消了protected的包访问权限。</p></li><li><p>Kotlin的默认访问控制符是public</p><p>此处的模块的存在形式有如下几种：</p></li></ol><ul><li><p>一个intelliJ IDEA模块</p></li><li><p>一个Maven项目</p></li><li><p>一个Gradle源集</p></li><li><p>一次<kotlinc>的Ant任务执行所编译的一套文件</p></li></ul><p>   注意，可以修改属性的setter()访问权限，但是无法修改属性的getter()访问权限，因为getter()访问权限是和属性的访问权限一致的</p><h3 id="3-继承：Kotlin与Java的设计相同，所有子类构造器必须调用父类构造器一次。"><a href="#3-继承：Kotlin与Java的设计相同，所有子类构造器必须调用父类构造器一次。" class="headerlink" title="3. 继承：Kotlin与Java的设计相同，所有子类构造器必须调用父类构造器一次。"></a>3. 继承：Kotlin与Java的设计相同，所有子类构造器必须调用父类构造器一次。</h3><p>   当调用子类构造器来初始化子类对象时，父类构造器总会在子类构造器之前执行；不仅如此，在执行父类构造器时，系统会再次上溯执行其父类构造器……以此类推，创建任何Kotlin对象，最先执行的总是Any类的构造器。</p><h3 id="4-方法的重写遵循”两同两小一大“规则"><a href="#4-方法的重写遵循”两同两小一大“规则" class="headerlink" title="4. 方法的重写遵循”两同两小一大“规则"></a>4. 方法的重写遵循”两同两小一大“规则</h3><ul><li>两同：方法名相同，形参列表相同</li><li>两小：子类方法的返回值类型比父类方法的返回值类型更小或相等。子类方法声明抛出的异常类应比父类方法生命抛出的异常类更小或相等。</li><li>一大：指的是子类方法的访问权限应比父类方法的访问权限更大或相等。</li></ul><h3 id="5-嵌套类和内部类"><a href="#5-嵌套类和内部类" class="headerlink" title="5. 嵌套类和内部类"></a>5. 嵌套类和内部类</h3><ol><li>内部类机制和Java的非静态内部类一致</li><li>嵌套类机制和Java的静态内部类一致，由于静态成员无法访问非静态成员，且Kotlin取消了static属性，因此Kotlin的嵌套类无法访问任何的外部类成员。</li><li>Koltin中允许在接口中定义嵌套类，但不允许在接口中定义内部类。</li></ol><h3 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6. 匿名内部类"></a>6. 匿名内部类</h3><ol><li>Kotlin 抛弃了匿名内部类，而用功能更强大的对象表达式</li><li>如果对象是一个函数式接口的实例，则可以使用Lambda表达式创建他（或者用带接口名前缀的lambda表达式创建他）。</li></ol><h3 id="7-对象表达式"><a href="#7-对象表达式" class="headerlink" title="7. 对象表达式"></a>7. 对象表达式</h3><pre><code class="kotlin">   object :N个父类型{   }</code></pre><ol><li>增强版的匿名内部类，匿名内部类只能指定一个父类型，而对象表达式可以指定N个父类型。</li><li>对象表达式不能是抽象类，因为系统在创建对象表达式的时候会立刻创建对象。</li><li>对象表达式不能定义构造器，但是可以定义初始化块。</li><li>对象表达式可以包含内部类，但是不能包含嵌套类。</li><li>Kotlin编译器能更准确地识别局部范围内或者private修饰的对象表达式的真实类型(既可以直接调用对象表达式中新定义的方法和属性)。</li><li>对象表达式可访问或者修改其所在范围内的局部变量。(java只能访问final变量，且不能修改)</li></ol><h3 id="8-对象声明-java的静态块单例模式"><a href="#8-对象声明-java的静态块单例模式" class="headerlink" title="8. 对象声明(java的静态块单例模式)"></a>8. 对象声明(java的静态块单例模式)</h3><pre><code class="kotlin">   objecct 名字 : N个接口{   }</code></pre><p>   对象声明和对象表达式的区别：</p><ol><li><p>对象表达式是表达式，因此可以赋值给变量并被引用。而对象声明不是表达式，不能用于赋值。</p></li><li><p>对象声明可包含嵌套类，不可包含内部类。对象表达式可包含内部类，不能包含嵌套类。</p></li><li><p>对象声明不能定义在函数和方法内，可以定义在类中。对象表达式可以嵌套在其他对象声明或者非内部类中。 </p><p>对象声明专门用于实现单例模式，对象声明所定义的对象就是该类的唯一实例，直接用对象声明的名称即可访问该唯一实例。</p><p>通过IntelliJ的tools-&gt;Kotlin-&gt;show Kotlin bytecode，再点击Decompile，可以看见Java代码的实现是：用懒加载的单例模式实现的。单例对象的初始化放在了静态块中。</p></li></ol><h3 id="9-伴生对象"><a href="#9-伴生对象" class="headerlink" title="9. 伴生对象"></a>9. 伴生对象</h3><ol><li><p>若在类中的对象声明加一个companion，该对象就变成了伴生对象。</p></li><li><p>每个类最多只能定义一个伴生对象。</p></li><li><p>伴生对象的名字并不重要，因此可以省略。</p></li><li><p>伴生对象的作用就是为他所在的类模拟静态成员。</p></li><li><p>拓展伴生对象就是为该伴生对象的外部类拓展静态方法和变量。</p><pre><code class="kotlin">fun main() { println(MyClass.name) MyClass.output(&quot;你好&quot;) MyClass.test() MyClass().test() println(MyClass.foo)}interface Outputable { fun output(msg: String)}class MyClass { companion object : Outputable {     //相当于MyClass的静态成员     val name = &quot;name 属性值&quot;     //相当于MyClass的静态方法     override fun output(msg: String) {         println(msg)     } }}//为MyClass拓展实例方法fun MyClass.Companion.test() { println(&quot;为伴生对象扩展的方法&quot;)}//为MyClass拓展静态方法fun MyClass.test() { println(&quot;为MyClass类扩展的方法&quot;)}//为MyClass拓展静态变量val MyClass.Companion.foo get() = &quot;为伴生对象拓展的属性&quot;</code></pre></li></ol><h3 id="10-类委托。就和java的代理模式的作用是一样的。"><a href="#10-类委托。就和java的代理模式的作用是一样的。" class="headerlink" title="10. 类委托。就和java的代理模式的作用是一样的。"></a>10. 类委托。就和java的代理模式的作用是一样的。</h3><h3 id="11-属性委托，可以直接实现Kotlin提供的两个接口ReadWriteProperty和ReadOnlyProperty来分别实现var和val属性的委托。"><a href="#11-属性委托，可以直接实现Kotlin提供的两个接口ReadWriteProperty和ReadOnlyProperty来分别实现var和val属性的委托。" class="headerlink" title="11. 属性委托，可以直接实现Kotlin提供的两个接口ReadWriteProperty和ReadOnlyProperty来分别实现var和val属性的委托。"></a>11. 属性委托，可以直接实现Kotlin提供的两个接口<code>ReadWriteProperty</code>和<code>ReadOnlyProperty</code>来分别实现var和val属性的委托。</h3><h3 id="12-Kotlin泛型"><a href="#12-Kotlin泛型" class="headerlink" title="12. Kotlin泛型"></a>12. Kotlin泛型</h3><h4 id="声明处型变"><a href="#声明处型变" class="headerlink" title="声明处型变"></a>声明处型变</h4><p>泛型中的<code>in</code>和<code>out</code>，用于取代java中有设计缺陷的<code>?</code>通配符和上下界的使用（具体设计缺陷在Kotlin文档的泛型这一部分有讲到）</p><p><code>out</code>    由<code>out</code>声明的泛型变量，只能作为方法的返回值发布到外部，不能作为方法的参数传递到方法内部。好处是：可以将带有该泛型的变量赋值给父类型泛型的变量。如</p><pre><code class="kotlin">interface Source&lt;out T&gt; {    fun nextT(): T}fun demo(strs: Source&lt;String&gt;) {    val newSource: Source&lt;Any&gt; = strs}</code></pre><p><code>in</code>        由<code>in</code>声明的泛型变量，只能作为参数被设置到内部，而不能发布到外部，因此，带有该泛型的子类型的变量都可以被作为参数传递进来。如</p><pre><code class="kotlin">interface ClassA&lt;in T&gt; {    fun setT(value: T)}fun demo(value: ClassA&lt;MutableList&lt;Int&gt;&gt;) {    value.setT(ArrayList())    //也可以引用给更小类型的泛型变量，因为这里的y此后调用setT()传进去的参数ArrayList比MutableList类型更小    val y: ClassA&lt;ArrayList&lt;Int&gt;&gt; = value}</code></pre><p>总结：out泛型的类可以作为方法中的参数，可以赋值给父类型的泛型引用。in泛型的类只能赋值给子类型泛型的变量，不可以作为方法中的参数。</p><h4 id="使用处型变"><a href="#使用处型变" class="headerlink" title="使用处型变"></a>使用处型变</h4><p>​<br></p>]]></content>
    
    
    <categories>
      
      <category>Kotlin</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>gradle的ext属性</title>
    <link href="/2019/05/20/Gradle/gradle%E7%9A%84ext%E5%B1%9E%E6%80%A7/"/>
    <url>/2019/05/20/Gradle/gradle%E7%9A%84ext%E5%B1%9E%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="1-常见用法"><a href="#1-常见用法" class="headerlink" title="1. 常见用法"></a>1. 常见用法</h3><h4 id="1-在ext这个map中放字符串或者基本数据类型"><a href="#1-在ext这个map中放字符串或者基本数据类型" class="headerlink" title="1. 在ext这个map中放字符串或者基本数据类型"></a>1. 在ext这个map中放字符串或者基本数据类型</h4><p>在android的rootProject的build.gradle中，定义如下代码块</p><pre><code class="groovy">ext {    compileSdkVersion = 25    buildToolsVersion = &quot;26.0.0&quot;    minSdkVersion = 14    targetSdkVersion = 22    appcompatV7 = &quot;com.android.support:appcompat-v7:$androidSupportVersion&quot;}</code></pre><p>然后在app模块下，通过</p><pre><code class="groovy">rootProject.ext.compileSdkVersionrootProject.ext.buildToolsVersion</code></pre><p>这种方式来访问在根目录build.gradle下定义的变量。</p><h4 id="2-在ext这个map中再map"><a href="#2-在ext这个map中再map" class="headerlink" title="2. 在ext这个map中再map"></a>2. 在ext这个map中再map</h4><p>新建一个config.gradle文件</p><p>在里面填充</p><pre><code class="groovy">ext {    //创建了一个名为android的，类型为map的变量，groovy中可以用[]来创建map类型。那么就是一个map下面又创         //建了一个map，且名字叫做android。    android = [            compileSdkVersion: 23,            buildToolsVersion: &quot;23.0.2&quot;,            minSdkVersion    : 14,            targetSdkVersion : 22,    ]    dependencies = [            appcompatV7&#39;: &#39;com.android.support:appcompat-v7:23.2.1&#39;,            design      : &#39;com.android.support:design:23.2.1&#39;    ]}</code></pre><p>然后在根目录的build.gradle的头部应用这个脚本：</p><pre><code class="groovy">apply from: &quot;config.gradle&quot;</code></pre><p>那么在app/build.gradle中，可以直接这样用：</p><pre><code class="groovy">android {    compileSdkVersion rootProject.ext.android.compileSdkVersion    buildToolsVersion rootProject.ext.buildToolsVersion    defaultConfig {        applicationId &quot;com.wuxiaolong.gradle4android&quot;        minSdkVersion rootProject.ext.android.minSdkVersion        targetSdkVersion rootProject.ext.android.targetSdkVersion        versionCode 1        versionName &quot;1.0&quot;    }...dependencies {    compile fileTree(dir: &#39;libs&#39;, include: [&#39;*.jar&#39;])    testCompile &#39;junit:junit:4.12&#39;    compile rootProject.ext.dependencies.appcompatV7    compile rootProject.ext.dependencies.design}</code></pre><h4 id="3-在ext这个map中放入函数类型的变量"><a href="#3-在ext这个map中放入函数类型的变量" class="headerlink" title="3. 在ext这个map中放入函数类型的变量"></a>3. 在ext这个map中放入函数类型的变量</h4><pre><code class="groovy">//用{}来创建函数类型对象，即闭包，赋值给变量myMethodext.myMethod = { param1, param2 -&gt;    // 闭包体}</code></pre><p>比如在rootProject中创建，那么任何一个其他的project对象都可以通过下面的方式访问到这个方法。</p><pre><code class="groovy">rootProject.ext.myMethod(&quot;1&quot;,&quot;2&quot;)</code></pre><h3 id="2-是什么："><a href="#2-是什么：" class="headerlink" title="2. 是什么："></a>2. 是什么：</h3><p>根据ext属性的<a href="https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtraPropertiesExtension.html#org.gradle.api.plugins.ExtraPropertiesExtension" target="_blank" rel="noopener">官方文档</a>，ext属性是<a href="https://docs.gradle.org/current/dsl/org.gradle.api.plugins.ExtensionAware.html" target="_blank" rel="noopener">ExtensionAware</a>类型的一个特殊的属性，本质是一个Map类型的变量，而</p><p>ExtentionAware接口的实现类为<code>Project</code>, <code>Settings</code>, <code>Task</code>, <code>SourceSet</code>等，ExtentionAware可以在运行时扩充属性，而这里的ext，就是里面的一个特殊的属性而已。如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-41485d8af4ff7083.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>关于ExtensionAware的大概的解释：该接口的子类型为<code>Project</code>, <code>Settings</code>, <code>Task</code>, <code>SourceSet</code>，他们都有一个变量叫做<code>extensions</code>(我猜想该变量也是一个类似map的实现原理)，可以往该变量中放置属性。</p><h3 id="3-使用ext属性的优势"><a href="#3-使用ext属性的优势" class="headerlink" title="3. 使用ext属性的优势"></a>3. 使用ext属性的优势</h3><p>用ext属性，和直接在build.gradle中用def定义变量的好处是什么？</p><p>ext属性可以伴随对应的<code>ExtensionAware</code>对象在构建的过程中被其他对象访问，例如你在rootProject中声明的ext中添加的内容，就可以在任何能获取到rootProject的地方访问这些属性，而如果只在rootProject/build.gradle中用def来声明这些变量，那么这些变量除了在这个文件里面访问之外，其他任何地方都没办法访问。</p><p>这是因为在build.gradle中直接定义的属性，只是作为gradle构建的生命周期中的<code>Configuration</code>阶段的局部变量而已（我在<a href="https://www.jianshu.com/p/4f0ff9bd2f62" target="_blank" rel="noopener">Gradle构建的生命周期和其对象的理解</a>中猜想该阶段是在执行Project对象的构造函数），而往ext属性中写入变量，则可以在整个构建的生命周期都访问到那些变量。</p><p>此外要注意，ext属性是属于拥有他的相应的对象的，比如Project对象，因此只要能访问到对应的Project对象，就能访问到对应的ext属性</p><p>thanks:</p><p><a href="http://wuxiaolong.me/2016/03/31/gradle4android2/" target="_blank" rel="noopener">http://wuxiaolong.me/2016/03/31/gradle4android2/</a></p><p><a href="https://stackoverflow.com/questions/37186108/gradle-def-vs-ext" target="_blank" rel="noopener">https://stackoverflow.com/questions/37186108/gradle-def-vs-ext</a></p><p><a href="https://stackoverflow.com/questions/27777591/how-to-define-and-call-custom-methods-in-build-gradle?noredirect=1&amp;lq=1" target="_blank" rel="noopener">https://stackoverflow.com/questions/27777591/how-to-define-and-call-custom-methods-in-build-gradle?noredirect=1&amp;lq=1</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Gradle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>观察者模式：将对象的状态监听器抽象</title>
    <link href="/2019/03/29/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81%E7%9B%91%E5%90%AC%E5%99%A8%E6%8A%BD%E8%B1%A1/"/>
    <url>/2019/03/29/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%EF%BC%9A%E5%B0%86%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%8A%B6%E6%80%81%E7%9B%91%E5%90%AC%E5%99%A8%E6%8A%BD%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>回调、监听器、观察者模式。这三个名词描述的都是同一件事物：</p><blockquote><p> 一个有状态的对象，将自身的状态发布出去，通知到那些订阅了该对象的状态的观察者（们）。</p></blockquote><p>举例子：微信用户关注（或者说订阅）一个公众号，当公众号作者发布一篇推文时，所有订阅了这个公众号的用户都能收到推送。</p><p>被观察者，都是有状态的对象，将自己的某个状态发布给订阅了他的对象们。</p><p>代码举例：</p><pre><code class="kotlin">class Author {    private var onPublishEssayListener: ((id: String) -&gt; Unit)? = null    private var onUpdateEssayListener: ((id: String) -&gt; Unit)? = null    private var onDeleteEssayListener: ((id: String) -&gt; Unit)? = null    fun publishEssay() {        //...        //由Author自己维护何时发布回调        onPublishEssayListener?.invoke(&quot;123&quot;)        //...    }    fun deleteEssay() {        //..        //由Author自己维护何时发布回调        onDeleteEssayListener?.invoke(&quot;123&quot;)        //..    }    fun updateEssay() {        //..        //由Author自己维护何时发布回调        onUpdateEssayListener?.invoke(&quot;123&quot;)        //..    }    fun observePublish(onPublishEssayListener: (id: String) -&gt; Unit) {        this.onPublishEssayListener = onPublishEssayListener    }    fun observeUpdate(onUpdateEssayListener: (id: String) -&gt; Unit) {        this.onUpdateEssayListener = onUpdateEssayListener    }    fun observeDelete(onDeleteEssayListener: (id: String) -&gt; Unit) {        this.onDeleteEssayListener = onDeleteEssayListener    }}fun main(args: Array&lt;String&gt;) {    val author = Author()    author.observePublish { id -&gt;        log(&quot;发布文章，id=$id&quot;)    }    author.observeUpdate { id -&gt;        log(&quot;更新文章，id=$id&quot;)    }    author.observeDelete { id -&gt;        log(&quot;删除文章。id=$id&quot;)    }    author.publishEssay()    author.updateEssay()    author.deleteEssay()}</code></pre><p>打印：</p><pre><code>发布文章，id=123更新文章，id=123删除文章。id=123</code></pre><p>上述代码由<code>Author</code>类直接引用了回调（用了Kotlin中的函数类型，省去了定义多个接口），在<code>Authoer</code>类的内部来直接根据当前的逻辑，将注册过来的观察者给发布出去。这里可以将这些观察者（或者说回调对象）抽象出来，做成一个父类，让<code>Author</code>继承。</p><p>因为观察者观察的都是文章的状态，因此这个类叫做<code>EssayStateRegistry</code></p><pre><code class="kotlin">abstract class EssayStateRegistry {    private var onPublishEssayListener: ((id: String) -&gt; Unit)? = null    private var onUpdateEssayListener: ((id: String) -&gt; Unit)? = null    private var onDeleteEssayListener: ((id: String) -&gt; Unit)? = null    //-------------状态的通知------------------    protected fun notifyPublish(id: String) {        onPublishEssayListener?.invoke(id)    }    protected fun notifyUpdate(id: String) {        onUpdateEssayListener?.invoke(id)    }    protected fun notifyDelete(id: String) {        onDeleteEssayListener?.invoke(id)    }    //------------状态的订阅--------------------    fun observePublish(onPublishEssayListener: (id: String) -&gt; Unit) {        this.onPublishEssayListener = onPublishEssayListener    }    fun observeUpdate(onUpdateEssayListener: (id: String) -&gt; Unit) {        this.onUpdateEssayListener = onUpdateEssayListener    }    fun observeDelete(onDeleteEssayListener: (id: String) -&gt; Unit) {        this.onDeleteEssayListener = onDeleteEssayListener    }}</code></pre><p>此时的<code>Authoer</code>便干净了许多</p><pre><code class="kotlin">//继承了EssayStateRegistryclass Author : EssayStateRegistry() {    fun publishEssay() {        //...        //由Author自己维护何时发布回调        notifyPublish(&quot;123&quot;)        //...    }    fun deleteEssay() {        //..        //由Author自己维护何时发布回调        notifyDelete(&quot;123&quot;)        //..    }    fun updateEssay() {        //..        //由Author自己维护何时发布回调        notifyUpdate(&quot;123&quot;)        //..    }}</code></pre><p>主程序代码不需要改变。</p><pre><code class="kotlin">fun main(args: Array&lt;String&gt;) {    val author = Author()    author.observePublish { id -&gt;        log(&quot;发布文章，id=$id&quot;)    }    author.observeUpdate { id -&gt;        log(&quot;更新文章，id=$id&quot;)    }    author.observeDelete { id -&gt;        log(&quot;删除文章。id=$id&quot;)    }    author.publishEssay()    author.updateEssay()    author.deleteEssay()}</code></pre><p>打印</p><pre><code>发布文章，id=123更新文章，id=123删除文章。id=123</code></pre><p>特点：</p><ol><li>将有状态的对象<code>Author</code>与他的观察、订阅逻辑分离。他自己不再直接维护他的状态。他的状态的订阅和发布的处理细节抽象给父类。他自己只需要继承父类就可以获得转发自己状态的能力。</li></ol><p>优点：</p><ol><li>逻辑分离，简化有状态的对象<code>Author</code>的代码，让其专注主要的逻辑。</li><li>抽象出来的父类<code>EssayStateRegistry</code>可以拓展，其他对象只需要继承父类，就可以瞬间拥有所有父类的状态和维护状态的能力。</li><li>当未来可能有更多的状态需要<code>Author</code>类拓展，那么可以再抽象出一个父类<code>XXXStateRegistry</code>来让<code>Author</code>继承，此时<code>Author</code>的代码将依然保持简洁。</li></ol><p>缺点：</p><ol><li>继承就是耦合，抽象父类的任何的改动，都将影响所有继承了父类的子类。</li></ol><p>图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-d534c096fb9f7b44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></p>]]></content>
    
    
    <categories>
      
      <category>java设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git新建远程分支，创建跟踪远程分支的本地副本</title>
    <link href="/2019/03/28/git/git%E6%96%B0%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%EF%BC%8C%E5%88%9B%E5%BB%BA%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%89%AF%E6%9C%AC/"/>
    <url>/2019/03/28/git/git%E6%96%B0%E5%BB%BA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%EF%BC%8C%E5%88%9B%E5%BB%BA%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%89%AF%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<h3 id="新建远程分支："><a href="#新建远程分支：" class="headerlink" title="新建远程分支："></a>新建远程分支：</h3><pre><code class="bash">git push -u origin 远程分支名</code></pre><p>新建远程分支，并将本地分支的commit信息push到远程分支。注意要加-u，表示当前追踪远程指定分支，如果不加，也无法建立远程分支。</p><h3 id="创建跟踪远程分支的本地副本："><a href="#创建跟踪远程分支的本地副本：" class="headerlink" title="创建跟踪远程分支的本地副本："></a>创建跟踪远程分支的本地副本：</h3><pre><code class="bash">$ git branch 本地分支名 origin/远程分支名</code></pre><p>建议本地分支名=远程分支名，否则在push的时候，git会提醒你，并让你明确指定那一次push的远程分支名。<br></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>FutureTask和ExecutorService#submit()</title>
    <link href="/2019/03/15/java%E5%B9%B6%E5%8F%91/FutureTask%E5%92%8CExecutorService#submit()/"/>
    <url>/2019/03/15/java%E5%B9%B6%E5%8F%91/FutureTask%E5%92%8CExecutorService#submit()/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7177220-f0bd9b56a9d192a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p><code>ThreadPoolExecutor</code>对象可以通过<code>Executor</code>的工厂方法(newXXX)或者他自己的构造函数来创建。他是Java线程池的实现类。</p><p>使用：</p><pre><code class="kotlin">//Runnablefun main(args: Array&lt;String&gt;) {    val pool= Executors.newFixedThreadPool(3)    pool.execute{        Thread.sleep(2000)        println(&quot;无返回值&quot;)        pool.shutdown()    }}//FutureTaskfun main(args: Array&lt;String&gt;) {    val pool= Executors.newFixedThreadPool(3)    val futureTask=FutureTask&lt;String&gt;(Callable&lt;String&gt;{        Thread.sleep(2000)        return@Callable &quot;有返回值&quot;    })    pool.submit(futureTask)    //block current thread    val result=futureTask.get()    println(result)    pool.shutdown()}</code></pre><p>一般用的比较多的都是第一种，创建<code>Runnable</code>实例，通过调用<code>execute()</code>或者<code>submit()</code>，交给线程池内部去处理。</p><p>第二种方法用的不多，下文浅析他的工作机制。</p><h3 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h3><p><code>ThreadPoolExecutor</code>的<code>pool.submit(xxx)</code>方法来自于他的父类<code>AbstractExecutorService</code>。</p><pre><code class="java">public Future&lt;?&gt; submit(Runnable task) {    if (task == null) throw new NullPointerException();    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null);    execute(ftask);    return ftask;}public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) {    if (task == null) throw new NullPointerException();    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);    execute(ftask);    return ftask;}public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) {    if (task == null) throw new NullPointerException();    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);    execute(ftask);    return ftask;}</code></pre><p>在这里可以看到，将传入的无论是<code>Runnable</code>还是<code>Callable</code>类型的变量，统一用一个<code>newTaskFor()</code>方法封装成了<code>RunnableFuture</code>对象，并且统一交给了<code>execute(Runnable command)</code>方法，这样就又回到了最熟悉的使用线程池的方式了。在<code>execute()</code>方法中，让线程池不同的实例去用不同的方法调度工作线程和任务队列。</p><p>在这里将<code>RunnableFuture</code>作为<code>Runnable</code>的子类型传递给<code>execute</code>，又作为<code>Future</code>的子类型从<code>submit()</code>方法返回。</p><p>他的实例化由<code>newTaskFor()</code>方法负责。</p><pre><code class="java">protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) {    return new FutureTask&lt;T&gt;(runnable, value);}protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) {    return new FutureTask&lt;T&gt;(callable);}</code></pre><p>全部返回了具体类型<code>FutureTask</code>的子类 。</p><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>uml类图如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-b484f4af170a1a56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>在这里关注<code>FutureTask</code>的三个方法：</p><ol><li>构造方法</li><li>run()方法。（作为Runnable子类传递给线程池的直接执行方法）</li><li>get()方法。（客户端调用，阻塞当前线程，获取执行结果）</li></ol><h4 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h4><pre><code class="java">public FutureTask(Callable&lt;V&gt; callable) {    if (callable == null)        throw new NullPointerException();    this.callable = callable;    this.state = NEW;       // ensure visibility of callable}public FutureTask(Runnable runnable, V result) {    //用Executors.callable将runnable转换成callable对象。    this.callable = Executors.callable(runnable, result);    this.state = NEW;       // ensure visibility of callable}</code></pre><p>构造方法：注入Callable对象，将当前状态标志为NEW。</p><h4 id="2-get-方法"><a href="#2-get-方法" class="headerlink" title="2. get()方法"></a>2. get()方法</h4><pre><code class="java">public V get() throws InterruptedException, ExecutionException {    int s = state;    if (s &lt;= COMPLETING)        //阻塞当前线程        s = awaitDone(false, 0L);    //当线程从阻塞状态被唤醒，将结果返回。    return report(s);}//Awaits completion or aborts on interrupt or timeout.private int awaitDone(boolean timed, long nanos)    throws InterruptedException {    final long deadline = timed ? System.nanoTime() + nanos : 0L;    WaitNode q = null;    boolean queued = false;    for (;;) {        if (Thread.interrupted()) {            removeWaiter(q);            throw new InterruptedException();        }        int s = state;        if (s &gt; COMPLETING) {            if (q != null)                q.thread = null;            return s;        }        else if (s == COMPLETING) // cannot time out yet            Thread.yield();        else if (q == null)            q = new WaitNode();        else if (!queued)            queued = UNSAFE.compareAndSwapObject(this, waitersOffset,                                                 q.next = waiters, q);        else if (timed) {            nanos = deadline - System.nanoTime();            if (nanos &lt;= 0L) {                removeWaiter(q);                return state;            }            LockSupport.parkNanos(this, nanos);        }        else            //阻塞当前线程            LockSupport.park(this);    }}</code></pre><p>这里是<code>get()</code>–&gt;<code>awaitDone()</code>–&gt;<code>LockSupport.park(this)</code>。</p><p>在<code>LockSupport.park()</code>方法内部，获取当前线程，并阻塞。</p><p>那么当线程从阻塞状态唤醒时（run方法执行完毕主动唤醒，或者遇到异常被唤醒），调用<code>report(int s)</code>方法将执行结果返回。</p><pre><code class="java">/** The result to return or exception to throw from get() */private Object outcome; // non-volatile, protected by state reads/writesprivate V report(int s) throws ExecutionException {    Object x = outcome;    if (s == NORMAL)        return (V)x;    if (s &gt;= CANCELLED)        throw new CancellationException();    throw new ExecutionException((Throwable)x);}</code></pre><p>读取实例变量<code>outcome</code>的值，并返回。</p><p>到这里就应该猜到，<code>outcome</code>的值的写入应该发生在<code>run()</code>方法里面了。</p><h4 id="3-run-方法"><a href="#3-run-方法" class="headerlink" title="3. run()方法"></a>3. run()方法</h4><pre><code class="java">public void run() {    if (state != NEW ||        !UNSAFE.compareAndSwapObject(this, runnerOffset,                                     null, Thread.currentThread()))        return;    try {        Callable&lt;V&gt; c = callable;        if (c != null &amp;&amp; state == NEW) {            V result;            boolean ran;            try {                //调用callback的方法，并获取执行结果                result = c.call();                ran = true;            } catch (Throwable ex) {                result = null;                ran = false;                setException(ex);            }            if (ran)                set(result);//将执行结果设置到实例变量中。        }    } finally {        // runner must be non-null until state is settled to        // prevent concurrent calls to run()        runner = null;        // state must be re-read after nulling runner to prevent        // leaked interrupts        int s = state;        if (s &gt;= INTERRUPTING)            handlePossibleCancellationInterrupt(s);    }}</code></pre><p>在这里直接调用<code>callback.call</code>方法执行其内部代码，然后将结果用<code>set()</code>保存起来</p><pre><code class="java">protected void set(V v) {    if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) {        //保存执行结果        outcome = v;        UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state        //唤醒当前线程。        finishCompletion();    }}/** * Removes and signals all waiting threads, invokes done(), and * nulls out callable. */private void finishCompletion() {    // assert state &gt; COMPLETING;    for (WaitNode q; (q = waiters) != null;) {        if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) {            for (;;) {                Thread t = q.thread;                if (t != null) {                    q.thread = null;                    //唤醒线程                    LockSupport.unpark(t);                }                WaitNode next = q.next;                if (next == null)                    break;                q.next = null; // unlink to help gc                q = next;            }            break;        }    }    done();    callable = null;        // to reduce footprint}</code></pre><hr><p>机制分析结束，在使用上面，<code>FutureTask</code>和<code>Runnable的</code>最大不同就是，可以用<code>get()</code>方法阻塞当前线程并获取执行结果。<br></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Handler内存泄漏再探索</title>
    <link href="/2019/03/09/Android/Handler%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%86%8D%E6%8E%A2%E7%B4%A2/"/>
    <url>/2019/03/09/Android/Handler%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%86%8D%E6%8E%A2%E7%B4%A2/</url>
    
    <content type="html"><![CDATA[<h3 id="情景"><a href="#情景" class="headerlink" title="情景"></a>情景</h3><ol><li>使用主线程单例Handler的<code>post()</code>，想要实现全局都可以往主线程post代码。</li><li>在<code>post()</code>中传入了一个<code>Runnable</code>对象，该<code>Runnable</code>对象在Activity中非静态，是局部匿名内部类的形式存在。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><pre><code class="kotlin">//单例类，提供一个主线程单例Handler。object ExecutorsHelper {    val mainThread = MainThreadExecutor()    class MainThreadExecutor {        private val handler = Handler(Looper.getMainLooper())        fun execute(lifecycleOwner: LifecycleOwner, command: Runnable?) {            //对生命周期组件进行处理，在其销毁时，手动将该Runnable从主线程消息队列中移除            lifecycleOwner.lifecycle.addObserver(object : LifecycleEventObserver {                override fun onStateChanged(source: LifecycleOwner, event: Lifecycle.Event){                    if (event == Lifecycle.Event.ON_DESTROY) {                        lifecycleOwner.lifecycle.removeObserver(this)                        handler.removeCallbacks(command)                        LogUtils.d(&quot;Main2Activity&quot;,&quot;尝试将Runnable从全局handler中移除！&quot;)                    }                }            })            //post到主线程消息队列            handler.post(command)        }    }}//发生内存泄露的Activityclass Main2Activity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main2)        ExecutorsHelper.mainThread.execute(this, Runnable {            thread {                val sleepTime = SECOND * 5                Thread.sleep(sleepTime)                LogUtils.d(&quot;${this}中的线程执行完毕&quot;)            }            LogUtils.d(&quot;$this 中引用的runnable在消息队列中执行完毕&quot;)        })    }    companion object {        //1秒        const val SECOND = 1000L    }}//主Activityclass MainActivity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main)        btn.setOnClickListener {            startActivity(Intent(this, Main2Activity::class.java))        }    }}</code></pre><p>当我从MainActivity不断地启动，销毁，启动，销毁Main2Activity时，发生了内存泄露。</p><p>原因：虽然我在Activity发生<code>onDestory（）</code>时将Runnable对象从主线程消息队列中移除（虽然移除的时候，Runnable早就执行完并且不在消息队列上了），但是由于Runnable代码块中启动了一个异步任务，这个异步任务等待了5秒，并且持有了外部对象<code>Main2Activity</code>的强引用。</p><hr><p>补充：为什么<code>Main2Activity</code>中创建的<code>Thread</code>对象不会被回收，他不是没有被任何对象引用吗？</p><p>答：存活的线程对象本身就是一个GC root，他不会被回收，而JVM顺着该GC root找到了<code>Thread</code>强引用的<code>Main2Activity</code>对象，因此<code>Main2Activity</code>不会被回收。</p><p><em>（我在这里也一直都不知道原来 a live Thread is a GC root这个概念的，当时学《深入理解java虚拟机》的时候是没有提到过这个概念的，这次也是刷新了认知了）</em></p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-40cad7fa1c198e65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p><a href="https://www.yourkit.com/docs/java/help/gc_roots.jsp" target="_blank" rel="noopener">https://www.yourkit.com/docs/java/help/gc_roots.jsp</a></p><hr><p>此处解决方案：让Runnable作为静态内部类，如果需要一个外部类<code>Activity</code>的引用，用<code>WeakReference</code>和空引用判断。</p><p>改造后的<code>Main2Activity</code></p><pre><code class="kotlin">class Main2Activity : AppCompatActivity() {    override fun onCreate(savedInstanceState: Bundle?) {        super.onCreate(savedInstanceState)        setContentView(R.layout.activity_main2)        ExecutorsHelper.mainThread.execute(this, ARunnable(this))    }    class ARunnable(activity: Main2Activity) : Runnable {        private val weakReference: WeakReference&lt;Main2Activity&gt; = WeakReference(activity)        override fun run() {            thread {                val sleepTime = SECOND * 5                Thread.sleep(sleepTime)                LogUtils.d(&quot;${weakReference.get()?.toString()}中的线程执行完毕&quot;)            }            LogUtils.d(&quot;$this 中引用的runnable在消息队列中执行完毕&quot;)        }    }    companion object {        //1秒        const val SECOND = 1000L    }}</code></pre><p>不再发生内存泄漏。</p><hr><p><strong>启示</strong>:防止Handler内存泄漏，需要：</p><ol><li>将Handler做成静态内部类</li><li>在控制器的<code>onDestroy()</code>中移除消息，例如<code>handler.removeCallbacks(...)</code></li><li><code>handler.post(Runnable)</code>中，但凡开启了异步任务的，都要将<code>Runnable</code>也做成静态内部类，且用<code>WeakReference</code>来获得控制器的引用。<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>view-getX(),-view-getLeft(),-view-getTranslationX()</title>
    <link href="/2019/03/05/View/view-getX(),-view-getLeft(),-view-getTranslationX()/"/>
    <url>/2019/03/05/View/view-getX(),-view-getLeft(),-view-getTranslationX()/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://stackoverflow.com/questions/30202379/android-views-gettop-getleft-getx-gety-getwidth-getheight-meth" target="_blank" rel="noopener">https://stackoverflow.com/questions/30202379/android-views-gettop-getleft-getx-gety-getwidth-getheight-meth</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7177220-4a075ebec23907b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>application-x-www-form-urlencoded-还是-multipart-form-data-</title>
    <link href="/2019/03/03/%E7%BD%91%E7%BB%9C/application-x-www-form-urlencoded-%E8%BF%98%E6%98%AF-multipart-form-data-/"/>
    <url>/2019/03/03/%E7%BD%91%E7%BB%9C/application-x-www-form-urlencoded-%E8%BF%98%E6%98%AF-multipart-form-data-/</url>
    
    <content type="html"><![CDATA[<blockquote><p>主体内容翻译自<a href="https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data" target="_blank" rel="noopener">https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data</a> 上的最高赞的回答</p></blockquote><hr><p>首先，http请求的内容如下：</p><pre><code>request lineheadersrequest body</code></pre><p>其中，request line部分的url必须以<code>application/x-www-form-urlencoded</code>方式编码</p><p>request body的编码方式由头部的Content-Type指定。</p><p>以下，开始翻译stackOverFlow的<code>application/x-www-form-urlencoded or multipart/form-data?</code>问题下的第一个回答。</p><hr><h2 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h2><p>总结：如果你有二进制的数据（即非字母或者数字，或者非常大的一段数据）要传输，那么使用<code>multipart/form-data</code>。否则，使用<code>application/x-www-form-urlencoded</code>。</p><p>分析：<code>multipart/form-data</code>和<code>application/x-www-form-urlencoded</code>是http post请求中，user-agent（浏览器或者客户端）必须支持的两种MIME type，这两种多媒体类型的请求的目的是去发送name/value对的一串列表到服务端。在传输的数据的类型和大小不同的情况下，以上两种方法，一种会比另一种更有效率。要理解为什么，你必须看一下这两种编码类型的内部实现。</p><p><code>multipart/x-www-form-urlencoded</code>：被发送到服务端的http消息的body在本质上是一个巨大的查询字符串：name/value对被<code>&amp;</code>符号分开，name和value被<code>=</code>符号分开，例如：</p><p><code>MyVariableOne=ValueOne&amp;MyVariableTwo=ValueTwo</code></p><p>根据<a href="https://www.w3.org/TR/html401/interact/forms.html" target="_blank" rel="noopener">specification</a> </p><blockquote><p>非字母和数字的字符会被<code>%HH</code>来代替，一个百分比符号和两个16位进制的数字代表着那个字符的ASCII码</p></blockquote><p>这意味着每一个在value中的非字母和数字的字节，都将被3个字节的数据代替。如果是一个大的二进制的文件，那么3倍的传输数据将会变得十分低效率。</p><p>这时<code>multipart/form-data</code>就该出现了。用这种方法来传输name/value对，每一个键值对都代表着MIM消息中的一个<code>part</code>。不同给的<code>part</code>被一个独特的字符串界线分割（该字符串分界线需要独特地生成，以便不会在任何value中出现）。每一个part有他自己的一系列MIME 头部，例如<code>Content-Type</code>，并且特别低，需要有<code>Content-Disposition</code>，来给每一个<code>part</code>他自己的“名字”。每一个name/value对的value是每一个MIME消息中的part的有效负载。MIME spec给了我们更多的选项，比如，我们可以选择一个更加高效率的数据编码方式来节约流量（eg.base64 或甚至 原生二进制）。</p><p>那么为什么不一直用<code>multipart/form-data</code>呢？因为：对于一些短的字母或数字的value（大多数web表单都是），添加所有MIME头的开销将大大超过从更有效的二进制编码中节省的任何开销。<br></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java泛型通配符，上下界。</title>
    <link href="/2019/02/17/Java/Java%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%8C%E4%B8%8A%E4%B8%8B%E7%95%8C%E3%80%82/"/>
    <url>/2019/02/17/Java/Java%E6%B3%9B%E5%9E%8B%E9%80%9A%E9%85%8D%E7%AC%A6%EF%BC%8C%E4%B8%8A%E4%B8%8B%E7%95%8C%E3%80%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>为了理清楚泛型的通配符和上下界的作用，并为了Kotlin的泛型中的关键字<code>in</code>和<code>out</code>的理解，在此用小demo重新梳理一遍对泛型的理解。</p></blockquote><h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code class="java">public class Example {    //程序入口    public static void main(String[] args) {        Source&lt;? extends Number&gt; sourceOfNumber = new Source&lt;&gt;();        Number params = sourceOfNumber.getParams();//get()方法，通过编译        sourceOfNumber.setParams(1);//①set()方法，不通过编译        Source&lt;? super Integer&gt; sourceOfParentOfInt = new Source&lt;&gt;();        sourceOfParentOfInt.setParams(new Integer(1));//set()方法，通过编译        Number i = sourceOfParentOfInt.getParams();//②get()方法，不通过编译    }    //包装对象    private static class Source&lt;T&gt; {        private T params;        public T getParams() {            return params;        }        public void setParams(T params) {            this.params = params;        }    }}</code></pre><p>以下来自《疯狂Kotlin讲义》并结合上述代码的理解。</p><h3 id="通配符下界Source-lt-super-Integer-gt"><a href="#通配符下界Source-lt-super-Integer-gt" class="headerlink" title="通配符下界Source&lt;? super Integer&gt;"></a>通配符下界<code>Source&lt;? super Integer&gt;</code></h3><p>在这里，<code>T</code>就是<code>? super Integer</code>。由于<code>Source&lt;T&gt;</code>中的泛型一定是Integer的父类，因此程序总是可以向<code>Source</code>对象传入<code>Integer</code>值。但从<code>Source&lt;T&gt;</code>中取出对象是不安全的，因为无法预测到取出的是<code>Number</code>对象还是<code>Object</code>对象，即无法判断demo中的<code>sourceOfParentOfInt</code>引用的对象实际是<code>Source&lt;Number&gt;</code>还是<code>Source&lt;Object&gt;</code>。</p><p>因此往对象中设置值总是安全的，取出值总是不安全的。</p><h3 id="通配符上界Source-lt-extends-Integer-gt"><a href="#通配符上界Source-lt-extends-Integer-gt" class="headerlink" title="通配符上界Source&lt;? extends Integer&gt;"></a>通配符上界<code>Source&lt;? extends Integer&gt;</code></h3><p>在这里，<code>T</code>就是<code>? extends Number</code>。由于<code>Source&lt;T&gt;</code>中的泛型一定是Number的子类，因此程序从<code>Source</code>对象中取出的<code>T</code>一定是<code>Number</code>的子类，即可以用<code>Number</code>来引用。但是向其中传入对象是不安全的，因为你不能确定demo中的<code>sourceOfNumber</code>引用的到底是<code>Source&lt;Float&gt;</code>还是<code>Source&lt;Integer&gt;</code>，如果是引用了<code>Source&lt;Float&gt;</code>对象，而你往里面传了一个<code>Integer</code>，那么程序就出错了。</p><p>因此从对象中取出值是安全的，但是往对象中设置值是不安全的。</p><p></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OkHttp拦截器袖珍重写版</title>
    <link href="/2019/01/18/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/OkHttp%E6%8B%A6%E6%88%AA%E5%99%A8%E8%A2%96%E7%8F%8D%E9%87%8D%E5%86%99%E7%89%88/"/>
    <url>/2019/01/18/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/OkHttp%E6%8B%A6%E6%88%AA%E5%99%A8%E8%A2%96%E7%8F%8D%E9%87%8D%E5%86%99%E7%89%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章建立在看过一遍OkHttp源码中的拦截器部分的基础上。</p></blockquote><h2 id="OkHttp回顾"><a href="#OkHttp回顾" class="headerlink" title="OkHttp回顾"></a>OkHttp回顾</h2><p>OkHttp的拦截器工作原理如下图，每一个拦截器都有机会处理上一个拦截器传下来的Request或者下一个拦截器返回上来的Response，即可任意地进行前处理和后处理。在最后一个拦截器CallServerInterceptor中进行真正的网络链接，成功后构造Response对象并发布，一层一层地传递到开发者手上。</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-b466a27ff2bd90c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" srcset="/img/loading.gif" alt=""></p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-646c4c0dd0fc126b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/250" srcset="/img/loading.gif" alt=""></p><h2 id="仿写拦截器"><a href="#仿写拦截器" class="headerlink" title="仿写拦截器"></a>仿写拦截器</h2><blockquote><p>在实战开发中，仅就涉及数据处理这一方面，拦截器就有非常好的设计效果，OkHttp这一套是可以照搬到很多地方的，拦截器这一套设计实战性非常高，故在这里动手撸一个简易版。</p></blockquote><h3 id="1-定义Request和Response"><a href="#1-定义Request和Response" class="headerlink" title="1. 定义Request和Response"></a>1. 定义Request和Response</h3><pre><code class="java">/** * 作为责任链上一直被传递的对象，从构造开始，一直传递到最后一个拦截器并被依次捕获和处理 */public class Request {    public int i = 0;    public int j = 1;}/** * 在最后一个拦截器中发生构造，并被依次返回到责任链的递归，并最终返回给应用层读取。 */public class Response {    public String param1;    public String param2;}</code></pre><ol><li><p>请求和响应是最先定义的，实际上这叫做输入和输出，Input和Output，只是刚好在网络请求这里叫做Request和Response，我按照OkHttp的来，也这样写了。</p></li><li><p>Request和Response要按照实际业务的需求来定义就行，只要记住一个是责任链的输入，一个是责任链的输出。</p></li></ol><h3 id="2-定义拦截器和责任链接口"><a href="#2-定义拦截器和责任链接口" class="headerlink" title="2.定义拦截器和责任链接口"></a>2.定义拦截器和责任链接口</h3><pre><code class="java">public interface Interceptor {    //拦截    Response intercept(Chain chain);    interface Chain {        //获取请求        Request request();        //处理请求，该方法由拿到了Chain对象引用的拦截器来调用。        Response proceed(Request request);    }}</code></pre><h3 id="3-实现责任链接口的封装"><a href="#3-实现责任链接口的封装" class="headerlink" title="3. 实现责任链接口的封装"></a>3. 实现责任链接口的封装</h3><pre><code class="java">/** * 实际上只是对以下3个变量的一个封装。 */public class RealInterceptorChain implements Interceptor.Chain {    //自始至终被传递的请求    private Request mRequest;    //拦截器容器    private List&lt;Interceptor&gt; mInterceptors;    //拦截器容器的下标。    private int mIndex;    public RealInterceptorChain(List&lt;Interceptor&gt; interceptors, int index, Request request) {        mRequest = request;        mInterceptors = interceptors;        mIndex = index;    }    @Override    public Request request() {        return mRequest;    }    @Override    public Response proceed(Request request) {        //该index处不再有拦截器，异常        if (mIndex &gt;= mInterceptors.size()) throw new AssertionError();        //构造责任链，将下标+1，其余不变。        RealInterceptorChain next = new RealInterceptorChain(mInterceptors, mIndex + 1, mRequest);        //获取当前下标的拦截器        Interceptor interceptor = mInterceptors.get(mIndex);        //将变量交给拦截器处理，由拦截器自己转发给下一个拦截器        return interceptor.intercept(next);    }}</code></pre><h3 id="4-完成"><a href="#4-完成" class="headerlink" title="4. 完成"></a>4. 完成</h3><blockquote><p>一共2个接口，3个类。</p></blockquote><p>拦截器的责任链模式就这么简单。</p><p>后面的封装就是锦上添花的东西了，比如再写几个具体的拦截器，把整个拦截器的功能隐藏起来，只暴露少数的接口给外部等等。总之也是按照OkHttp源码那一套写就不会错。</p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>这是在没有任何封装的条件下的直接new出两个拦截器实例来测试。</p><ol><li>构造Request</li><li>构造拦截器容器</li><li>添加内部的或外部的拦截器</li><li>构造第一个Chain对象，交给第一个拦截器，发起责任两从上到下的处理。</li><li>拿到处理后的Response，开发者进行处理。</li></ol><p>实际上这里面的第2，3，4步在OkHttp里面都是封装了的。当然我们自己实现的时候肯定也得封装。</p><pre><code class="java">import interception.Interceptor;import interception.RealInterceptorChain;import interception.Request;import interception.Response;import java.util.ArrayList;import java.util.List;public class Main {    public static void main(String[] args) {        //1.构造Request        //2.构造拦截器容器        //3.添加内部的或外部的拦截器        //4.构造第一个Chain对象，交给第一个拦截器，发起责任两从上到下的处理。        //5.拿到处理后的Response，开发者进行处理。        //1        Request request = new Request();        //2        List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;();        //3        interceptors.add(chain -&gt; {            //修改Request            Request r = chain.request();            r.i = 100;            r.j = 99;            //将request向责任链下部传递。            return chain.proceed(r);        });        interceptors.add(chain -&gt; {            Request r = chain.request();            //最后一个Chain对象只有request方法起作用，用来获取Request，而不会调用proceed，在最后一个拦截器中生成Response直接返回而不再递归            Response response = new Response();            if (r.i == 100) {                response.param1 = String.valueOf(r.i);            }            if (r.j == 99) {                response.param2 = String.valueOf(r.j);            }            return response;        });        //4        RealInterceptorChain chain = new RealInterceptorChain(interceptors, 0, request);        Response response = chain.proceed(request);        //5        System.out.println(response.param1);        System.out.println(response.param2);    }}//打印：//100//99</code></pre><p>在这个测试里面有两个拦截器，第一个拦截器对Request的两个参数进行了赋值，一个100一个99，并没有处理下面返回的Response。第二个拦截器对Request的值进行了检查，生成了Response对象并赋值返回。过程如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-c86afc4540c52472.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>全文源码：<a href="https://github.com/HWilliamgo/EasyInterceptorChain/tree/master" target="_blank" rel="noopener">https://github.com/HWilliamgo/EasyInterceptorChain/tree/master</a><br></p>]]></content>
    
    
    <categories>
      
      <category>第三方库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Message-obtain()中的单链表栈缓存</title>
    <link href="/2019/01/16/Android/Message-obtain()%E4%B8%AD%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E6%A0%88%E7%BC%93%E5%AD%98/"/>
    <url>/2019/01/16/Android/Message-obtain()%E4%B8%AD%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%E6%A0%88%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Message-obtain-中的单链表栈缓存"><a href="#Message-obtain-中的单链表栈缓存" class="headerlink" title="Message.obtain()中的单链表栈缓存"></a>Message.obtain()中的单链表栈缓存</h1><p>Android中的Message.java用单链表实现了一个size=50的栈，用作缓存。以下结合源码和图分析存取过程。</p><h3 id="存"><a href="#存" class="headerlink" title="存"></a>存</h3><pre><code class="java">void recycleUnchecked() {    // Mark the message as in use while it remains in the recycled object pool.    // Clear out all other details.    flags = FLAG_IN_USE;    what = 0;    arg1 = 0;    arg2 = 0;    obj = null;    replyTo = null;    sendingUid = -1;    when = 0;    target = null;    callback = null;    data = null;    synchronized (sPoolSync) {        if (sPoolSize &lt; MAX_POOL_SIZE) {            next = sPool;            sPool = this;            sPoolSize++;        }    }}</code></pre><p><strong>调用时机</strong>：在Looper.loop中调用，具体地说在Handler.handleMessage()之后立刻调用。</p><pre><code class="java">public void static loop(){    final Looper me=Looper.myLopper();    final MessageQueue queue = me.mQueue;    for(;;){        //...        Message msg = queue.next();        msg.target.dispatchMessage(msg);        //上面的dispatchMessage最终执行到handler的handleMessasge了        msg.recycleUnchecked();    }}</code></pre><h3 id="取"><a href="#取" class="headerlink" title="取"></a>取</h3><pre><code class="java">public static Message obtain() {    synchronized (sPoolSync) {        if (sPool != null) {            Message m = sPool;            sPool = m.next;            m.next = null;            m.flags = 0; // clear in-use flag            sPoolSize--;            return m;        }    }    return new Message();}</code></pre><p><strong>调用时机：</strong>这个应该由开发者在需要Message对象的时候手动调用来获取缓存池中的Message对象。</p><h3 id="结合图来分析存取过程中单链表栈的变化"><a href="#结合图来分析存取过程中单链表栈的变化" class="headerlink" title="结合图来分析存取过程中单链表栈的变化"></a>结合图来分析存取过程中单链表栈的变化</h3><h4 id="第一次存取"><a href="#第一次存取" class="headerlink" title="第一次存取"></a>第一次存取</h4><ol><li>初始状态，sPool指向null。没有任何Messsage对象。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/7177220-0681293feda3b545.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="1547627128889.png"></p><ol start="2"><li><p>调用一次Message.obtain()。由于sPool==null，因此直接new Message()并返回给开发者使用，在用完后，Looper为其调用了 msg.recycleUnchecked();将其回收。</p><pre><code class="java">synchronized (sPoolSync) {    if (sPoolSize &lt; MAX_POOL_SIZE) {        next = sPool；//1        sPool = this;//2        sPoolSize++;//3    }}</code></pre><p>开始分析，此时还未执行代码段1,2,3。</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-2e803375a8817c6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="1547627414730.png"></p><p>执行1。（此时Message1.next实际上指向了Null）<br><img src="https://upload-images.jianshu.io/upload_images/7177220-32a6ac31cdecf1a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>执行2。（sPool引用指向了对象Message1）<br><img src="https://upload-images.jianshu.io/upload_images/7177220-6713a7ca06edb9d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p></li></ol><p>   执行3。将缓存池数量标记+1。</p><h4 id="第二次存取"><a href="#第二次存取" class="headerlink" title="第二次存取"></a>第二次存取</h4><ol><li>初始状态</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/7177220-6713a7ca06edb9d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><ol start="2"><li><p>开发者调用Messsage.obatin()来获取Message对象</p><pre><code class="java">public static Message obtain() {    synchronized (sPoolSync) {        if (sPool != null) {            Message m = sPool;//1            sPool = m.next;//2            m.next = null;//3            m.flags = 0; // clear in-use flag            sPoolSize--;            return m;//4        }    }    return new Message();}</code></pre><p>执行1。（创建一个Message m引用，指向了sPool所指向的对象Message1）<br><img src="https://upload-images.jianshu.io/upload_images/7177220-ead30088c7f79264.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="1547628442298.png"></p></li></ol><p>   执行2。（让sPool指向null）<br><img src="https://upload-images.jianshu.io/upload_images/7177220-b7b1f14b8e3b0dd7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="1547628468565.png"></p><p>   执行3。还是上面的原图</p><p>   执行4。将引用m返回，交给开发者，其指向了对象Message1，开发者可以拿着这个引用对其做处理。</p><ol start="3"><li>由Looper来调用msg.recycleUnchecked将其回收。其所有过程和第一次存取的回收过程如出一辙。</li></ol><h4 id="多次存取"><a href="#多次存取" class="headerlink" title="多次存取"></a>多次存取</h4><ol><li><p>一次性调用多次obtain，由于当缓存池中没有Message对象时，sPool指针就会==null，因此就会直接生成Message实例，如图：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-3779d68feb0c0c1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="1547628887922.png"></p></li><li><p>此时每一个Message都被handler处理完成，并准备一个一个被Looper回收。</p><p>执行Message1的回收：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-27506b615819d57b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="1547628987637.png"></p><p>执行Message2的回收：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-9ef3dfdc1be898e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="1547629051003.png"></p></li></ol><p>   执行Message3的回收<br> <img src="https://upload-images.jianshu.io/upload_images/7177220-87f8263db4bbcf96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="1547629167436.png"><br>   执行Message4的回收<br><img src="https://upload-images.jianshu.io/upload_images/7177220-08e7664e714d1744.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="1547629182292.png"></p><p><strong>如图，此时Message维护了一个单链表构成的栈，sPool指向栈顶</strong></p><p>当obtainMessage()时，创建一个引用指向sPool，即指向栈顶的Message4，将sPool指向Message4.next即Message3，再将Message4.next=null，将Message4对象脱离单链!<br>表，最后将引用返回给开发者，供开发者操纵对象Message4。图不再给出。</p><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Socket、描述符、端口号</title>
    <link href="/2018/12/16/%E7%BD%91%E7%BB%9C/Socket%E3%80%81%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E7%AB%AF%E5%8F%A3%E5%8F%B7/"/>
    <url>/2018/12/16/%E7%BD%91%E7%BB%9C/Socket%E3%80%81%E6%8F%8F%E8%BF%B0%E7%AC%A6%E3%80%81%E7%AB%AF%E5%8F%A3%E5%8F%B7/</url>
    
    <content type="html"><![CDATA[<h1 id="Socket、描述符、端口号"><a href="#Socket、描述符、端口号" class="headerlink" title="Socket、描述符、端口号"></a>Socket、描述符、端口号</h1><h2 id="端口："><a href="#端口：" class="headerlink" title="端口："></a>端口：</h2><h3 id="端口与进程对应："><a href="#端口与进程对应：" class="headerlink" title="端口与进程对应："></a>端口与进程对应：</h3><p>TCP 的包是不包含 IP 地址信息的，那是 IP 层上的事，但是有源端口和目的端口。<br>就是说，端口这一东西，是属于 TCP 知识范畴的。</p><p>我们知道两个进程，在计算机内部进行通信，可以有管道、内存共享、信号量、消息队列等方法。<br>而两个进程如果需要进行通讯最基本的一个前提是能够唯一的标识一个进程，在本地进程通讯中我们可以使用 <strong>「PID(进程标识符)」</strong> 来唯一标识一个进程。<br>但 PID 只在本地唯一，如果把两个进程放到了不同的两台计算机，然后他们要通信的话，PID 就不够用了，这样就需要另外一种手段了。</p><p>解决这个问题的方法就是在运输层使用 <strong>「协议端口号 (protocol port number)」</strong>，简称 <strong>「端口 (port)」</strong>.<br>我们知道 IP 层的 ip 地址可以唯一标识主机，而 TCP 层协议和端口号可以唯一标识主机的一个进程，这样我们可以利用：<strong>「ip地址＋协议＋端口号」</strong>唯一标示网络中的一个进程。<br>在一些场合，也把这种唯一标识的模式称为<strong>「套接字 (Socket)」</strong>。</p><h3 id="服务器端口："><a href="#服务器端口：" class="headerlink" title="服务器端口："></a>服务器端口：</h3><ol><li>熟知端口：范围从0到1023</li></ol><table><thead><tr><th>应用程序</th><th>FTP</th><th>TELNET</th><th>SMTP</th><th>DNS</th><th>TFTP</th><th>HTTP</th><th>HTTPS</th><th>SNMP</th></tr></thead><tbody><tr><td>熟知端口号</td><td><strong>21</strong></td><td>23</td><td>25</td><td>53</td><td>69</td><td><strong>80</strong></td><td><strong>443</strong></td><td>161</td></tr></tbody></table><ol start="2"><li>动态端口：范围从1024到65535。不固定分配某种服务，而是动态分配。动态分配是指一个系统进程或者引用程序需要网络通信时，它向主机申请一个端口，主机从可用端口号中分配一个供他使用。</li></ol><h3 id="客户端端口"><a href="#客户端端口" class="headerlink" title="客户端端口"></a>客户端端口</h3><p>取值范围：49152 ~ 65535。<br>这类端口仅在客户端进程运行时才动态选择。<br>又叫 短暂端口号，表示这种端口的存在时间是短暂的，客户进程并不在意操作系统给它分配的是哪一个端口号，因为客户进程之所以必须有一个端口号，是为了让传输层的实体能够找到自己。</p><h2 id="描述符"><a href="#描述符" class="headerlink" title="描述符"></a>描述符</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li><p>一个TCP连接的套接字对（socket pair）是一个定义该连接的两个端点的四元组：本地IP地址、本地TCP端口、外地地址、外地TCP端口。套接字对唯一标识一个网络上的每个TCP连接。</p></li><li><p>标识每个端口的两个值（IP地址和端口号）通常称为一个套接字。</p></li><li><p>Socket最初作为UNIX操作系统的一部分而开发的，所以其API和系统其他IO设备集成在一起，当创建一个Socket是，操作系统返回一个int型的变量作为描述符，用来标志这个Socket，然后应用程序通过该描述符作为传递参数，通过调用函数来完成收发网络数据。</p></li><li><p>Socket描述符是一个指向内部数据结构的指针，它指向描述符表入口。调用Socket函数时，socket执行体将建立一个Socket，实际上”建立一个Socket”意味着为一个Socket数据结构分配存储空间。 Socket执行体为你管理描述符表。</p></li></ol><p>理解：描述符就类似于Java中的引用变量，而操作系统中的C语言并没有面向对象，没有引用变量和对象之说，因此需要用描述符来指向之前创建的Socket数据结构，来操纵它完成网络操作。</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>如果说描述符是用来在一台计算机内部识别套接字的机制,那么端口号就是用来让通信的另一方能够识别出套接字的机制 。</p><blockquote><p>来自：</p><p><a href="https://github.com/JerryC8080/understand-tcp-udp" target="_blank" rel="noopener">https://github.com/JerryC8080/understand-tcp-udp</a></p><p><a href="https://www.cnblogs.com/davidzhou11225/archive/2012/05/03/2480347.html" target="_blank" rel="noopener">https://www.cnblogs.com/davidzhou11225/archive/2012/05/03/2480347.html</a></p><p>《网络是怎样连接的》<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android文件api获得的路径</title>
    <link href="/2018/12/02/Android/Android%E6%96%87%E4%BB%B6api%E8%8E%B7%E5%BE%97%E7%9A%84%E8%B7%AF%E5%BE%84/"/>
    <url>/2018/12/02/Android/Android%E6%96%87%E4%BB%B6api%E8%8E%B7%E5%BE%97%E7%9A%84%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<h2 id="InternalStorage"><a href="#InternalStorage" class="headerlink" title="InternalStorage"></a>InternalStorage</h2><p><code>/data/user/0</code>等同于<code>/data/data</code></p><pre><code class="java">context.getFilesDir();//路径：/data/user/0/包名/files</code></pre><pre><code class="java">context.getCacheDir();//路径：/data/user/0/包名/cache</code></pre><pre><code class="java">context.getDir(&quot;abc&quot;,MODE_PRIVATE);//路径：/data/user/0/包名/app_abc</code></pre><pre><code class="java">contexnt.createTmpFile(&quot;myTmp&quot;,&quot;.suffix&quot;);//路径：/data/user/0/包名/cache/myTmp一串随机数字.suffix</code></pre><h2 id="ExternalStorage"><a href="#ExternalStorage" class="headerlink" title="ExternalStorage"></a>ExternalStorage</h2><p><code>/storage/emulated/0</code>等同于<code>/sdcard</code></p><pre><code class="java">context.getExternalCacheDir();//路径：/storage/emulated/0/Android/data/包名/cache</code></pre><pre><code class="java">context.getExternalFilesDir();//路径：/storage/emulated/0/Android/data/包名/files</code></pre><p>关于<code>InternalStorage</code>和<code>ExternalStorage</code>的详细介绍跳转文档：</p><p><a href="https://developer.android.com/training/data-storage/files#WriteExternalStorage" target="_blank" rel="noopener">https://developer.android.com/training/data-storage/files#WriteExternalStorage</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Gradle构建的生命周期和其对象的理解</title>
    <link href="/2018/11/11/Gradle/Gradle%E6%9E%84%E5%BB%BA%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%85%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2018/11/11/Gradle/Gradle%E6%9E%84%E5%BB%BA%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%85%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章主题内容来自<code>Gradle官方文档</code>的<code>Understanding the Build Lifecycler</code>章节。通读完该章节，大大加深了我对task对象，project对象，gradle.build脚本和project对象的关系等这3个概念的理解。</p><p>官方文档地址：<a href="https://docs.gradle.org/current/userguide/build_lifecycle.html#sub:building_the_tree" target="_blank" rel="noopener">https://docs.gradle.org/current/userguide/build_lifecycle.html#sub:building_the_tree</a></p></blockquote><p><img src="https://upload-images.jianshu.io/upload_images/7177220-dddeef0781734dae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><h2 id="构建的不同阶段"><a href="#构建的不同阶段" class="headerlink" title="构建的不同阶段"></a>构建的不同阶段</h2><p>一个<code>gradle</code>的构建有3个不同的阶段</p><ol><li><p>初始化（Initialization）</p><p>Gradle支持单和多project的构建。在初始化阶段，gradle决定了哪一个或哪些project将要参与到这次构建，并且为每个project创建一个<code>Project</code>对象。（注意，一个project对应一个build.gradle文件）</p></li><li><p>安装（Configuration）</p><p>在这个阶段，<code>Project</code>对象被安装(个人猜测是执行Project对象的构造函数)。所有参与到这次构建的build.gradle脚本文件都会被执行。</p></li><li><p>执行（Execution）</p><p>在此阶段，gradle将会决定在安装(Configuration)阶段所创建和装配的tasks的哪些子集tasks要被执行。被执行的那些task是通过<code>gradle</code>命令的参数中的task的名字和当前在哪个目录下来决定的。gradle然后执行每一个被选中的task。</p></li></ol><h2 id="settings-gradle"><a href="#settings-gradle" class="headerlink" title="settings.gradle"></a>settings.gradle</h2><ol><li>除了<code>build.gradle</code>脚本之外，gradle还定义了一个<code>settings.gradle</code>文件。这个文件会在初始化(initialization)阶段被执行。</li><li>一个multi-project的构建必须有一个<code>settings.gradle</code>文件在根目录。因为后者定义了哪些project(也就是build.gradle脚本)会参与到这个构建。当然，单project(单个build.gradle脚本)的情况下，<code>settings.gradle</code>可有可无。</li></ol><h2 id="3个不同阶段在构建中的执行顺序"><a href="#3个不同阶段在构建中的执行顺序" class="headerlink" title="3个不同阶段在构建中的执行顺序"></a>3个不同阶段在构建中的执行顺序</h2><h3 id="1-定义了3个task来分别查看他们执行时打印的情况"><a href="#1-定义了3个task来分别查看他们执行时打印的情况" class="headerlink" title="1. 定义了3个task来分别查看他们执行时打印的情况"></a>1. 定义了3个task来分别查看他们执行时打印的情况</h3><ol><li><p><code>settings.gradle</code>文件</p><pre><code class="groovy">println(&#39;initialization：settings.gradle被执行&#39;)</code></pre></li><li><p><code>build.gradle</code>文件</p><pre><code class="groovy">println(&#39;configuration：build.gradle&#39;)task configured{    println(&#39;configuration:task configured&#39;)}task A{    println(&#39;configuration:task A&#39;)    doLast{        println &#39;这里执行task:A#doLast&#39;    }}task B {    doFirst{        println &#39;这里执行task:B#doFirst&#39;    }    doLast{        println &#39;这里执行task:B#doLast&#39;    }    println &#39;configuration:task B&#39;}</code></pre></li><li><p><code>$ gradle configured</code></p><pre><code class="shell">william@localhost:~/IdeaProjects/1$ gradle configuredinitialization：settings.gradle被执行&gt; Configure project : configuration：build.gradleconfiguration:task configuredconfiguration:task Aconfiguration:task B</code></pre></li><li><p><code>$ gradle A</code></p><pre><code class="shell">initialization：settings.gradle被执行&gt; Configure project : configuration：build.gradleconfiguration:task configuredconfiguration:task Aconfiguration:task B&gt; Task :A 这里执行task:A#doLast</code></pre></li><li><p><code>$ gradle B</code></p><pre><code class="shell">并被添加到Project对象的一个字段TaskContainer tasks中，initialization：settings.gradle被执行&gt; Configure project : configuration：build.gradleconfiguration:task configuredconfiguration:task Aconfiguration:task B&gt; Task :B 这里执行task:B#doFirst这里执行task:B#doLast</code></pre></li><li><p><code>$ gradle A B</code></p><pre><code class="shell">initialization：settings.gradle被执行&gt; Configure project : configuration：build.gradleconfiguration:task configuredconfiguration:task Aconfiguration:task B&gt; Task :A 这里执行task:A#doLast&gt; Task :B 这里执行task:B#doFirst这里执行task:B#doLast</code></pre></li></ol><h3 id="2-结论"><a href="#2-结论" class="headerlink" title="2. 结论"></a>2. 结论</h3><ol><li><p>初始化阶段执行settings.gradle脚本中的内容，</p></li><li><p>安装阶段执行build.gradle脚本中除了<code>task.doLast(Closure c)</code>和<code>task.doFirst(Closure c)</code>中的所有内容。因为在安装阶段时，该<code>build.gradle</code>文件对应的<code>Project</code>对象已经创建，此时安装阶段对应的就是<code>Project</code>对象执行其构造方法。而上述代码中在<code>build.gradle</code>中定义了3个task，那么在安装阶段，这3个task就会被创建为3个task对象实例，并且被加入到<code>Project</code>对象的<code>TaskContainer</code>容器中，此后，这3个task实例就作为<code>Project</code>对象的属性，可以直接使用了。</p></li><li><p>执行阶段，根据输入的task的名称和相关依赖（如果存在），去遍历执行对应的task对象中</p><pre><code class="java">private List&lt;ContextAwareTaskAction&gt; actions=new ArrayList&lt;&gt;();</code></pre><p>的所有的方法，而当我们调用<code>doLast</code>或者<code>doFirst</code>都是往那个<code>ArrayList</code>的头尾插入由我们传入的闭包而转化成的<code>Action</code>接口的对象。而<code>Action</code>接口长这样：</p><pre><code class="java">@HasImplicitReceiverpublic interface Action&lt;T&gt; {    void execute(T t);}</code></pre><p>那么到执行阶段，这个task的<code>Action</code>的容器<code>actions</code>就会被遍历并调用每个<code>Action</code>的<code>execute(T t)</code>方法。</p></li></ol><h2 id="响应build-gradle脚本的生命周期"><a href="#响应build-gradle脚本的生命周期" class="headerlink" title="响应build.gradle脚本的生命周期"></a>响应build.gradle脚本的生命周期</h2><h3 id="1-Project的安装"><a href="#1-Project的安装" class="headerlink" title="1. Project的安装"></a>1. Project的安装</h3><p>build.gradle中的内容依靠<code>Project</code>对象的构造方法来安装<code>Project</code>对象，其中有两个回调暴露给我们，分别是</p><pre><code>afterEvalueate(Closure closure)beforeEvalueate(Closure closure)</code></pre><p>它们属于<code>Project</code>接口中就定义了的方法，因此直接用就行</p><p>build.gradle：</p><pre><code class="groovy">afterEvaluate {    if (it.hasProperty(&#39;group&#39;)) {        println(&#39;has group&#39;)        it.task(&#39;B&#39;){            doLast{                println &#39;execute B&#39;            }        }    } else {        println(&#39;do not have group&#39;)    }}task A {    println(&#39; configure A&#39;)}</code></pre><p>执行task B</p><pre><code class="shell">william@localhost:~/IdeaProjects/1$ gradle B&gt; Configure project : configure Ahas task A&gt; Task :B execute BBUILD SUCCESSFUL in 0s1 actionable task: 1 executed</code></pre><p>执行结果如上，<code>Project#afterEvaluated(Closure closure)</code>方法会在<code>Project</code>对象全部安装完之后被调用，这也是其构造方法暴露给客户端的回调，那么<code>Project</code>对象的构造方法的伪代码如下：</p><pre><code class="java">public ProjectImpl(){    runClosureBeforeEvalueation();//执行安装前的闭包    configureCodeInSript();//安装    runClosureAfterEvalueation();//执行安装后的闭包    }</code></pre><h3 id="2-Task的创建"><a href="#2-Task的创建" class="headerlink" title="2. Task的创建"></a>2. Task的创建</h3><p>在一个task对象被添加到一个<code>Project</code>对象后，可以立刻收到一个回调。</p><p>用<code>tasks.whenTaskAdded(Closure closure)</code>就可以办到</p><p>build.gradle：</p><pre><code class="groovy">tasks.whenTaskAdded {    println(it.name)}task A {    println(&#39;configure A&#39;)}task B {    println &#39;configure B&#39;}</code></pre><p>执行task A</p><pre><code class="shell">william@localhost:~/IdeaProjects/1$ gradle A&gt; Configure project : Aconfigure ABconfigure B</code></pre><h3 id="3-Task的执行"><a href="#3-Task的执行" class="headerlink" title="3.Task的执行"></a>3.Task的执行</h3><pre><code class="groovy">gradle.taskGraph.addTaskExecutionListener(new TaskExecutionListener() {    @Override    void beforeExecute(Task task) {    }    @Override    void afterExecute(Task task, TaskState state) {    }})gradle.taskGraph.beforeTask {}gradle.taskGraph.afterTask {}</code></pre><p>上面的接口的方法和下面的两个闭包方法的作用都是一样的，我认为他们相比于<code>Task#doFirst</code>或者<code>Task#doLast</code>方法的优点在于，<code>TaskExecutionGraph</code>的这几个方法，是为每一个安装了的task对象都插入一段回调，这段回调在每一个task执行前后被调用。</p><hr><p>个人总结：</p><ol><li>在执行build.gradle之前，他所对应的<code>Project</code>对象已然创建，猜测是在执行<code>settings.gradle</code>时已经创建了。</li><li>build.gradle中的所有代码，都作为<code>Project</code>对象的构造函数一部分而插入构造函数。</li><li>在build.gradle脚本中创建的所有Task对象都在创建后都被<code>Project</code>对象的<code>TaskContainer</code>这个容器对象引用。</li><li>命令行每执行一次gradle命令，就创建一个程序，从类似java的<code>main</code>方法开始运行。创建<code>Project</code>对象，执行build.gradle脚本来安装(在他的构造方法中)，而gradle命令后面跟随的是task的名字，此时装配好<code>Project</code>对象后，根据传入的task的名字来去直接执行这个task。当task执行完毕输出结果后，程序结束，<code>main()</code>方法结束。</li><li>当直接执行gradle命令而不加task，也会依然会执行build.gradle中为<code>Project</code>装配而存在的代码，即此时<code>Project</code>对象存在，但是只是不去execute task了。</li></ol><p><strong>以上，为总结和对gradle运行原理的猜想，待考证更多资料后证实之。</strong><br></p>]]></content>
    
    
    <categories>
      
      <category>Gradle</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu下配置java，gradle，groovy，androidSdk，androidNdk环境变量</title>
    <link href="/2018/11/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ubuntu%E4%B8%8B%E9%85%8D%E7%BD%AEjava%EF%BC%8Cgradle%EF%BC%8Cgroovy%EF%BC%8CandroidSdk%EF%BC%8CandroidNdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2018/11/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ubuntu%E4%B8%8B%E9%85%8D%E7%BD%AEjava%EF%BC%8Cgradle%EF%BC%8Cgroovy%EF%BC%8CandroidSdk%EF%BC%8CandroidNdk%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="1-下载"><a href="#1-下载" class="headerlink" title="1. 下载"></a>1. 下载</h2><p>到官网下载各自对应的压缩包并解压。注意，如果提前用AndroidStudio下载了gradle，那么可以直接在<code>~/.gradle/wrapper/dists/</code>下找到已经下载了的gradle。</p><h2 id="2-配置"><a href="#2-配置" class="headerlink" title="2.配置"></a>2.配置</h2><p>命令行</p><ol><li>用gedit打开profile配置文件<pre><code class="shell">$ sudo gedit /etc/profile</code></pre></li><li>拉倒最底部，依次根据自己的下载路径加入如下配置<pre><code># set java environmentexport JAVA_HOME=/home/william/下载/jdk-8u181-linux-x64/jdk1.8.0_181export PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</code></pre></li></ol><h1 id="set-gradle-environment"><a href="#set-gradle-environment" class="headerlink" title="set gradle environment"></a>set gradle environment</h1><p>export GRADLE_HOME=/home/william/.gradle/wrapper/dists/gradle-4.6-all/bcst21l2brirad8k2ben1letg/gradle-4.6<br>export PATH=${JAVA_HOME}/bin:${JRE_HOME}/bin:${GRADLE_HOME}/bin:${JAVA_HOME}:${PATH}</p><h1 id="set-groovy-environment"><a href="#set-groovy-environment" class="headerlink" title="set groovy environment"></a>set groovy environment</h1><p>export GROOVY_HOME=”/home/william/公共的/apache-groovy-sdk-2.5.3/groovy-2.5.3”<br>export PATH=$GROOVY_HOME/bin:$PATH</p><h1 id="set-androd-sdk-environment"><a href="#set-androd-sdk-environment" class="headerlink" title="set androd sdk environment"></a>set androd sdk environment</h1><p>export ANDROID_SDK=/home/hwilliamgo/Android/Sdk<br>export PATH=$ANDROID_SDK/tools:$ANDROID_SDK/platform-tools:$PATH</p><h1 id="set-android-ndk-environment"><a href="#set-android-ndk-environment" class="headerlink" title="set android ndk environment"></a>set android ndk environment</h1><p>export ANDROID_SDK=/home/hwilliamgo/Android/Sdk<br>export PATH=$ANDROID_SDK/tools:$ANDROID_SDK/platform-tools:$PATH</p><pre><code>3. 保存，查验执行` source /etc/profile`使环境变量生效检查jdk设置是否生效``` shell$ java -versionjava version &quot;1.8.0_181&quot;Java(TM) SE Runtime Environment (build 1.8.0_181-b13)Java HotSpot(TM) 64-Bit Server VM (build 25.181-b13, mixed mode)</code></pre><p>检查gradle设置是否生效</p><pre><code class="shell">$ gradle -version------------------------------------------------------------Gradle 4.6------------------------------------------------------------Build time:   2018-02-28 13:36:36 UTCRevision:     8fa6ce7945b640e6168488e4417f9bb96e4ab46cGroovy:       2.4.12Ant:          Apache Ant(TM) version 1.9.9 compiled on February 2 2017JVM:          1.8.0_181 (Oracle Corporation 25.181-b13)OS:           Linux 4.15.0-38-generic amd64</code></pre><p>检查groovy设置是否生效</p><pre><code class="shell">$ groovy -versionGroovy Version: 2.5.3 JVM: 1.8.0_181 Vendor: Oracle Corporation OS: Linux</code></pre><p>检查android sdk设置是否生效</p><pre><code class="shell">$ android*************************************************************************The &quot;android&quot; command is deprecated.For manual SDK, AVD, and project management, please use Android Studio.For command-line tools, use tools/bin/sdkmanager and tools/bin/avdmanager*************************************************************************Invalid or unsupported command &quot;&quot;Supported commands are:android list targetandroid list avdandroid list deviceandroid create avdandroid move avdandroid delete avdandroid list sdkandroid update sdk</code></pre><p>检查android ndk设置是否生效</p><pre><code class="shell">$ ndk-build -vGNU Make 3.81Copyright (C) 2006  Free Software Foundation, Inc.This is free software; see the source for copying conditions.There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR APARTICULAR PURPOSE.This program built for x86_64-pc-linux-gnu</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git在github上的操作的版本回退</title>
    <link href="/2018/10/08/git/git%E5%9C%A8github%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%9A%84%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/"/>
    <url>/2018/10/08/git/git%E5%9C%A8github%E4%B8%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%9A%84%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80/</url>
    
    <content type="html"><![CDATA[<h1 id="git在github上的操作的版本回退"><a href="#git在github上的操作的版本回退" class="headerlink" title="git在github上的操作的版本回退"></a>git在github上的操作的版本回退</h1><ol><li>找到你要回退的版本快照的<code>hashCode</code></li><li><code>git reset --hard hashCode</code> 将本地的head指针指向<code>hashCode</code>代表的版本快照。</li><li><code>git push -f</code>将当前指针强制推送到远程，操作之后github上的版本快照回到原来的样子。（强制push之前一定要再看一眼head指针指向的版本快照是你想要的原来的样子）<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu下android-studio同步踩坑</title>
    <link href="/2018/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Ubuntu%E4%B8%8Bandroid-studio%E5%90%8C%E6%AD%A5%E8%B8%A9%E5%9D%91/"/>
    <url>/2018/09/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/Ubuntu%E4%B8%8Bandroid-studio%E5%90%8C%E6%AD%A5%E8%B8%A9%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<h1 id="Ubuntu下android-studio同步踩坑"><a href="#Ubuntu下android-studio同步踩坑" class="headerlink" title="Ubuntu下android studio同步踩坑"></a>Ubuntu下android studio同步踩坑</h1><h3 id="1-安装shadowsocks-https-blog-csdn-net-A807296772-article-details-80112871"><a href="#1-安装shadowsocks-https-blog-csdn-net-A807296772-article-details-80112871" class="headerlink" title="1. 安装shadowsocks : https://blog.csdn.net/A807296772/article/details/80112871"></a>1. 安装shadowsocks : <a href="https://blog.csdn.net/A807296772/article/details/80112871" target="_blank" rel="noopener">https://blog.csdn.net/A807296772/article/details/80112871</a></h3><h3 id="2-shadowsocks配置"><a href="#2-shadowsocks配置" class="headerlink" title="2. shadowsocks配置"></a>2. shadowsocks配置</h3><ol><li><p>打开客户端</p></li><li><p>根据购买的账号和密码和服务器地址配置：</p></li><li><p>注意，本地服务器类型不能选择socks5，而是选择第二个HTTP(S)，否则android studio的gradle无法走代理。</p></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/7177220-fb5af5f0973e767a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><h3 id="3-配置本地代理"><a href="#3-配置本地代理" class="headerlink" title="3. 配置本地代理"></a>3. 配置本地代理</h3><p><img src="https://upload-images.jianshu.io/upload_images/7177220-93d3e65be75043cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>不要配成socks主机，就配HTTP代理和HTTPS代理。</p><h3 id="4-配置Android-studio代理"><a href="#4-配置Android-studio代理" class="headerlink" title="4. 配置Android studio代理"></a>4. 配置Android studio代理</h3><p><img src="https://upload-images.jianshu.io/upload_images/7177220-77aaadafaa6ce025.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>完成。折腾了接近半天。<br></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ubuntu--下的android-studio的真机调试</title>
    <link href="/2018/09/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ubuntu--%E4%B8%8B%E7%9A%84android-studio%E7%9A%84%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/"/>
    <url>/2018/09/02/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ubuntu--%E4%B8%8B%E7%9A%84android-studio%E7%9A%84%E7%9C%9F%E6%9C%BA%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="ubuntu-下的android-studio的真机调试"><a href="#ubuntu-下的android-studio的真机调试" class="headerlink" title="ubuntu  下的android studio的真机调试"></a>ubuntu  下的android studio的真机调试</h1><blockquote><p> 直接连真机一般都是连不上adb的。</p></blockquote><h3 id="1-找出真机的硬件id"><a href="#1-找出真机的硬件id" class="headerlink" title="1. 找出真机的硬件id"></a>1. 找出真机的硬件id</h3><pre><code class="shell"># 列出当前链接的设备$ lsusb</code></pre><pre><code>Bus 002 Device 002: ID 8087:8000 Intel Corp. Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 001 Device 002: ID 8087:8008 Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 003 Device 005: ID 8087:07dc Intel Corp. Bus 003 Device 004: ID 04f2:b439 Chicony Electronics Co., Ltd Bus 003 Device 002: ID 04b4:2009 Cypress Semiconductor Corp. Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</code></pre><p>将手机与电脑插上usb并链接。再次列出当前设备</p><pre><code class="shell">$ lsusb# 此时肯定比之前会多出一个设备</code></pre><pre><code class="shell">Bus 002 Device 002: ID 8087:8000 Intel Corp. Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 001 Device 002: ID 8087:8008 Intel Corp. Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hubBus 004 Device 001: ID 1d6b:0003 Linux Foundation 3.0 root hubBus 003 Device 005: ID 8087:07dc Intel Corp. #就是这个了。Bus 003 Device 009: ID 0e8d:201c MediaTek Inc. Bus 003 Device 004: ID 04f2:b439 Chicony Electronics Co., Ltd Bus 003 Device 002: ID 04b4:2009 Cypress Semiconductor Corp. Bus 003 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub</code></pre><p><code>Bus 003 Device 009: ID 0e8d:201c MediaTek Inc.</code>我的这台手机是魅族，这个<code>0e8d</code>就是这个硬件的id，记录下来。</p><h3 id="2-修改配置，重启服务。"><a href="#2-修改配置，重启服务。" class="headerlink" title="2. 修改配置，重启服务。"></a>2. 修改配置，重启服务。</h3><p>在<code>/etc/udev/rules.d/</code>目录下用命令行新建一个<code>70-android.rules</code>文件</p><pre><code class="shell">$ sudo gedit 70-android.rules</code></pre><p>此时用<code>gedit</code>编辑器打开了文本文件，内容填入</p><pre><code>SUBSYSTEM==&quot;usb&quot;, ATTR{idVendor}==&quot;0e8d″, MODE=&quot;0666″</code></pre><p>保存并关闭。</p><p>命令行执行以下命令重启服务。</p><pre><code class="shell">$ sudo /etc/init.d/udev restart</code></pre><h3 id="3-链接adb"><a href="#3-链接adb" class="headerlink" title="3. 链接adb"></a>3. 链接adb</h3><pre><code class="shell">$ adb kill-server# XXX$ adb start-server# XXX$ adb devicesList of devices attachedA02AACPPGN43E    device</code></pre><hr><p>END</p><p>thanks:<a href="https://blog.csdn.net/u010214802/article/details/54603457" target="_blank" rel="noopener">https://blog.csdn.net/u010214802/article/details/54603457</a><br></p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>requestLayout()引起的问题</title>
    <link href="/2018/08/31/View/requestLayout()%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2018/08/31/View/requestLayout()%E5%BC%95%E8%B5%B7%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="requestLayout-引起的问题"><a href="#requestLayout-引起的问题" class="headerlink" title="requestLayout()引起的问题"></a>requestLayout()引起的问题</h1><blockquote><p>网上有大量写的很深入的<code>requestLayout()</code>源码分析的文章。故这里不再写了，只做一个实际情况下遇到的问题的分析。</p><p>起因：</p><p>自定义了一个<code>CircleImageView</code>，功能是调用<code>setImage(Bitmap bitmap)</code>后可以将图片以圆形加载。</p><p>本以为直接在<code>setImage(Bitmap)</code>的结尾直接调用<code>requestLayout()</code>即可。</p></blockquote><p>这里从两个方面写：</p><h3 id="xml中定义为wrap-content"><a href="#xml中定义为wrap-content" class="headerlink" title="xml中定义为wrap_content"></a>xml中定义为wrap_content</h3><p>当<code>LayoutParams</code>是<code>wrap_content</code>时，我处理的逻辑是：在<code>onMeasure()</code>中根据宽高的<code>MeasureSpec</code>是否等于<code>MeasureSpec.AT_MOST</code>，如果等于，那么在第一次绘制的时候，<code>setMeasureDimension()</code>都设置成0，而当调用了<code>setBitmap()</code>时，获取图片的宽高并保存，然后调用<code>requestLayout()</code>，此举引起<code>onMeasure()</code>，那么在此处将图片的宽高设置到<code>setMeasureDimension()</code>中，而整体的View的测量大小就是图片大小了。</p><p>此时我的<code>onMeasure</code>和<code>setBitmap</code>长这样：</p><pre><code class="java">@Overrideprotected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {    Log.d(TAG, &quot;onMeasure: &quot;);    int ws = MeasureSpec.getSize(widthMeasureSpec);    int hs = MeasureSpec.getSize(heightMeasureSpec);    int wm = MeasureSpec.getMode(widthMeasureSpec);    int hm = MeasureSpec.getMode(heightMeasureSpec);    //如果子view是wrap_content，那么view就设置成bitmap的大小。    if (wm == MeasureSpec.AT_MOST) {        ws = bitmapW;    }    if (hm == MeasureSpec.AT_MOST) {        hs = bitmapH;    }    int resultW = MeasureSpec.makeMeasureSpec(ws, wm);    int resultH = MeasureSpec.makeMeasureSpec(hs, hm);    super.onMeasure(resultW, resultH);}public void setImage(Bitmap bitmap) {    mBitmap = bitmap;    bitmapH = mBitmap.getHeight();    bitmapW = mBitmap.getWidth();    requestLayout();//最后要调用一个requestLayout，引起onMeasure()和onLayout()。}</code></pre><h4 id="大小不同的两张图片"><a href="#大小不同的两张图片" class="headerlink" title="大小不同的两张图片"></a>大小不同的两张图片</h4><p>此时为这个<code>CircleImageView</code>准备了两张分辨率不同的图片，点击按钮A加载图片A，点击按钮B加载图片B。</p><p>点击情况：</p><ol><li>由显示A的情况下加载B，或者显示B的情况下加载A，或者从没有图片情况下点击加载Ａ或Ｂ，分别引起了<code>onMeasure()</code>,<code>onSizeChanged（）</code>,<code>onLayout()</code>,<code>onDraw</code>回调。成功地在<code>onDraw</code>重新<code>drawBitmap()</code>切换了图片。</li><li>当在A图片下点击按钮A，或者在B图片下点击按钮B。只引起了<code>onMeasure()</code>和<code>onLayout()</code>回调。这里少了一个<code>onSizeChanged()</code>很好理解，因为在该情况下，<code>setMeasureDimesion()</code>传入的值和上一次一样，View中可以很容易通过这种判断而跳过<code>onSizeChanged()</code>回调，而至于为什么<code>onDraw（）</code>回调没有引起，这点我也很疑惑。</li></ol><h4 id="大小相同的两张图片"><a href="#大小相同的两张图片" class="headerlink" title="大小相同的两张图片"></a>大小相同的两张图片</h4><p>此时我又准备了两张大小相同的图片。操作和上述一样。</p><p>点击情况：</p><ol><li>从没有图片的情况下点击加载图片Ａ:<code>onMeasure()</code>,<code>onSizeChanged（）</code>,<code>onLayout()</code>,<code>onDraw</code></li><li>从图片Ａ点击加载图片Ｂ：加载失败，图片仍然停留在图片Ａ，此时的回调是：<code>onMeasure()</code>和｀onLayout()｀</li><li>图片Ａ点击加载图片Ａ:　同２。</li></ol><h4 id="推论：-在wrap-content情况下"><a href="#推论：-在wrap-content情况下" class="headerlink" title="推论：(在wrap_content情况下)"></a>推论：(在wrap_content情况下)</h4><ol><li>当<code>requestLayout()</code>调用时，一定会引起<code>onMeasure()</code>和<code>onLayout()</code>。</li><li>当<code>requestLayout()</code>调用时，如果没有在<code>setMeasureDimension()</code>中传入和上次不同的测量值的话，一定不会引起<code>onSizeChanged()</code>和<code>onDraw()</code>。<code>onSizeChanged()</code>不被调用的原因很容易在<code>onLayout()</code>的源码中找到答案，而<code>onDraw()</code>不引起回调的原因目前还不明白。</li></ol><h3 id="xml中定义为精确值"><a href="#xml中定义为精确值" class="headerlink" title="xml中定义为精确值"></a>xml中定义为精确值</h3><ol><li><p>情况：此时图片直接无法加载。仅仅在第一次实例化CircleImageView的时候会依次调用<code>onMeasure()</code>,<code>onSizeChanged（）</code>,<code>onLayout()</code>,<code>onDraw</code>，伺候每一次调用<code>setImage()</code>都只会引起<code>onMeasure()</code>和<code>onLayout()</code>。</p></li><li><p>原因：因为在<code>requestLayout()</code>调用后，因为此时的测量模式是<code>EXACTLY</code>，因此<code>setMeasuredDimension()</code>中传入的值永远不变，永远都是xml中定义的那个精确值。而上文的推论中指出，<code>setMeasuredDimension()</code>传入的值等于原本的测量值的话，直接引起<code>onSizeChanged()</code>和<code>onDraw()</code>无法调用。</p></li></ol><hr><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>上文中的推论</li><li>不能依赖<code>requestLayout</code>来引起<code>onDraw()</code>回调，如果百分之百确定要绘制，直接调用<code>invalidate()</code>或<code>postInvalidate()</code>，他们只会引起<code>onDraw()</code>的回调。</li><li>CircleImageView源码：<a href="https://github.com/William619499149/anddroid-little-bubble/blob/master/CircleImageView.java" target="_blank" rel="noopener">https://github.com/William619499149/anddroid-little-bubble/blob/master/CircleImageView.java</a><br></li></ol>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Tue Aug 21 2018 00:00:00 GMT+0000 (Coordinated Universal Time)</title>
    <link href="/2018/08/21/git/2018-08-21/"/>
    <url>/2018/08/21/git/2018-08-21/</url>
    
    <content type="html"><![CDATA[<p>git push失败时：</p><pre><code>git fetchgit rebase origin/XXXgit push</code></pre><p>git要压缩历史</p><pre><code>git merge -squash &lt;name&gt;或者git rebase -i HEAD~n</code></pre><p>撤销工作区某个文件的改动</p><pre><code>git checkout -- 文件名</code></pre><p>撤销工作区所有文件的改动</p><pre><code>git checkout .//当暂存区为空，回到当前的版本快照。暂存区不为空，回到上个暂存区。</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Integer++</title>
    <link href="/2018/08/18/Java/Integer++/"/>
    <url>/2018/08/18/Java/Integer++/</url>
    
    <content type="html"><![CDATA[<h1 id="Integer"><a href="#Integer" class="headerlink" title="Integer++"></a>Integer++</h1><blockquote><p>在写一个线程同步的demo的时候，想用Integer作为对象传入各个Runnable中作为flag，自增，然后发现失败，探究原因后记录如下：</p></blockquote><pre><code class="java">public class Main {    public static void main(String[] args) {        Integer i = 10;        Integer j = i++;        System.out.println(i == j);    }}</code></pre><p>输出：<code>false</code></p><p>原因：</p><p>Integer中表示值的变量<code>value</code>本身就是一个<code>final</code>类型的，即不可变类型，不可重新赋值。</p><pre><code class="java">private final int value;</code></pre><p>那么当<code>Integer++</code>时，只能去重新创建一个<code>Integer对象</code>，获取从缓存中<code>IntegerCache</code>这个数组缓存中取出现成的<code>Integer</code>对象。</p><p>当<code>Integer++</code>时，首先调用<code>intValue()</code>自动拆箱</p><pre><code class="java">public int intValue() {    return value;}</code></pre><p>返回的<code>value</code>自增后，用<code>valueOf(int i)</code>自动装箱，然后返回一个新的<code>Integer</code>对象。</p><pre><code class="java">public static Integer valueOf(int i) {    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)        return IntegerCache.cache[i + (-IntegerCache.low)];    return new Integer(i);}</code></pre><p>当<code>i</code>的值在区间<code>[IntegerCache.low , IntegerCache.high]</code>时，返回<code>IntegerCache.cahce</code>这个静态数组中的元素。</p><pre><code class="java">private static class IntegerCache {    static final int low = -128;    static final int high;    static final Integer cache[];//静态数组    //静态代码块中直接初始化了静态数组。    static {        // high value may be configured by property        int h = 127;        String integerCacheHighPropValue =            sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);        if (integerCacheHighPropValue != null) {            try {                int i = parseInt(integerCacheHighPropValue);                i = Math.max(i, 127);                // Maximum array size is Integer.MAX_VALUE                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);            } catch( NumberFormatException nfe) {                // If the property cannot be parsed into an int, ignore it.            }        }        high = h;        cache = new Integer[(high - low) + 1];        int j = low;        for(int k = 0; k &lt; cache.length; k++)            cache[k] = new Integer(j++);        // range [-128, 127] must be interned (JLS7 5.1.7)        assert IntegerCache.high &gt;= 127;    }    private IntegerCache() {}}</code></pre><p>结论：在<code>int</code>取值为<code>[-128 , 127]</code>时，从静态数组中直接取出现有的<code>Integer</code>对象。不在这个区间时，直接new出<code>Integer</code>对象。<br></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ThreadLocal</title>
    <link href="/2018/08/16/Java/ThreadLocal/"/>
    <url>/2018/08/16/Java/ThreadLocal/</url>
    
    <content type="html"><![CDATA[<h1 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h1><blockquote><p><code>ThreadLocal</code>是一个线程独立存储类，通过他的<code>get</code>和<code>set</code>方法，在不同的线程中，可以独立地存取不同的<code>value</code>。</p><p>每次回顾<code>Looper</code>源码的时候，都会忘了<code>ThreadLocal</code>是如何实现和工作的，故这次记录下来。</p></blockquote><p>[TOC]</p><h2 id="工作原理图"><a href="#工作原理图" class="headerlink" title="工作原理图"></a>工作原理图</h2><p><img src="https://upload-images.jianshu.io/upload_images/7177220-1d4fc68a677a2449.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><h2 id="ThreadLocal中的ThreadLocalMap"><a href="#ThreadLocal中的ThreadLocalMap" class="headerlink" title="ThreadLocal中的ThreadLocalMap"></a>ThreadLocal中的ThreadLocalMap</h2><p><img src="https://upload-images.jianshu.io/upload_images/7177220-bb29144bb538d057.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>首先观察<code>ThreadLocal</code>的结构，有两个静态内部类，其中第二个<code>ThreadLocalMap</code>是他工作原理的最重要的类。</p><p>此时点开<code>Thread</code>类源码：</p><pre><code class="java">/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null;</code></pre><p>会发现<code>Thread</code>引用了一个<code>ThreadLocal.ThreadLocalMap</code>，并且命名为<code>threadLocals</code>。并且这个引用在每一个<code>Thread</code>对象中只有一个。这样的设计使得每个<code>Thread</code>对象都有一个自己的<code>Map</code>。</p><h3 id="Entry-extends-WeakRefernce"><a href="#Entry-extends-WeakRefernce" class="headerlink" title="Entry extends WeakRefernce"></a>Entry extends WeakRefernce</h3><p>再回到<code>ThreadLocalMap</code>中。<img src="https://upload-images.jianshu.io/upload_images/7177220-11f49c53a0f9900e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>如果看过<code>HashMap</code>或者<code>LinkedHashMap</code>源码应该会对这个<code>Entry</code>的设计很熟悉。代码为：</p><pre><code class="java">static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; {    /** The value associated with this ThreadLocal. */    Object value;    Entry(ThreadLocal&lt;?&gt; k, Object v) {        super(k);        value = v;    }    //...    private Entry[] table;//Entry数组    //set方法    private void set(ThreadLocal&lt;?&gt; key, Object value) {        Entry[] tab = table;        int len = tab.length;        int i = key.threadLocalHashCode &amp; (len-1);        for (Entry e = tab[i];             e != null;             e = tab[i = nextIndex(i, len)]) {            ThreadLocal&lt;?&gt; k = e.get();            if (k == key) {                e.value = value;                return;            }            if (k == null) {                replaceStaleEntry(key, value, i);                return;            }        }        tab[i] = new Entry(key, value);        int sz = ++size;        if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)            rehash();    }    //get方法    private Entry getEntry(ThreadLocal&lt;?&gt; key) {        int i = key.threadLocalHashCode &amp; (table.length - 1);        Entry e = table[i];        if (e != null &amp;&amp; e.get() == key)            return e;        else            return getEntryAfterMiss(key, i, e);    }}</code></pre><p>与<code>HashMap</code>不同的是，</p><ol><li>他继承了<code>WeakRefernce</code>，<code>key</code>必须是<code>ThreadLocal</code>，<code>value</code>是Object，即任意类型，并且在构造函数中将<code>key</code>传入作为弱引用构造函数的参数。</li><li><code>Entry</code>并没有引用一个<code>next</code>之类的指针，因此无法构成<code>HashMap</code>那样的链表。</li><li>纯粹的是维护一个<code>Entry</code>数组。</li></ol><p>继承<code>WeakReferenc</code>是因为：<code>ThreadLocal</code>作为key，如果是强引用，会一直被这个<code>ThreadLocalMap</code>引用，而只要后者对应的线程没有结束，那么就算在别处因为不需要了，而将该<code>ThreadLoacal</code>释放(=null)，由于在map中的强引用，<code>ThreadLocal</code>对象也无法回收。</p><p>因此这里只要设计成弱引用，在别处释放后，垃圾收集器就可以顺利回收<code>ThreadLocal</code>对象。</p><h2 id="ThreadLocal-1"><a href="#ThreadLocal-1" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><p>ThreadLocal对象实质上是做为一个key，在不同的线程中的map里，存取不同的对象。</p><pre><code class="java">public ThreadLocal() {    //...    public T get() {        Thread t = Thread.currentThread();//获取当前线程        ThreadLocalMap map = getMap(t);        if (map != null) {            ThreadLocalMap.Entry e = map.getEntry(this);//当前对象作为key去getEntry(this)            if (e != null) {                @SuppressWarnings(&quot;unchecked&quot;)                T result = (T)e.value;                return result;            }        }        return setInitialValue();    }    public void set(T value) {        Thread t = Thread.currentThread();//获取当前线程        ThreadLocalMap map = getMap(t);        if (map != null)            map.set(this, value);//当前对象作为key去set(this,value)        else            createMap(t, value);    }}</code></pre><hr><p>剩下的就是一些实现细节了，直接到源码里面去看就行了，主要还是看看顶部的工作原理图，理解原理就行。</p><p></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看Android设备已安装的apk的versionCode</title>
    <link href="/2018/08/11/Android/%E6%9F%A5%E7%9C%8BAndroid%E8%AE%BE%E5%A4%87%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84apk%E7%9A%84versionCode/"/>
    <url>/2018/08/11/Android/%E6%9F%A5%E7%9C%8BAndroid%E8%AE%BE%E5%A4%87%E5%B7%B2%E5%AE%89%E8%A3%85%E7%9A%84apk%E7%9A%84versionCode/</url>
    
    <content type="html"><![CDATA[<h1 id="查看Android设备已安装的apk的versionCode"><a href="#查看Android设备已安装的apk的versionCode" class="headerlink" title="查看Android设备已安装的apk的versionCode"></a>查看Android设备已安装的apk的versionCode</h1><h2 id="1-确认连接"><a href="#1-确认连接" class="headerlink" title="1. 确认连接"></a>1. 确认连接</h2><pre><code class="shell">$ adb devices</code></pre><h2 id="2-输出设备所有已安装的apk"><a href="#2-输出设备所有已安装的apk" class="headerlink" title="2. 输出设备所有已安装的apk"></a>2. 输出设备所有已安装的apk</h2><pre><code class="shell">$ adb shell list packages</code></pre><h2 id="3-找到目标apk名字，输出对应信息，找到versionCode即可。"><a href="#3-找到目标apk名字，输出对应信息，找到versionCode即可。" class="headerlink" title="3. 找到目标apk名字，输出对应信息，找到versionCode即可。"></a>3. 找到目标apk名字，输出对应信息，找到versionCode即可。</h2><pre><code class="shell">$ adb shell dumpsys package com.aaa.bbb</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AppCompatActivity和Fragment如何通过Lifecycle将生命周期状态转发出去</title>
    <link href="/2018/08/10/Android/AppCompatActivity%E5%92%8CFragment%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87Lifecycle%E5%B0%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%91%E5%87%BA%E5%8E%BB/"/>
    <url>/2018/08/10/Android/AppCompatActivity%E5%92%8CFragment%E5%A6%82%E4%BD%95%E9%80%9A%E8%BF%87Lifecycle%E5%B0%86%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%8A%B6%E6%80%81%E8%BD%AC%E5%8F%91%E5%87%BA%E5%8E%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p> 关于android的Lifecycle是什么和怎么用就不说了，这篇写的很好了：</p><p><a href="https://blog.csdn.net/mq2553299/article/details/79029657" target="_blank" rel="noopener">Android官方架构组件:Lifecycle详解&amp;原理分析</a></p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ol><li>概述：Lifecycle方案其实就是把AppCompatActivity和Fragment(support包下的)的声名周期回调转发出去，本质上是基于一个观察者模式，将观察者注册到有生命周期的组件，然后有生命周期的组件在他们的生命周期回调时，把事件转发给每一个观察者，这样观察者就收到了AppCompatActivity或Fragment的生命周期回调，也就具有了生命周期感知能力。</li><li>需要了解：<ol><li>Lifecycle是什么和怎么用</li><li>创建一个没有视图的Fragment，由于该Fragment和创建他的Activity的生命周期是一致的，因此该Fragment也具有Activtiy生命周期感知能力。</li></ol></li></ol><h2 id="Fragment如何转发生命周期"><a href="#Fragment如何转发生命周期" class="headerlink" title="Fragment如何转发生命周期"></a>Fragment如何转发生命周期</h2><ol><li><p>打开<code>android.support.v4.app</code>包下的Fragment</p><pre><code class="java"> public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner,ViewModelStoreOwner {     //...     LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);     @Override     public Lifecycle getLifecycle() {         return mLifecycleRegistry;     }     //... }</code></pre><p> Fragment实现了LifecycleOwner，在该接口唯一的抽象方法中返回了</p><p> <code>LifecycleRegistry</code>，中文翻译过来是<strong>生命周期注册处</strong>，他是官方对Lifecycle抽象类的默认实现，而他就是一个被观察者，是一个<code>Observable</code>。</p></li><li><p>接着看<code>performCreate()</code>和<code>performStart()</code></p><pre><code class="java"> void performCreate(Bundle savedInstanceState) {     if (mChildFragmentManager != null) {         mChildFragmentManager.noteStateNotSaved();     }     mState = CREATED;     mCalled = false;     onCreate(savedInstanceState);     mIsCreated = true;     if (!mCalled) {         throw new SuperNotCalledException(&quot;Fragment &quot; + this                 + &quot; did not call through to super.onCreate()&quot;);     }     //在这里，将Lifecycle.Event.ON_CREATE事件转发给所有生命周期观察者。     mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); }</code></pre><pre><code class="java"> void performStart() {     if (mChildFragmentManager != null) {         mChildFragmentManager.noteStateNotSaved();         mChildFragmentManager.execPendingActions();     }     mState = STARTED;     mCalled = false;     onStart();     if (!mCalled) {         throw new SuperNotCalledException(&quot;Fragment &quot; + this                 + &quot; did not call through to super.onStart()&quot;);     }     if (mChildFragmentManager != null) {         mChildFragmentManager.dispatchStart();     }     //同理。     mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); }</code></pre><p> 至于<code>onResume()</code>，<code>onPause()</code>,<code>onStop</code>和<code>onDestory</code>，都是一样的，都会调用<code>mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.XXX)</code>把生命周期转发给观察者。</p></li><li><p>看下<code>handleLifecycleEvent()</code></p><pre><code class="java"> public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {     State next = getStateAfter(event);     moveToState(next); }</code></pre><p> 点进moveToState(next);</p><pre><code class="java"> private void moveToState(State next) {     if (mState == next) {         return;     }     mState = next;     if (mHandlingEvent || mAddingObserverCounter != 0) {         mNewEventOccurred = true;         // we will figure out what to do on upper level.         return;     }     mHandlingEvent = true;     sync();//关注这个方法     mHandlingEvent = false; }</code></pre><p> 点进sync();</p><pre><code class="java"> private void sync() {     LifecycleOwner lifecycleOwner = mLifecycleOwner.get();     if (lifecycleOwner == null) {         Log.w(LOG_TAG, &quot;LifecycleOwner is garbage collected, you shouldn&#39;t try dispatch &quot;                 + &quot;new events from it.&quot;);         return;     }     while (!isSynced()) {         mNewEventOccurred = false;         // no need to check eldest for nullability, because isSynced does it for us.         if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) {             backwardPass(lifecycleOwner);//点进这里         }         Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();         if (!mNewEventOccurred &amp;&amp; newest != null                 &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) {             forwardPass(lifecycleOwner);//或者点进这里         }     }     mNewEventOccurred = false; }</code></pre><p> 接着点进backwardPass或者forwardPass。</p><pre><code class="java"> private void backwardPass(LifecycleOwner lifecycleOwner) {     Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =             mObserverMap.descendingIterator();     while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) {         Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();         ObserverWithState observer = entry.getValue();         while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred                 &amp;&amp; mObserverMap.contains(entry.getKey()))) {             Event event = downEvent(observer.mState);             pushParentState(getStateAfter(event));             observer.dispatchEvent(lifecycleOwner, event);//终于，在这里把事件正式转发给了观察者。             popParentState();         }     } }</code></pre><p> 点进observer.dispatchEvent(…)</p><pre><code class="java"> void dispatchEvent(LifecycleOwner owner, Event event) {     State newState = getStateAfter(event);     mState = min(mState, newState);     mLifecycleObserver.onStateChanged(owner, event);//在这里     mState = newState; }</code></pre><p> 点进mLifecycleObserver.onStateChanged(owner, event);</p><pre><code class="java"> public interface GenericLifecycleObserver extends LifecycleObserver {     void onStateChanged(LifecycleOwner source, Lifecycle.Event event); }</code></pre><p> 终于，到了LifecycleObserver了，观察者只需要实现这个接口，然后再Activty或者Fragment里面注册一下，就能接收到一系列的生命周期回调了。</p></li></ol><h2 id="AppCompatActivity如何转发生命周期"><a href="#AppCompatActivity如何转发生命周期" class="headerlink" title="AppCompatActivity如何转发生命周期"></a>AppCompatActivity如何转发生命周期</h2><h3 id="1-找到SupportActivity"><a href="#1-找到SupportActivity" class="headerlink" title="1. 找到SupportActivity"></a>1. 找到SupportActivity</h3><p>AppCompatActivity的继承关系：</p><pre><code>Context (android.content)    ContextWrapper (android.content)        ContextThemeWrapper (android.view)            Activity (android.app)                SupportActivity (android.support.v4.app)                    BaseFragmentActivityApi14 (android.support.v4.app)                        BaseFragmentActivityApi16 (android.support.v4.app)                            FragmentActivity (android.support.v4.app)                                AppCompatActivity (android.support.v7.app)</code></pre><h3 id="2-分析SupportActivity"><a href="#2-分析SupportActivity" class="headerlink" title="2. 分析SupportActivity"></a>2. 分析SupportActivity</h3><pre><code class="java">public class SupportActivity extends Activity implements LifecycleOwner {    //...    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);    @Override    public Lifecycle getLifecycle() {        return mLifecycleRegistry;    }    @Override    @SuppressWarnings(&quot;RestrictedApi&quot;)    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        ReportFragment.injectIfNeededIn(this);//关键点    }}</code></pre><p>其实我刚开始找AppCompatActivity的时候是懵逼的，因为从上到下的所有父类，都没有在生命周期里像Fragment一样去直接用<code>LifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.XXX)</code>转发生命周期事件的，找了半天都没找到。</p><p>后来发现了上图14行代码处`ReportFragment.injectIfNeededIn(this);，原来是他，他用的技巧是文章开头说到的：<strong>创建一个没有视图的Fragment，由于该Fragment和创建他的Activity的生命周期是一致的，因此该Fragment也具有Activtiy生命周期感知能力。创建一个没有视图的Fragment，由于该Fragment和创建他的Activity的生命周期是一致的，因此该Fragment也具有Activtiy生命周期感知能力。</strong></p><h3 id="3-ReportFragment-injectIfNeededIn-this"><a href="#3-ReportFragment-injectIfNeededIn-this" class="headerlink" title="3. ReportFragment.injectIfNeededIn(this)"></a>3. ReportFragment.injectIfNeededIn(this)</h3><pre><code class="java">public class ReportFragment extends Fragment {    public static void injectIfNeededIn(Activity activity) {    // ProcessLifecycleOwner should always correctly work and some activities may not extend    // FragmentActivity from support lib, so we use framework fragments for activities        android.app.FragmentManager manager = activity.getFragmentManager();        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {        manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();        // Hopefully, we are the first to make a transaction.        manager.executePendingTransactions();        }    }}</code></pre><p>借助传入的activity，创建一个<code>ReportFragment</code>(没有视图的Fragment)。</p><p>再看ReportFragment的生命周期回调</p><pre><code class="java">@Overridepublic void onActivityCreated(Bundle savedInstanceState) {    super.onActivityCreated(savedInstanceState);    dispatchCreate(mProcessListener);    dispatch(Lifecycle.Event.ON_CREATE);}@Overridepublic void onStart() {    super.onStart();    dispatchStart(mProcessListener);    dispatch(Lifecycle.Event.ON_START);}@Overridepublic void onResume() {    super.onResume();    dispatchResume(mProcessListener);    dispatch(Lifecycle.Event.ON_RESUME);}@Overridepublic void onPause() {    super.onPause();    dispatch(Lifecycle.Event.ON_PAUSE);}@Overridepublic void onStop() {    super.onStop();    dispatch(Lifecycle.Event.ON_STOP);}@Overridepublic void onDestroy() {    super.onDestroy();    dispatch(Lifecycle.Event.ON_DESTROY);    // just want to be sure that we won&#39;t leak reference to an activity    mProcessListener = null;}</code></pre><p>是的就是这样，借助了这个没有视图的Fragment来把生命周期转发出去。</p><p>看下<code>dispatch(Lifecycle.Event.XXX)</code>做了什么</p><pre><code class="java">private void dispatch(Lifecycle.Event event) {    Activity activity = getActivity();    if (activity instanceof LifecycleRegistryOwner) {        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);        return;    }    if (activity instanceof LifecycleOwner) {        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();        if (lifecycle instanceof LifecycleRegistry) {            ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);        }    }}</code></pre><p>看到了第10行的<code>((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</code>，在这里，把生命周期转发出去。</p><hr><p>至此，分析结束。我从这个Lifecycle方案中学到的一点是：</p><p>无视图Fragment的技巧的优点：</p><p>他与创建他的Activity的生命周期一致（让这个Fragment具有生命周期感知能力），可以在不修改原有Activity生命周期代码的情况下，用Fragment来从外部<code>插入</code>方法。可拔插，解耦合，非常灵活。<br>力。<br>2. 需要了解：</p><ol><li>Lifecycle是什么和怎么用</li><li>创建一个没有视图的Fragment，由于该Fragment和创建他的Activity的生命周期是一致的，因此该Fragment也具有Activtiy生命周期感知能力。</li></ol><h2 id="Fragment如何转发生命周期-1"><a href="#Fragment如何转发生命周期-1" class="headerlink" title="Fragment如何转发生命周期"></a>Fragment如何转发生命周期</h2><ol><li><p>打开<code>android.support.v4.app</code>包下的Fragment</p><pre><code class="java"> public class Fragment implements ComponentCallbacks, OnCreateContextMenuListener, LifecycleOwner,ViewModelStoreOwner {     //...     LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);     @Override     public Lifecycle getLifecycle() {         return mLifecycleRegistry;     }     //... }</code></pre><p> Fragment实现了LifecycleOwner，在该接口唯一的抽象方法中返回了</p><p> <code>LifecycleRegistry</code>，中文翻译过来是<strong>生命周期注册处</strong>，他是官方对Lifecycle抽象类的默认实现，而他就是一个被观察者，是一个<code>Observable</code>。</p></li><li><p>接着看<code>performCreate()</code>和<code>performStart()</code></p><pre><code class="java"> void performCreate(Bundle savedInstanceState) {     if (mChildFragmentManager != null) {         mChildFragmentManager.noteStateNotSaved();     }     mState = CREATED;     mCalled = false;     onCreate(savedInstanceState);     mIsCreated = true;     if (!mCalled) {         throw new SuperNotCalledException(&quot;Fragment &quot; + this                 + &quot; did not call through to super.onCreate()&quot;);     }     //在这里，将Lifecycle.Event.ON_CREATE事件转发给所有生命周期观察者。     mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_CREATE); }</code></pre><pre><code class="java"> void performStart() {     if (mChildFragmentManager != null) {         mChildFragmentManager.noteStateNotSaved();         mChildFragmentManager.execPendingActions();     }     mState = STARTED;     mCalled = false;     onStart();     if (!mCalled) {         throw new SuperNotCalledException(&quot;Fragment &quot; + this                 + &quot; did not call through to super.onStart()&quot;);     }     if (mChildFragmentManager != null) {         mChildFragmentManager.dispatchStart();     }     //同理。     mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.ON_START); }</code></pre><p> 至于<code>onResume()</code>，<code>onPause()</code>,<code>onStop</code>和<code>onDestory</code>，都是一样的，都会调用<code>mLifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.XXX)</code>把生命周期转发给观察者。</p></li><li><p>看下<code>handleLifecycleEvent()</code></p><pre><code class="java"> public void handleLifecycleEvent(@NonNull Lifecycle.Event event) {     State next = getStateAfter(event);     moveToState(next); }</code></pre><p> 点进moveToState(next);</p><pre><code class="java"> private void moveToState(State next) {     if (mState == next) {         return;     }     mState = next;     if (mHandlingEvent || mAddingObserverCounter != 0) {         mNewEventOccurred = true;         // we will figure out what to do on upper level.         return;     }     mHandlingEvent = true;     sync();//关注这个方法     mHandlingEvent = false; }</code></pre><p> 点进sync();</p><pre><code class="java"> private void sync() {     LifecycleOwner lifecycleOwner = mLifecycleOwner.get();     if (lifecycleOwner == null) {         Log.w(LOG_TAG, &quot;LifecycleOwner is garbage collected, you shouldn&#39;t try dispatch &quot;                 + &quot;new events from it.&quot;);         return;     }     while (!isSynced()) {         mNewEventOccurred = false;         // no need to check eldest for nullability, because isSynced does it for us.         if (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; 0) {             backwardPass(lifecycleOwner);//点进这里         }         Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();         if (!mNewEventOccurred &amp;&amp; newest != null                 &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; 0) {             forwardPass(lifecycleOwner);//或者点进这里         }     }     mNewEventOccurred = false; }</code></pre><p> 接着点进backwardPass或者forwardPass。</p><pre><code class="java"> private void backwardPass(LifecycleOwner lifecycleOwner) {     Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; descendingIterator =             mObserverMap.descendingIterator();     while (descendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) {         Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = descendingIterator.next();         ObserverWithState observer = entry.getValue();         while ((observer.mState.compareTo(mState) &gt; 0 &amp;&amp; !mNewEventOccurred                 &amp;&amp; mObserverMap.contains(entry.getKey()))) {             Event event = downEvent(observer.mState);             pushParentState(getStateAfter(event));             observer.dispatchEvent(lifecycleOwner, event);//终于，在这里把事件正式转发给了观察者。             popParentState();         }     } }</code></pre><p> 点进observer.dispatchEvent(…)</p><pre><code class="java"> void dispatchEvent(LifecycleOwner owner, Event event) {     State newState = getStateAfter(event);     mState = min(mState, newState);     mLifecycleObserver.onStateChanged(owner, event);//在这里     mState = newState; }</code></pre><p> 点进mLifecycleObserver.onStateChanged(owner, event);</p><pre><code class="java"> public interface GenericLifecycleObserver extends LifecycleObserver {     void onStateChanged(LifecycleOwner source, Lifecycle.Event event); }</code></pre><p> 终于，到了LifecycleObserver了，观察者只需要实现这个接口，然后再Activty或者Fragment里面注册一下，就能接收到一系列的生命周期回调了。</p></li></ol><h2 id="AppCompatActivity如何转发生命周期-1"><a href="#AppCompatActivity如何转发生命周期-1" class="headerlink" title="AppCompatActivity如何转发生命周期"></a>AppCompatActivity如何转发生命周期</h2><h3 id="1-找到SupportActivity-1"><a href="#1-找到SupportActivity-1" class="headerlink" title="1. 找到SupportActivity"></a>1. 找到SupportActivity</h3><p>AppCompatActivity的继承关系：</p><pre><code>Context (android.content)    ContextWrapper (android.content)        ContextThemeWrapper (android.view)            Activity (android.app)                SupportActivity (android.support.v4.app)                    BaseFragmentActivityApi14 (android.support.v4.app)                        BaseFragmentActivityApi16 (android.support.v4.app)                            FragmentActivity (android.support.v4.app)                                AppCompatActivity (android.support.v7.app)</code></pre><h3 id="2-分析SupportActivity-1"><a href="#2-分析SupportActivity-1" class="headerlink" title="2. 分析SupportActivity"></a>2. 分析SupportActivity</h3><pre><code class="java">public class SupportActivity extends Activity implements LifecycleOwner {    //...    private LifecycleRegistry mLifecycleRegistry = new LifecycleRegistry(this);    @Override    public Lifecycle getLifecycle() {        return mLifecycleRegistry;    }    @Override    @SuppressWarnings(&quot;RestrictedApi&quot;)    protected void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        ReportFragment.injectIfNeededIn(this);//关键点    }}</code></pre><p>其实我刚开始找AppCompatActivity的时候是懵逼的，因为从上到下的所有父类，都没有在生命周期里像Fragment一样去直接用<code>LifecycleRegistry.handleLifecycleEvent(Lifecycle.Event.XXX)</code>转发生命周期事件的，找了半天都没找到。</p><p>后来发现了上图14行代码处`ReportFragment.injectIfNeededIn(this);，原来是他，他用的技巧是文章开头说到的：<strong>创建一个没有视图的Fragment，由于该Fragment和创建他的Activity的生命周期是一致的，因此该Fragment也具有Activtiy生命周期感知能力。创建一个没有视图的Fragment，由于该Fragment和创建他的Activity的生命周期是一致的，因此该Fragment也具有Activtiy生命周期感知能力。</strong></p><h3 id="3-ReportFragment-injectIfNeededIn-this-1"><a href="#3-ReportFragment-injectIfNeededIn-this-1" class="headerlink" title="3. ReportFragment.injectIfNeededIn(this)"></a>3. ReportFragment.injectIfNeededIn(this)</h3><pre><code class="java">public class ReportFragment extends Fragment {    public static void injectIfNeededIn(Activity activity) {    // ProcessLifecycleOwner should always correctly work and some activities may not extend    // FragmentActivity from support lib, so we use framework fragments for activities        android.app.FragmentManager manager = activity.getFragmentManager();        if (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == null) {        manager.beginTransaction().add(new ReportFragment(), REPORT_FRAGMENT_TAG).commit();        // Hopefully, we are the first to make a transaction.        manager.executePendingTransactions();        }    }}</code></pre><p>借助传入的activity，创建一个<code>ReportFragment</code>(没有视图的Fragment)。</p><p>再看ReportFragment的生命周期回调</p><pre><code class="java">@Overridepublic void onActivityCreated(Bundle savedInstanceState) {    super.onActivityCreated(savedInstanceState);    dispatchCreate(mProcessListener);    dispatch(Lifecycle.Event.ON_CREATE);}@Overridepublic void onStart() {    super.onStart();    dispatchStart(mProcessListener);    dispatch(Lifecycle.Event.ON_START);}@Overridepublic void onResume() {    super.onResume();    dispatchResume(mProcessListener);    dispatch(Lifecycle.Event.ON_RESUME);}@Overridepublic void onPause() {    super.onPause();    dispatch(Lifecycle.Event.ON_PAUSE);}@Overridepublic void onStop() {    super.onStop();    dispatch(Lifecycle.Event.ON_STOP);}@Overridepublic void onDestroy() {    super.onDestroy();    dispatch(Lifecycle.Event.ON_DESTROY);    // just want to be sure that we won&#39;t leak reference to an activity    mProcessListener = null;}</code></pre><p>是的就是这样，借助了这个没有视图的Fragment来把生命周期转发出去。</p><p>看下<code>dispatch(Lifecycle.Event.XXX)</code>做了什么</p><p>```java<br>private void dispatch(Lifecycle.Event event) {<br>    Activity activity = getActivity();<br>    if (activity instanceof LifecycleRegistryOwner) {<br>        ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);<br>        return;<br>    }<br>    if (activity instanceof LifecycleOwner) {<br>        Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycl</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Service是单例</title>
    <link href="/2018/08/09/Android/Service%E6%98%AF%E5%8D%95%E4%BE%8B/"/>
    <url>/2018/08/09/Android/Service%E6%98%AF%E5%8D%95%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<p>stackoverflow上的3个问题解答了我的疑惑：<br><a href="https://stackoverflow.com/questions/3567667/android-when-to-use-service-vs-singleton" target="_blank" rel="noopener">Android: When to use Service vs Singleton?</a><br><a href="https://stackoverflow.com/questions/16309494/android-service-isnt-working-as-a-singleton" target="_blank" rel="noopener">Android service isn’t working as a singleton</a><br><a href="https://stackoverflow.com/questions/2518238/does-startservice-create-a-new-service-instance-or-using-the-existing-one" target="_blank" rel="noopener">Does startService() create a new Service instance or using the existing one?</a></p><hr><p>结论：</p><ol><li>当多次startService去启动Service，若Service对象存在，就只调用onStartCommand，若Service对象不存在，创建Service对象。</li><li>服务时天然的单例模式，且可以被销毁。<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>获取Activity的布局文件的root-view</title>
    <link href="/2018/08/09/View/%E8%8E%B7%E5%8F%96Activity%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E7%9A%84root-view/"/>
    <url>/2018/08/09/View/%E8%8E%B7%E5%8F%96Activity%E7%9A%84%E5%B8%83%E5%B1%80%E6%96%87%E4%BB%B6%E7%9A%84root-view/</url>
    
    <content type="html"><![CDATA[<h2 id="两种方式"><a href="#两种方式" class="headerlink" title="两种方式"></a>两种方式</h2><ol><li>在xml文件中的root view上设置id，然后<code>findViewByid(String resId)</code>即可。</li><li>不用设置id，直接在代码里获取：<pre><code class="java">ViewGroup contentView= (ViewGroup) ((ViewGroup) findViewById(android.R.id.content)).getChildAt(0);</code></pre><code>contentView</code>即为所求</li></ol><hr><p>这是从<code>DecorView</code>开始的view tree，debug得到的。<br><img src="https://upload-images.jianshu.io/upload_images/7177220-cd93a7e0e314b94f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>View#scrollBy(int-x-,-int-y)反向</title>
    <link href="/2018/07/27/View/View#scrollBy(int-x-,-int-y)%E5%8F%8D%E5%90%91/"/>
    <url>/2018/07/27/View/View#scrollBy(int-x-,-int-y)%E5%8F%8D%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>先看下源码</p><pre><code class="java">public void scrollBy(int x, int y) {    scrollTo(mScrollX + x, mScrollY + y);}</code></pre><pre><code class="java">public void scrollTo(int x, int y) {    if (mScrollX != x || mScrollY != y) {        int oldX = mScrollX;        int oldY = mScrollY;        mScrollX = x;        mScrollY = y;        invalidateParentCaches();        onScrollChanged(mScrollX, mScrollY, oldX, oldY);        if (!awakenScrollBars()) {            postInvalidateOnAnimation();        }    }}</code></pre><p>了解了scrollBy( x , y)就是在原来的基础上，改mScrollX为x，改为mScrollY为Y。</p><p>比如调用<code>view#scrollBy(100 , 50)</code>后，mScrollX增加了100，mScrollY增加了50。但是这个view的内容却往反方向移动了，就是往左边移动100 ，上边移动50。</p><p>而mScrollX和mScrollY的定义：</p><p>mScrollX = View的内容左边框的x坐标值 - 实际的View左边缘的x坐标。</p><p>mScrollY = View的内容上边框的的y坐标值 - 实际的View上边缘的y坐标。</p><p>而View的内容左边框的x坐标值和View的内容上边框的y坐标值在用<code>View#scrollTo</code>和<code>View#scrollBy</code>是不会改变的。</p><p>因此当调用scrollBy(int x , int y)中的参数都填入正值时，</p><pre><code>mScrollX = View的内容左边框的x坐标值 - 实际的View左边缘的x坐标。</code></pre><p>由等式性质得：实际的View的左边缘的x坐标，减少。</p><p>即scrollBy(x, y )的x&gt;0时，view会往左跑。这就是scrollBy(int x , int y)反向的原因。</p><p>那么要让view的内容往右下方走的话，就要为scrollBy传入负值。比如：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-20de8296e0e33692.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android模拟简单跨进程通信</title>
    <link href="/2018/07/26/Android/android%E6%A8%A1%E6%8B%9F%E7%AE%80%E5%8D%95%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/"/>
    <url>/2018/07/26/Android/android%E6%A8%A1%E6%8B%9F%E7%AE%80%E5%8D%95%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="android模拟简单跨进程通信"><a href="#android模拟简单跨进程通信" class="headerlink" title="android模拟简单跨进程通信"></a>android模拟简单跨进程通信</h1><blockquote><p>需求：当前进程需要和远程进程通信，调用远程<code>Service</code>的<code>getEntity(int age)</code>方法，客户端（当前进程）传入参数int age，服务端（远程Service进程）根据得到的参数返回Entity。</p></blockquote><h2 id="1-建立客户端和服务端通信的共同协议：接口"><a href="#1-建立客户端和服务端通信的共同协议：接口" class="headerlink" title="1. 建立客户端和服务端通信的共同协议：接口"></a>1. 建立客户端和服务端通信的共同协议：接口</h2><p>让Entitiy类实现Parcelable接口：</p><pre><code class="java">//省略get set方法。public class Entity implements Parcelable{    private int age;    private String name;    private String country;    public Entity() {    }    private Entity(Parcel in) {        age = in.readInt();        name = in.readString();        country = in.readString();    }    public static final Creator&lt;Entity&gt; CREATOR = new Creator&lt;Entity&gt;() {        @Override        public Entity createFromParcel(Parcel in) {            return new Entity(in);        }        @Override        public Entity[] newArray(int size) {            return new Entity[size];        }    };    @Override    public int describeContents() {        return 0;    }    @Override    public void writeToParcel(Parcel dest, int flags) {        dest.writeInt(age);        dest.writeString(name);        dest.writeString(country);    }}</code></pre><p>新建Entity.aidl</p><pre><code class="java">// IEntity.aidlpackage com.example.admin.servicetrain;// Declare any non-default types here with import statementsparcelable Entity;</code></pre><p>新建IEntityInterface.aidl</p><pre><code class="java">// IEntityInterface.aidlpackage com.example.admin.servicetrain;import com.example.admin.servicetrain.Entity;//要手动导包// Declare any non-default types here with import statementsinterface IEntityInterface {    /**     * Demonstrates some basic types that you can use as parameters     * and return values in AIDL.     */    Entity getEntity(int age);}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-f532170aabb228e0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><h2 id="2-建立RemoteService，让他当做远程服务进程。"><a href="#2-建立RemoteService，让他当做远程服务进程。" class="headerlink" title="2. 建立RemoteService，让他当做远程服务进程。"></a>2. 建立RemoteService，让他当做远程服务进程。</h2><pre><code class="java">public class RemoteService extends Service {    public static final String TAG = &quot;William&quot;;    MyBinder myBinder=new MyBinder();    @Override    public void onCreate() {        super.onCreate();        Log.d(TAG, &quot;RemoteService onCreate: &quot;);    }    @Override    public boolean onUnbind(Intent intent) {        Log.d(TAG, &quot;onUnbind: &quot;);        return super.onUnbind(intent);    }    @Override    public void onDestroy() {        Log.d(TAG, &quot;onDestroy: &quot;);        super.onDestroy();    }    @Nullable    @Override    public IBinder onBind(Intent intent) {        Log.d(TAG, &quot;RemoteService onBind: &quot;);        return myBinder;    }    //通过集成IXXXInterface.Stub创建Binder实体类。    private static class MyBinder extends IEntityInterface.Stub{        Random random=new Random();        @Override        public Entity getEntity(int age) throws RemoteException {            if (age&gt;30){                Entity entity=new Entity();                entity.setAge(random.nextInt(70)+30);                entity.setCountry(&quot;Japan&quot;);                entity.setName(&quot;AAA&quot;);                return entity;            }else {                Entity entity=new Entity();                entity.setAge(random.nextInt(30));                entity.setName(&quot;Big&quot;);                entity.setCountry(&quot;China&quot;);                return entity;            }        }    }}</code></pre><p>在AndroidManifest.xml中注册，process的写法有两种，我选了其中一种。表示RemoteService是当前应用私有进程。</p><pre><code class="xml">&lt;service android:name=&quot;.RemoteService&quot;    android:exported=&quot;false&quot;    android:process=&quot;:remote&quot;&gt;&lt;/service&gt;</code></pre><h2 id="3-在客户端进程中绑定并通过Binder驱动为我们生成的Binder代理对象来调用RemoteService中的方法。"><a href="#3-在客户端进程中绑定并通过Binder驱动为我们生成的Binder代理对象来调用RemoteService中的方法。" class="headerlink" title="3. 在客户端进程中绑定并通过Binder驱动为我们生成的Binder代理对象来调用RemoteService中的方法。"></a>3. 在客户端进程中绑定并通过Binder驱动为我们生成的Binder代理对象来调用RemoteService中的方法。</h2><pre><code class="java">public class MainActivity extends AppCompatActivity {    Button btn_bind;    Button btn_unbind;    Button btn_getEntity;    //build后，通过sdk的工具将写的.aidl文件转换成了.java接口。    private IEntityInterface entityInterface;    //标志位，bind=true表示Service已绑定，bind=false表示Service已解绑。    private boolean bind;    private final ServiceConnection connection=new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName name, IBinder service) {            //通过asInterface生成Binder代理类对象。（Proxy的对象）            entityInterface= IEntityInterface.Stub.asInterface(service);            bind=true;        }        @Override        public void onServiceDisconnected(ComponentName name) {            entityInterface=null;        }    };    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        btn_bind=findViewById(R.id.btn_bind);        btn_unbind=findViewById(R.id.btn_unbind);        btn_getEntity=findViewById(R.id.btn_get_number);        btn_bind.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                Intent intent=new Intent(MainActivity.this,RemoteService.class);                bindService(intent,connection,BIND_AUTO_CREATE);            }        });        btn_unbind.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                bind=false;                unbindService(connection);            }        });        final Random random=new Random();        btn_getEntity.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                if (!bind){                    return;                }                try {                    Log.d(RemoteService.TAG, entityInterface.getEntity(random.nextInt(60)).toString());                } catch (RemoteException e) {                    e.printStackTrace();                }            }        });    }}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-e548db10c6e45bd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>点击”绑定”，再点击”跨进程获取Entity”，打印：</p><pre><code class="verilog">07-26 10:24:01.805 10825-10825/com.example.admin.servicetrain D/William: Entity{age=7, name=&#39;Big&#39;, country=&#39;China&#39;}07-26 10:24:01.995 10825-10825/com.example.admin.servicetrain D/William: Entity{age=28, name=&#39;Big&#39;, country=&#39;China&#39;}07-26 10:24:02.205 10825-10825/com.example.admin.servicetrain D/William: Entity{age=26, name=&#39;Big&#39;, country=&#39;China&#39;}07-26 10:24:02.385 10825-10825/com.example.admin.servicetrain D/William: Entity{age=0, name=&#39;Big&#39;, country=&#39;China&#39;}07-26 10:24:02.545 10825-10825/com.example.admin.servicetrain D/William: Entity{age=20, name=&#39;Big&#39;, country=&#39;China&#39;}07-26 10:24:02.735 10825-10825/com.example.admin.servicetrain D/William: Entity{age=63, name=&#39;AAA&#39;, country=&#39;Japan&#39;}07-26 10:24:02.905 10825-10825/com.example.admin.servicetrain D/William: Entity{age=99, name=&#39;AAA&#39;, country=&#39;Japan&#39;}</code></pre><hr><p>End<br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hugo配合GitHub搭建博客（Windows-10）</title>
    <link href="/2018/07/23/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/Hugo%E9%85%8D%E5%90%88GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Windows-10%EF%BC%89/"/>
    <url>/2018/07/23/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/Hugo%E9%85%8D%E5%90%88GitHub%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%EF%BC%88Windows-10%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h1 id="Hugo配合GitHub搭建博客（Windows-10）"><a href="#Hugo配合GitHub搭建博客（Windows-10）" class="headerlink" title="Hugo配合GitHub搭建博客（Windows 10）"></a>Hugo配合GitHub搭建博客（Windows 10）</h1><blockquote><p>前提：</p><ol><li>会Git和GitHub</li><li>安装git</li><li>安装hugo</li></ol></blockquote><h2 id="安装hugo"><a href="#安装hugo" class="headerlink" title="安装hugo"></a>安装hugo</h2><ol><li><p>安装Chocolatey</p><p> 以管理员身份运行cmd命令行</p><p> <img src="http://upload-images.jianshu.io/upload_images/7177220-863e7d4b48040a30.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p> 直接输入以下命令，回车。</p><pre><code> @&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#39;https://chocolatey.org/install.ps1&#39;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</code></pre><p> 成功后，输入choco，会显示Chocolatey的版本。</p><p> 均来自官网教程<a href="https://chocolatey.org/install。" target="_blank" rel="noopener">https://chocolatey.org/install。</a></p></li><li><p>在安装好choco后，cmd下执行：</p><pre><code> choco install hugo -confirm</code></pre><p> 成功后，执行hugo version。会显示hugo版本号。</p></li></ol><h2 id="关联github和本地的hugo建立的一系列文件。"><a href="#关联github和本地的hugo建立的一系列文件。" class="headerlink" title="关联github和本地的hugo建立的一系列文件。"></a>关联github和本地的hugo建立的一系列文件。</h2><ol><li><p>github–&gt;右上角的new repository–&gt;git clone 地址。</p></li><li><p>进入本地的刚clone下来的路径里，git bash here，然后执行</p><pre><code>hugo new site .​```在当前路径下创建</code></pre></li></ol><p><img src="https://upload-images.jianshu.io/upload_images/7177220-f333f2407a69575e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>​    要先git clone的原因是：git clone自动为本地分支建立远程分支并跟踪，方便，待会直接push就行了。</p><ol start="3"><li><p>修改配置文件config.toml。</p><pre><code> //默认为： baseURL = &quot;http://example.org/&quot; languageCode = &quot;en-us&quot; title = &quot;My New Hugo Site&quot; //修改为 baseURL = &quot;github发布出去的博客地址&quot; languageCode = &quot;en-us&quot; title = &quot;My New Hugo Site&quot; publishDir = &quot;docs&quot;</code></pre><p> 修改了baseURL，并增加了publishDir。publishDir的修改是因为：当在content目录下添加了.md文件后，需要执行<code>hugo -t &lt;主题名&gt;</code>来用hugo把发布用的目录编译出来，而默认的编译目录名为<code>publish</code>，这里改成了<code>docs</code>，这是因为Github规定了用做Gitpages的分类只有三种：</p><ol><li><p>发布路径在master分支下。</p></li><li><p>发布路径在master分支的docs目录下。</p></li><li><p>发布路径在gh-pages 分支下。</p><p>详情见  <a href="https://help.github.com/articles/user-organization-and-project-pages/" target="_blank" rel="noopener">User, Organization, and Project Pages</a></p><p>而我认为只将默认的发布目录/publish推送上去，不利于跨设备修改我的博客，因此我认为要将整个目录都推送上去，然后将/publish改成/docs，给github识别成gitpages用。</p></li></ol></li></ol><h2 id="安装主题"><a href="#安装主题" class="headerlink" title="安装主题"></a>安装主题</h2><p>选择一款主题</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-436bbdd8c4e291a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p><a href="https://themes.gohugo.io/" target="_blank" rel="noopener">https://themes.gohugo.io/</a></p><p>点进去之后都有demo和git clone用的地址，</p><p>我选了一个hyde主题。进入到themes目录下</p><pre><code>git clone https://github.com/spf13/hyde.git</code></pre><p>编辑config.toml，配置待会给博客编译用的主题。</p><pre><code>baseURL = &quot;github发布出去的博客地址&quot;languageCode = &quot;en-us&quot;title = &quot;My New Hugo Site&quot;publishDir = &quot;docs&quot;theme=&quot;hyde&quot;</code></pre><h2 id="写一个-md并预览"><a href="#写一个-md并预览" class="headerlink" title="写一个.md并预览"></a>写一个.md并预览</h2><p>git bash执行</p><pre><code>hugo new 你好.md</code></pre><p>进入content/你好.md。编辑一下，记得把draft=true改成draft=false。不然博客里面不会显示。draft–&gt;草稿.n</p><p>执行<code>hugo server</code> ，他运行一个本地服务器，并且把文章部署上去，但是没有生成发布目录（默认/publish），具体原因不清楚，好像新版的在内存中完成，老版的会生成发布目录。</p><pre><code class="bash">$ hugo serverERROR 2018/07/23 01:31:53 port 1313 already in use, attempting to use an available portBuilding sites …                   | EN+------------------+----+  Pages            |  8  Paginator pages  |  0  Non-page files   |  0  Static files     |  6  Processed images |  0  Aliases          |  0  Sitemaps         |  1  Cleaned          |  0Total in 4 msWatching for changes in Q:\123\{content,data,layouts,static,themes}Watching for config changes in Q:\123\config.tomlServing pages from memoryRunning in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRenderWeb Server is available at //localhost:54116/ (bind address 127.0.0.1)Press Ctrl+C to stop</code></pre><p>浏览器打开localhost:54116/：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-1c1c9c5b5f8b8797.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><h2 id="发布到github。"><a href="#发布到github。" class="headerlink" title="发布到github。"></a>发布到github。</h2><pre><code class="bash">hugo -t hyde</code></pre><p>hyde是主题名。必须有。</p><p>然后回到git工作目录.</p><pre><code>git add .git commit -m &quot;XXX&quot;git push</code></pre><p>到github上的代码仓库的settings中。</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-7b3dbe1a1b788358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>选择master branch/docs。 并且Save保存。</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-7e7cf9647fc9d6cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>完成。<br></p>]]></content>
    
    
    <categories>
      
      <category>搭建博客相关</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git修改commit信息。</title>
    <link href="/2018/07/20/git/git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF%E3%80%82/"/>
    <url>/2018/07/20/git/git%E4%BF%AE%E6%94%B9commit%E4%BF%A1%E6%81%AF%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>在Android Studio上面直接操作Version Control的reword是最直接的。</p><p>用git的方式来：</p><pre><code>git rebase -i HEAD~1</code></pre><p>打开了文本编辑器</p><pre><code>pick 10130de msg# Rebase da71f75..10130de onto da71f75 (1 command)## Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#39;s log message# x, exec &lt;command&gt; = run command (the rest of the line) using shell# d, drop &lt;commit&gt; = remove commit# l, label &lt;label&gt; = label current HEAD with a name# t, reset &lt;label&gt; = reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# .       create a merge commit using the original merge commit&#39;s# .       message (or the oneline, if no original merge commit was# .       specified). Use -c &lt;commit&gt; to reword the commit message.## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.##    However, if you remove everything, the rebase will be aborted.##    # Note that empty commits are commented out</code></pre><p>保存，关闭。<br>git显示命令：</p><pre><code>$ git rebase -i HEAD~1hint: Waiting for your editor to close the file...</code></pre><p>然后打开了文本编辑器，显示的就是</p><pre><code>msg//提示信息</code></pre><p>这里把msg改成123456798，然后保存，关闭。</p><pre><code>$ git rebase -i HEAD~1[detached HEAD 951f653] 123456789 Date: Fri Jul 20 15:26:26 2018 +0800 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 新建文本文档.txtSuccessfully rebased and updated refs/heads/master.</code></pre><p>这个时候commit信息已经修改，并且也改了版本快照的hash值。<br></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>启动一个Activity</title>
    <link href="/2018/07/20/View/%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AAActivity/"/>
    <url>/2018/07/20/View/%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AAActivity/</url>
    
    <content type="html"><![CDATA[<h1 id="Activity启动"><a href="#Activity启动" class="headerlink" title="Activity启动"></a>Activity启动</h1><h2 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity()"></a>startActivity()</h2><p>||</p><p>||</p><p>V</p><pre><code class="java">startActivityForResult()</code></pre><p> ||</p><p> ||</p><p> V</p><pre><code class="java">ActivityStackSupervisor # realStartActivityLocked(){    //...    app.thread.scheduleLaunchActivity(new Intent(r.intent), r.appToken,            System.identityHashCode(r), r.info,            new Configuration(mService.mConfiguration), r.compat,            app.repProcState, r.icicle, results, newIntents, !andResume,            mService.isNextTransitionForward(), profileFile, profileFd,            profileAutoStop);    //...}</code></pre><p>此处的<code>app.thread</code>是<code>IApplicationThread</code> ，他的实现类是<code>ActivityThread</code>的内部类<code>ApplicationThread</code>。</p><p>那么看<code>ApplicationThread</code>中的<code>shceduleLaunchActivity</code></p><pre><code class="java">@Overridepublic final void scheduleLaunchActivity(Intent intent, IBinder token, int ident,        ActivityInfo info, Configuration curConfig, Configuration overrideConfig,        CompatibilityInfo compatInfo, String referrer, IVoiceInteractor voiceInteractor,        int procState, Bundle state, PersistableBundle persistentState,        List&lt;ResultInfo&gt; pendingResults, List&lt;ReferrerIntent&gt; pendingNewIntents,        boolean notResumed, boolean isForward, ProfilerInfo profilerInfo) {    //...    sendMessage(H.LAUNCH_ACTIVITY, r);}</code></pre><p>看下<code>sendMessage</code>做了什么</p><h2 id="sendMessage"><a href="#sendMessage" class="headerlink" title="sendMessage()"></a>sendMessage()</h2><pre><code class="java">private void sendMessage(int what, Object obj, int arg1, int arg2, boolean async) {    if (DEBUG_MESSAGES) Slog.v(        TAG, &quot;SCHEDULE &quot; + what + &quot; &quot; + mH.codeToString(what)        + &quot;: &quot; + arg1 + &quot; / &quot; + obj);    Message msg = Message.obtain();    msg.what = what;    msg.obj = obj;    msg.arg1 = arg1;    msg.arg2 = arg2;    if (async) {        msg.setAsynchronous(true);    }    mH.sendMessage(msg);}</code></pre><p>搜索<code>mH</code>，发现是<code>private class H extends Handler</code>。是<code>ActivityThread</code>的内部类，和主线程<code>Looper</code>关联，那么<code>mH</code> 的<code>handleMessage()</code>就是在主线程里面执行了。</p><p>搜索H类里面的<code>H.LAUNCH_ACTIVITY</code>，发现了：</p><pre><code class="java">public void handleMessage(Message msg) {    if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));    switch (msg.what) {        case LAUNCH_ACTIVITY: {            Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityStart&quot;);            final ActivityClientRecord r = (ActivityClientRecord) msg.obj;            r.packageInfo = getPackageInfoNoCheck(                    r.activityInfo.applicationInfo, r.compatInfo);            handleLaunchActivity(r, null);//在这            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);        break;        //...    }}</code></pre><h2 id="handleLaunchActivity"><a href="#handleLaunchActivity" class="headerlink" title="handleLaunchActivity()"></a>handleLaunchActivity()</h2><pre><code class="java">private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) {    //...    //创建Application和Activity对象，并调用它们的生命周期    Activity a = performLaunchActivity(r, customIntent);    if(a!=null){        //Activity#onResume        handleResumeActivity(r.token, false, r.isForward,!r.activity.mFinished &amp;&amp; !r.startsNotResumed);    }}</code></pre><h3 id="performLaunchActivity"><a href="#performLaunchActivity" class="headerlink" title="performLaunchActivity()"></a>performLaunchActivity()</h3><pre><code class="java">private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent){    ClassLoader cl = r.packageInfo.getClassLoader();    //根据ClassLoader创建Activity对象    Activity activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);    //创建Application对象并调用App#onCreate    Application app=r.packageInfo.makeApplication(false,mInstrumentation);    //创建PhoneWindow，WindowManager。并和Activity关联    activity.attach(...);    //Activity#onCreate()    mInstrumentation.callActivityOnCreate(activity, r.state);    //Activity#onStart()    activity.performStart();    //...}</code></pre><h4 id="r-pakageInfo-makeApplication"><a href="#r-pakageInfo-makeApplication" class="headerlink" title="r.pakageInfo.makeApplication()"></a>r.pakageInfo.makeApplication()</h4><pre><code class="java">public Application makeApplication(boolean forceDefaultAppClass, Instrumentation instrumentation) {    if (mApplication != null) {        return mApplication;    }    Application app = null;    java.lang.ClassLoader cl = getClassLoader();    app = mActivityThread.mInstrumentation.newApplication(cl, appClass, appContext);    mActivityThread.mAllApplications.add(app);    instrumentation.callApplicationOnCreate(app);//调用App.onCreate()</code></pre><h4 id="activity-onAttach"><a href="#activity-onAttach" class="headerlink" title="activity.onAttach()"></a>activity.onAttach()</h4><pre><code class="java">final void attach(...) {    //实例化PhoneWindow    mWindow = new PhoneWindow(this);    mWindow.setCallback(this);    mWindow.getLayoutInflater().setPrivateFactory(this);    //实例化WindowManagerImpl，并和mWindow建立关联。    mWindow.setWindowManager((WindowManager)context.getSystemService(Context.WINDOW_SERVICE),                             mToken, mComponent.flattenToString(),            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);    mWindowManager = mWindow.getWindowManager();}</code></pre><p>看下是否在此处就new出一个<code>WindowManager</code>，点进<code>setWindowManager()</code>。</p><pre><code class="java">public void setWindowManager(WindowManager wm, IBinder appToken, String appName,        boolean hardwareAccelerated) {    //...    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);}</code></pre><p>点进<code>createLocalWindowManager(this)</code></p><pre><code class="java">public WindowManagerImpl createLocalWindowManager(Window parentWindow) {    //的确，在这里实例化了WindowManagerImpl    return new WindowManagerImpl(mDisplay, parentWindow);}</code></pre><h3 id="handleResumeActivity"><a href="#handleResumeActivity" class="headerlink" title="handleResumeActivity()"></a>handleResumeActivity()</h3><pre><code class="java">final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward,boolean reallyResume) {    //Activity#onResume()    ActivityClientRecord r = performResumeActivity(token, clearHide);    r.window = r.activity.getWindow();    View decor = r.window.getDecorView();    //让DecorView变的不可见    decor.setVisibility(View.INVISIBLE);    //WindowManager在Activity#onAttach中已经被实例化了    ViewManager wm = a.getWindowManager();    WindowManager.LayoutParams l = r.window.getAttributes();    //WindowManager#addView，将DecorView添加到Window中。    wm.addView(decor, l);}</code></pre><p>现在Activity的<code>onResume</code>都执行完了，执行到了<code>WindowManager#addView</code>。</p><hr><h2 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h2><p><code>WindowManager</code>接口继承自<code>ViewMananger</code>。<code>ViewManager</code>意思是：view管理者</p><pre><code class="java">public interface ViewManager{    public void addView(View view, ViewGroup.LayoutParams params);    public void updateViewLayout(View view, ViewGroup.LayoutParams params);    public void removeView(View view);}</code></pre><p>因此<code>WindowManager</code>也具有管理View管理者的能力，他的实现类是<code>WindowManagerImpl</code>。看看他的<code>addView</code>在做什么。</p><pre><code class="java">@Overridepublic void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) {    applyDefaultToken(params);    mGlobal.addView(view, params, mDisplay, mParentWindow);}</code></pre><p>mGlobal是WindowManagerGlobal，从命名方式和<code>getInstance</code>看出，很明显的全局单例。<br><code>private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();</code><br>看下WindowManagerGlobal中的4个引用</p><pre><code class="java">public final class WindowManagerGlobal {    ...    //放着所有的DecorView。（有的博客说放着所有的View，但是WMG里面用了mViews.add()的地方只有一个，而且只会传入DecorView。因此我认为是只放DecorView）    private final ArrayList&lt;View&gt; mViews = new ArrayList&lt;View&gt;();    //放着所有的ViewRootImpl    private final ArrayList&lt;ViewRootImpl&gt; mRoots = new ArrayList&lt;ViewRootImpl&gt;();    //放着所有的WindowManager.LayoutParams    private final ArrayList&lt;WindowManager.LayoutParams&gt; mParams =new ArrayList&lt;WindowManager.LayoutParams&gt;();    //放着所有正在被删除的View。    private final ArraySet&lt;View&gt; mDyingViews = new ArraySet&lt;View&gt;();    ...}</code></pre><p>接着mGlobal.addView里面在做什么。</p><pre><code class="java">public void addView(View view, ViewGroup.LayoutParams params,        Display display, Window parentWindow) {    final WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;    ViewRootImpl root;    //实例化了ViewRootImpl，调用他的构造方法。    root = new ViewRootImpl(view.getContext(), display);    view.setLayoutParams(wparams);    mViews.add(view);    mRoots.add(root);    mParams.add(wparams);    // do this last because it fires off messages to start doing things    root.setView(view, wparams, panelParentView);//调用了ViewRootImpl#setView。跟进去看下}</code></pre><p>ViewRootImpl#setView</p><pre><code class="java">public void setView(View view, WindowManager.LayoutParams attrs, View panelParentView) {    mView = view;    // Schedule the first layout -before- adding to the window    // manager, to make sure we do the relayout before receiving    // any other events from the system.    requestLayout();    //将该Window添加到屏幕。    //mWindowSession实现了IWindowSession接口，它是Session的客户端Binder对象.    //addToDisplay是一次AIDL的跨进程通信，通知WindowManagerService添加IWindow    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,        getHostVisibility(), mDisplay.getDisplayId(),        mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,        mAttachInfo.mOutsets, mInputChannel);    view.assignParent(this);}</code></pre><p>requestLayout()里面调用scheduleTraversals();然后调用Choreographer编舞者的内部的一系列方法，用Handler和Looper,把doTraversals()放到主线程去轮询。然后调用的就是三大遍历，测量，布局，绘制。<br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>View#post(Runnable-runnable)为什么能拿到view的宽高。</title>
    <link href="/2018/07/19/View/View#post(Runnable-runnable)%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8B%BF%E5%88%B0view%E7%9A%84%E5%AE%BD%E9%AB%98%E3%80%82/"/>
    <url>/2018/07/19/View/View#post(Runnable-runnable)%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E6%8B%BF%E5%88%B0view%E7%9A%84%E5%AE%BD%E9%AB%98%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>结论：view.post()方法在整个view树的performMeasure, performLayout, performDraw执行完后，才被主线程轮询到，才得到执行。</p><hr><p>基于android sdk-23的源码分析，文章分成两个部分，实际上我是先写第二部分了再写第一部分的。</p><h2 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h2><p>看一下view.post的内部。</p><pre><code class="java">public boolean post(Runnable action) {    final AttachInfo attachInfo = mAttachInfo;    if (attachInfo != null) {        return attachInfo.mHandler.post(action);    }    // Assume that post will succeed later    ViewRootImpl.getRunQueue().post(action);    return true;}</code></pre><p>如果在Activity#onCreate()中直接调用view.post，attachInfo==null，因为此时view还没有attach到Window上。那么看ViewRootImpl.getRunQueue().post(action)。</p><pre><code class="java">/** * The run queue is used to enqueue pending work from Views when no Handler is * attached.  The work is executed during the next call to performTraversals on * the thread. * @hide */static final class RunQueue {    private final ArrayList&lt;HandlerAction&gt; mActions = new ArrayList&lt;HandlerAction&gt;();    void post(Runnable action) {        postDelayed(action, 0);    }    void postDelayed(Runnable action, long delayMillis) {        HandlerAction handlerAction = new HandlerAction();        handlerAction.action = action;        handlerAction.delay = delayMillis;        synchronized (mActions) {            mActions.add(handlerAction);        }    }    ...    void executeActions(Handler handler) {        synchronized (mActions) {            final ArrayList&lt;HandlerAction&gt; actions = mActions;            final int count = actions.size();            for (int i = 0; i &lt; count; i++) {                final HandlerAction handlerAction = actions.get(i);                handler.postDelayed(handlerAction.action, handlerAction.delay);            }            actions.clear();        }    }    private static class HandlerAction {        Runnable action;        long delay;        @Override        public boolean equals(Object o) {            if (this == o) return true;            if (o == null || getClass() != o.getClass()) return false;            HandlerAction that = (HandlerAction) o;            return !(action != null ? !action.equals(that.action) : that.action != null);        }        @Override        public int hashCode() {            int result = action != null ? action.hashCode() : 0;            result = 31 * result + (int) (delay ^ (delay &gt;&gt;&gt; 32));            return result;        }    }}</code></pre><p>这里省略了一个remove的方法。RunQueue就是在view.post(Runnable)的时候，把Runnable放到数组mAction里，然后当ActivityThread的performTraversal()里的getRunQueue().executeActions(attachInfo.mHandler);时，就把所有数组中的Runnable发送到主线程的Looper里去轮询。当然这些都会在performTraversal()执行完之后才能执行。</p><h2 id="第二部分"><a href="#第二部分" class="headerlink" title="第二部分"></a>第二部分</h2><pre><code class="java">final class TraversalRunnable implements Runnable {    @Override    public void run() {        doTraversal();//专门用来执行ViewRootImpl里的doTraversal()，而doTraversal()里面有performTraversal();    }}final TraversalRunnable mTraversalRunnable = new TraversalRunnable();//紧接着就new出来一个实例</code></pre><p><code>mTraversalRunnable</code>在ViewRootImpl里面总共也就出现了两次</p><pre><code class="java">void scheduleTraversals() {    if (!mTraversalScheduled) {        mTraversalScheduled = true;        mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();        mChoreographer.postCallback(                Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);        if (!mUnbufferedInputDispatch) {            scheduleConsumeBatchedInput();        }        notifyRendererOfFramePending();        pokeDrawLockIfNeeded();    }}</code></pre><p>另一个是<code>void unscheduleTraversals()</code>，先不看。<br>那么在这里出现的地方这一句<code>mChoreographer.postCallback( Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, null);</code>，<br>Choreographer.n 编舞者<br>他在<code>ViewRootImpl</code>的构造方法中实例化：<code>mChoreographer = Choreographer.getInstance();</code></p><pre><code class="java">//获取单例public static Choreographer getInstance() {    return sThreadInstance.get();}//看下sThreadInstanceprivate static final ThreadLocal&lt;Choreographer&gt; sThreadInstance =        new ThreadLocal&lt;Choreographer&gt;() {    @Override    protected Choreographer initialValue() {        Looper looper = Looper.myLooper();        if (looper == null) {            throw new IllegalStateException(&quot;The current thread must have a looper!&quot;);        }        return new Choreographer(looper);    }};//看下编舞者的私有构造方法private Choreographer(Looper looper) {    mLooper = looper;    mHandler = new FrameHandler(looper);//用looper实例化了Handler。    mDisplayEventReceiver = USE_VSYNC ? new FrameDisplayEventReceiver(looper) : null;    mLastFrameTimeNanos = Long.MIN_VALUE;    mFrameIntervalNanos = (long)(1000000000 / getRefreshRate());    mCallbackQueues = new CallbackQueue[CALLBACK_LAST + 1];    for (int i = 0; i &lt;= CALLBACK_LAST; i++) {        mCallbackQueues[i] = new CallbackQueue();    }}</code></pre><p>很明显的是由ThreadLocal来控制的线程单例类，拿到的Looper也是线程单例的Looper，而创建Choreographer的ViewRootImpl是在主线程创建的，因此拿到的就是主线程的Looper。<br>看回Choreographer的postCallback();，最终进来调用的postCallbackDelayedInternal();</p><pre><code class="java">private void postCallbackDelayedInternal(int callbackType,        Object action, Object token, long delayMillis) {    if (DEBUG_FRAMES) {        Log.d(TAG, &quot;PostCallback: type=&quot; + callbackType                + &quot;, action=&quot; + action + &quot;, token=&quot; + token                + &quot;, delayMillis=&quot; + delayMillis);    }    synchronized (mLock) {        final long now = SystemClock.uptimeMillis();        final long dueTime = now + delayMillis;        mCallbackQueues[callbackType].addCallbackLocked(dueTime, action, token);        if (dueTime &lt;= now) {            scheduleFrameLocked(now);        } else {            Message msg = mHandler.obtainMessage(MSG_DO_SCHEDULE_CALLBACK, action);            msg.arg1 = callbackType;            msg.setAsynchronous(true);            //在此处用主线程的looper，最后把这个Runnable发到主线程里去，排队等待被调用mHandler.handleMessage()；最后被执行。            mHandler.sendMessageAtTime(msg, dueTime);        }    }}</code></pre><p>总之这个ViewRootImpl里的doTraversal()方法由ViewRootImpl的scheduleTraversal()最终放到<br>Android主线程的Looper里面去轮询排队执行了。</p><p>后面就是doTraversal()里面的performTraversal()了。</p><pre><code class="java"> private void performTraversals() {        // cache mView since it is used so much below...        final View host = mView;        //注：该方法有800行代码，已省略        // Execute enqueued actions on every traversal in case a detached view enqueued an action        getRunQueue().executeActions(attachInfo.mHandler);    ...    performMeasure();//从DecorView开始完成View树的测量    ...    performLayout();//从DecorView开始完成View树的布局    ...    performDraw();//从DecorView开始绘制View树 }</code></pre><p>注意：<code>getRunQueue().executeActions(attachInfo.mHandler)</code>里面会遍历数组然后把所有的view.post(Runnable)里的Runnable都用和主线程Looper关联的Hanlder#sendMessage出去，放到主线程Looper里轮询，等待调用。那么由于当前的<code>performTraversals()</code>本身就是由主线程Looper回调给刚才的编舞者Choreographer里面去执行的，因此主线程一定会等待performTraversals()整个方法执行完，才去接着执行由view.post()推送到主线程的Runnable。因此整个View树都完成了测量，布局，绘制。然后view.post()里面百分百的可以拿到view的宽高了。</p><hr><p>thanks</p><p><a href="https://blog.csdn.net/scnuxisan225/article/details/49815269" target="_blank" rel="noopener">通过View.post()获取View的宽高引发的两个问题：1post的Runnable何时被执行，2为何View需要layout两次；以及发现Android的一个小bug - CSDN博客</a></p><p><a href="https://www.cnblogs.com/dasusu/p/8047172.html" target="_blank" rel="noopener">【Android源码解析】View.post()到底干了啥 - 请叫我大苏 - 博客园</a></p><p></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RecyclerView记事</title>
    <link href="/2018/07/19/Android/RecyclerView%E8%AE%B0%E4%BA%8B/"/>
    <url>/2018/07/19/Android/RecyclerView%E8%AE%B0%E4%BA%8B/</url>
    
    <content type="html"><![CDATA[<ol><li>当RecyclerView组装完后，立刻去获取Item的高度：<pre><code>int childHeight = recyclerView.getLayoutManager().findViewByPosition(0).getHeight();</code></pre>会报空指针，因为itemView还没有attach到recyclerView中，获取不到itemView，用<code>view.post()</code>解决<pre><code class="java">recyclerView.post(new Runnable){ int childHeight = recyclerView.getLayoutManager().findViewByPosition(0).getHeight();}</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git压缩版本快照</title>
    <link href="/2018/07/19/git/git%E5%8E%8B%E7%BC%A9%E7%89%88%E6%9C%AC%E5%BF%AB%E7%85%A7/"/>
    <url>/2018/07/19/git/git%E5%8E%8B%E7%BC%A9%E7%89%88%E6%9C%AC%E5%BF%AB%E7%85%A7/</url>
    
    <content type="html"><![CDATA[<p>目前有两种方案：</p><ol><li><code>git merge --squash</code></li><li><h2 id="git-rebase-i-HEAD-n"><a href="#git-rebase-i-HEAD-n" class="headerlink" title="git rebase -i HEAD~n"></a><code>git rebase -i HEAD~n</code></h2></li></ol><h2 id="1-merge"><a href="#1-merge" class="headerlink" title="1. merge"></a>1. merge</h2><pre><code>git merge --squash &lt;要合并的分支&gt;</code></pre><p>例子：<br>本地的情况：</p><ol><li>用普通的git merge<br><img src="https://upload-images.jianshu.io/upload_images/7177220-53c5c615c305f866.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ol><p>当用<code>git checkout master</code>+<code>git merge develop</code>:<br><img src="https://upload-images.jianshu.io/upload_images/7177220-3107771c580978e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="省略了origin/master"><br>此时用<code>git push</code>，会将<code>3,4,5,10,11,12,13</code>的<code>版本快照</code>全部push到服务器去。那么如果要我要压缩，把这么多<code>版本快照</code>压缩成一个<code>版本快照</code>然后push到服务器呢？<br>2. 用git merge –squash &lt;要合并的分支&gt;</p><pre><code>git checkout mastergit merge --squash develop</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-89cdac30f2f2e579.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>此时用<code>git push</code>，只会push<code>3和13</code>到服务器去，于和之前的区别在于，<code>13</code>不再指向<code>12</code>，因此不会把12那边的链都push上去。</p><p>当然，此时还是会push两个版本快照到服务器，那么咋办：从<code>origin/master</code>再checkout一个新的分支，然后用<code>git merge -squash master</code>，再push，就可以了。</p><p>##2. rebase</p><pre><code>git rebase -i HEAD~n</code></pre><p>上述表示选定<strong>当前分支</strong>中包含<code>HEAD</code>在内的<code>n</code>个最新<code>版本快照</code>为对象，并在编辑器中打开。<br>比如本地版本库为如下：</p><pre><code class="git">* f9bcbae (HEAD -&gt; master) 12346579* aa82af1 132* 58f2314 用文本编辑器写的comment* e5d8212 (origin/master) 123</code></pre><p>这个时候push的话，会吧<code>f9bcbae</code>,<code>aa82af1</code>,<code>58f2314</code>都push到服务器去。<br>执行：</p><pre><code>git rebase -i HEAD~3</code></pre><p>git打开了文本编辑器，显示：</p><pre><code>pick 58f2314 用文本编辑器写的commentpick aa82af1 132pick f9bcbae 12346579# Rebase e5d8212..f9bcbae onto e5d8212 (3 commands)## Commands:# p, pick &lt;commit&gt; = use commit# r, reword &lt;commit&gt; = use commit, but edit the commit message# e, edit &lt;commit&gt; = use commit, but stop for amending# s, squash &lt;commit&gt; = use commit, but meld into previous commit# f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#39;s log message# x, exec &lt;command&gt; = run command (the rest of the line) using shell# d, drop &lt;commit&gt; = remove commit# l, label &lt;label&gt; = label current HEAD with a name# t, reset &lt;label&gt; = reset HEAD to a label# m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]# .       create a merge commit using the original merge commit&#39;s# .       message (or the oneline, if no original merge commit was# .       specified). Use -c &lt;commit&gt; to reword the commit message.## These lines can be re-ordered; they are executed from top to bottom.## If you remove a line here THAT COMMIT WILL BE LOST.##    However, if you remove everything, the rebase will be aborted.##    # Note that empty commits are commented out</code></pre><p>把后面的两个版本快照的前缀<code>pick</code>修改为<code>fixup</code></p><pre><code>pick 58f2314 用文本编辑器写的commentfixup aa82af1 132fixup f9bcbae 12346579</code></pre><p>保存，关掉文本编辑器。<br>显示：</p><pre><code>$ git rebase -i HEAD~3Successfully rebased and updated refs/heads/master.</code></pre><p>查看版本库信息：</p><pre><code>* 2db421a (HEAD -&gt; master) 用文本编辑器写的comment* e5d8212 (origin/master) 123</code></pre><p>原本那三个版本快照只剩了一个刚才没有修改pick前缀的版本快照，并且<code>hash</code>也改变了，猜测意思是：重新生成了版本快照。<br>此时也达到了压缩版本快照的目的。push时，只会push<code>2db421a</code>上去。<br></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为git设置文本编辑器。</title>
    <link href="/2018/07/19/git/%E4%B8%BAgit%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%82/"/>
    <url>/2018/07/19/git/%E4%B8%BAgit%E8%AE%BE%E7%BD%AE%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%99%A8%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>直接输入<code>git commit</code>的时候，或者<code>git rebase -i</code>来压缩的时候，都会进入git默认的文本编辑器，根本不会用，然后只能被迫关闭。后得知可以更改文本编辑器，配置如下：</p><pre><code>git config --global core.editor &quot;\&quot;D:\应用程序\Sublime Text3\sublime_text.exe\&quot;&quot;</code></pre><p>更改后，当git要进入文本编辑器的时候，就会直接打开路径下的sublime text了。</p><p>配制后的<code>C:\Users\admin\.gitconfig</code>如下:</p><pre><code>//...略[core]    editor = \&quot;D:\\应用程序\\Sublime Text3\\sublime_text.exe\&quot;</code></pre><hr><p>thanks:<a href="https://my.oschina.net/lmpudding/blog/730097" target="_blank" rel="noopener">https://my.oschina.net/lmpudding/blog/730097</a><br></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记录自定义Dialog的一个天坑和启动Dialog的小流程</title>
    <link href="/2018/07/17/View/%E8%AE%B0%E5%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89Dialog%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%A9%E5%9D%91%E5%92%8C%E5%90%AF%E5%8A%A8Dialog%E7%9A%84%E5%B0%8F%E6%B5%81%E7%A8%8B/"/>
    <url>/2018/07/17/View/%E8%AE%B0%E5%BD%95%E8%87%AA%E5%AE%9A%E4%B9%89Dialog%E7%9A%84%E4%B8%80%E4%B8%AA%E5%A4%A9%E5%9D%91%E5%92%8C%E5%90%AF%E5%8A%A8Dialog%E7%9A%84%E5%B0%8F%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h2 id="记录自定义Dialog的一个天坑。"><a href="#记录自定义Dialog的一个天坑。" class="headerlink" title="记录自定义Dialog的一个天坑。"></a>记录自定义Dialog的一个天坑。</h2><pre><code class="java">/** * Created by 黄伟杰 on 2018/7/17. */public class MyDialog extends Dialog {    private Context context;    public MyDialog(@NonNull Context context) {        super(context);        this.context=context;    }    @Override    protected void onCreate(Bundle savedInstanceState) {        setContentView(R.layout.dialog);//放在onCreate里去调用，文档里就是这么写的。        locateWindow(Gravity.TOP|Gravity.CENTER_HORIZONTAL);    }    //如果这个方法不在setContentView后面调用，params.width和params.height的设置将会失效    private void locateWindow(int gravity){        Window window = getWindow();        Objects.requireNonNull(window).setGravity(gravity);        WindowManager.LayoutParams params = Objects.requireNonNull(window).getAttributes();        params.y = DensityUtil.dip2px(context, 49);        params.width = WindowManager.LayoutParams.MATCH_PARENT;        params.height = WindowManager.LayoutParams.WRAP_CONTENT;        window.setAttributes(params);    }}</code></pre><h2 id="附带一个Dialog的由创建到展现给用户的流程："><a href="#附带一个Dialog的由创建到展现给用户的流程：" class="headerlink" title="附带一个Dialog的由创建到展现给用户的流程："></a>附带一个<code>Dialog</code>的由创建到展现给用户的流程：</h2><p><em>贴出的源码都是浓缩版代码</em></p><hr><p>构造方法：</p><pre><code class="java">    Dialog( Context context, int themeResId, boolean createContextThemeWrapper) {        ...        //获取单例类WindowManager。        mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);        //创建PhoneWindow对象        final Window w = new PhoneWindow(mContext);        mWindow = w;      ...    }</code></pre><p>创建完后，我们代码里调用<code>Dialog#show</code></p><pre><code class="java">public void show(){    dispatchOnCreate(null);//  ==&gt;调用onCreate();    onStart();    mDecor=mWindow.getDecorView();//获取我们Dialog所在的Window上的DecorView。    mWindowManager.addView(mDecor, l);//把顶级DecorView放到Window上。  //至此，Dialog显示出来了。准确地说，是刚才创建的PhoneWindow上的View显示出来了。}</code></pre><p>在onCreate()中，按照谷歌文档的推荐，在此处调用<code>setContentView()</code>;<br><img src="https://upload-images.jianshu.io/upload_images/7177220-20abe6de646a5a01.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><hr><p>要深入去看Window的一些东西，看这个大神的文章：<br><a href="https://blog.csdn.net/qian520ao/article/details/78555397" target="_blank" rel="noopener">Android Window 机制探索 - 凶残的程序员</a><br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RecyclerView的复用</title>
    <link href="/2018/07/12/Android/RecyclerView%E7%9A%84%E5%A4%8D%E7%94%A8/"/>
    <url>/2018/07/12/Android/RecyclerView%E7%9A%84%E5%A4%8D%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>当有9个不同的Item显示在屏幕上，一定有超过9个的ViewHolder对象，通过<code>onCreateViewHolder(ViewGroup parent, int type)</code>被创建（也就是其引用的View对象被创建）。</p><p>根据官方文档阅读到的资料，大致整理了一下RecyclerView的3个方面：</p><h3 id="创建Item"><a href="#创建Item" class="headerlink" title="创建Item"></a>创建Item</h3><ol><li>从.xml布局文件中<code>inflate</code>出新的View对象.</li><li>上述新建的View对象作为参数传入ViewHolder的构造函数来创建ViewHolder对象。</li></ol><h3 id="显示或更新数据"><a href="#显示或更新数据" class="headerlink" title="显示或更新数据"></a>显示或更新数据</h3><ol><li>为每个ViewHolder对象分配一个position，并调用<code>onBindViewHolder(ViewHolder holder, int position)</code>，来将数据写入ViewHolder中引用的View。</li><li>当数据实体或者数据在结构上改变（如增减list中的元素），用<code>mAdapter#notifyXXX()</code>，Adapter会自动重新进行必要的数据更新。</li></ol><h3 id="复用"><a href="#复用" class="headerlink" title="复用"></a>复用</h3><p>每当滑动RecyclerView时，被滑出的Item的View不会从内存中释放，RecyclerView通过引用着ViewHolder，保存着滑出的Item中的View对象，这样在新滑入的Item要进入用户视线时，不用再去.xml文件中加载新的View对象，而是拿到刚才被ViewHolder引用着的View对象，通过onBindViewHolder()重新为其写入数据，后其回到用户视线，实现了View对象的复用。</p><p>做了个实验，写了一个一次展示9个Item的RecyclerView，在RecyclerView的Adapter中的<code>onCreateViewHolder</code>和<code>onBindViewHolder()</code>中打印出传入的ViewHolder中的itemView的<code>hashCode</code>值。</p><ol><li>当RecylerView显示到界面时，log显示为每个ViewHolder依次创建并写入数据，屏幕上面有9个Item，但是log中创建了10个Item。<pre><code>onCreateViewHolder: 创建ViewHolder，引用着View:android.widget.FrameLayout{42b36fb0 V.E..... ......I. 0,0-0,0}onBindViewHolder: 将数据写入ViewHolder中的View:android.widget.FrameLayout{42b36fb0 V.E..... ......I. 0,0-0,0}</code></pre></li><li>向下滑动时，根据观察<code>hashCode</code>，又创建并写入数据了3个新的View，即此时已经创建了13个View，或者说13个ViewHolder了。</li><li>当再滑动时，不再调用<code>onCreateViewHolder()</code>，只会不断地调用<code>onBindViewHolder()</code>，并且打印出的hashCode值都是前面13个View的hashCode值中出现过的，这说明此时不再创建View了，而是通过复用从屏幕中滑出的View来重新写入数据，来展示。</li></ol><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ViewGroup拦截子View点击事件失败</title>
    <link href="/2018/07/12/View/ViewGroup%E6%8B%A6%E6%88%AA%E5%AD%90View%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%A4%B1%E8%B4%A5/"/>
    <url>/2018/07/12/View/ViewGroup%E6%8B%A6%E6%88%AA%E5%AD%90View%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E5%A4%B1%E8%B4%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7177220-91210f087c254c6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>流程图整理自<a href="http://wangkuiwu.github.io/2015/01/04/TouchEvent-ViewGroup/" target="_blank" rel="noopener">Android 触摸事件机制(四) ViewGroup中触摸事件详解 | skywang</a></p><h3 id="事情起因："><a href="#事情起因：" class="headerlink" title="事情起因："></a>事情起因：</h3><p>要用RelativeLayout去拦截里面的子View的点击事件，因此直接为</p><pre><code>relativeLayout.setOnTouchListener(new View.OnTouchListener() {    @Override    public boolean onTouch(View v, MotionEvent event) {        return true;    }});</code></pre><p>打算通过返回true来将后续的点击事件消费掉，但是失败了。</p><h3 id="在看了源码分析之后，找到原因："><a href="#在看了源码分析之后，找到原因：" class="headerlink" title="在看了源码分析之后，找到原因："></a>在看了源码分析之后，找到原因：</h3><ol><li>当ViewGroup有子View的时候，一定能拦截点击事件的入口是<code>onInterceptTouchEvent()</code>。</li><li>当ViewGroup有子View能接收点击事件的时候，不会调用ViewGroup任何自己的点击事件监听方法（无论内部还是外部设置的监听器）。</li><li>当ViewGroup没有子View能接收点击事件时，则会调用super.dispatchTouchEvent()，此时将ViewGroup当做View来看，按照View的那一套来。</li></ol><h3 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h3><p>我的RelativeLayout里面的子View可以接收点击事件，因此点击事件会直接传给他们，无法通过外部设置监听器去拦截。<br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android自定义View中用NinePatch类画9图</title>
    <link href="/2018/07/03/View/android%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%AD%E7%94%A8NinePatch%E7%B1%BB%E7%94%BB9%E5%9B%BE/"/>
    <url>/2018/07/03/View/android%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B8%AD%E7%94%A8NinePatch%E7%B1%BB%E7%94%BB9%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p>9图的制作在官网和其他博客中都有大量教程，最终可以制作出<code>XXX.9.png</code>文件</p><p>##　没有用NinePatch:<br>在自定义View中，直用<code>Bitmap</code>和画笔而不配合<code>NinePatch</code>类是画不9图的效果的，比如：</p><pre><code>//R.drawable.image9Patch是制作好的9图Bitmap bitmap=BitmapFactory.decodeResource(getResources(),R.drawable.image9Patch)</code></pre><pre><code>@Overrideprotected void onDraw(Canvas canvas) {   ...创建RectF dst，作为bitmap被画出且自动缩放的矩形区域。   //直接用canvas画   canvas.drawBitmap(bitmap,null,dst,null);}</code></pre><p>这样是画不出想要的9图的效果的。在目标矩形中，图片依然会被不和谐地拉伸或缩放。</p><h2 id="用了NinePatch"><a href="#用了NinePatch" class="headerlink" title="用了NinePatch"></a>用了NinePatch</h2><pre><code>@Overrideprotected void onDraw(Canvas canvas) {    ...创建RectF dst，作为bitmap被画出且自动缩放的矩形区域。    NinePatch np=new NinePatch(bitmap,bitmap.getNinePatchChunk(),null);    np.draw(canvas,dst);}</code></pre><p>借助<code>NinePatch</code>这个类，用他来画，最后在目标矩形区域，可以成功地按照9图的方式来缩放。<br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dagger2配合Application拓展类实现单例模式</title>
    <link href="/2018/07/02/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/Dagger2%E9%85%8D%E5%90%88Application%E6%8B%93%E5%B1%95%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2018/07/02/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/Dagger2%E9%85%8D%E5%90%88Application%E6%8B%93%E5%B1%95%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>需要提前了解Dagger2的<code>@Singleton</code> 和 <code>@Component</code>依赖。</p></blockquote><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Android中的单例模式，可以通过继承<code>Application</code>类，在onCreate中初始化单例类，然后将单例类的引用通过<code>getXXX()</code>发布出去。<br>Application类提供了天然的单例模式。</p><p>但是，如果我们有10个单例类，那么就需要</p><ol><li>在<code>Application</code>类里面写10个引用，</li><li>10个<code>getXXX()</code>方法</li><li><code>onCreate()</code>中10个单例类的初始化</li></ol><p><strong>缺点</strong> </p><ol><li>当需求变动，要更换实现类的时候，要在Application里面做修改</li><li><code>onCreate()</code>中初始化的10个单例类，并不是马上就要用的，更好的做法是，要用到他们的时候才实例化他们，但是在<code>onCreate()</code>中实例化，则必须将10个类一次性提前全部实例化。<h2 id="用Dagger2解决上述两个缺点"><a href="#用Dagger2解决上述两个缺点" class="headerlink" title="用Dagger2解决上述两个缺点"></a>用Dagger2解决上述两个缺点</h2></li><li>依赖Dagger2</li><li>将10个单例类从Application类中移除</li><li>创建<code>ApplicationComponent</code>类，并用<code>@Component</code>和<code>@Singleton</code>标注，在<code>ApplicationComponent</code>中写<strong>带返回值的方法</strong>（用于别的Component类来依赖，或者自己要用的时候调用），不写<code>void inject(上下文)</code>方法，因为不需要在<code>onCreate</code>中立刻实例化那10个单例类。</li><li>创建<code>ApplicationModule</code>类，标注<code>@Module</code>，写好工厂方法并标注<code>@Provides</code>和<code>@Singleton</code>，回到<code>ApplicationComponent</code>，加上这个<code>ApplicationModule.class</code>。</li><li>在<code>onCreate</code>中实例化<code>ApplicationComponent</code>，并用<code>getApplicationComponent()</code>，将该<code>component</code>对象发布出去。</li></ol><p>那么这个时候，在别处任何地方通过该<code>ApplicationComponent</code>对象来依赖注入的任何对象，都是单例的。<br>而且别的<code>Component</code>还可以依赖<code>ApplicationComponent</code>来拓展自己的依赖注入范围，且通过拓展而来的那些依赖注入来的对象，依然是单例的。<br><strong>好处</strong>：</p><ol><li>大大缩减了<code>Application</code>类的代码量。</li><li>当后期需求变动，要改单例类的实现时，只要改<code>ApplicationModule</code>中的工厂方法即可。<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>第三方库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dagger2脑图</title>
    <link href="/2018/07/02/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/Dagger2%E8%84%91%E5%9B%BE/"/>
    <url>/2018/07/02/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/Dagger2%E8%84%91%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7177220-160c551b48a38df5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>查看原图会非常清晰。<br>对于@Component的依赖，不理解就对着这篇博客敲一遍就懂了</p><p></p>]]></content>
    
    
    <categories>
      
      <category>第三方库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git，为服务器仓库建立新的分支。</title>
    <link href="/2018/07/01/git/git%EF%BC%8C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%93%E5%BA%93%E5%BB%BA%E7%AB%8B%E6%96%B0%E7%9A%84%E5%88%86%E6%94%AF%E3%80%82/"/>
    <url>/2018/07/01/git/git%EF%BC%8C%E4%B8%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%93%E5%BA%93%E5%BB%BA%E7%AB%8B%E6%96%B0%E7%9A%84%E5%88%86%E6%94%AF%E3%80%82/</url>
    
    <content type="html"><![CDATA[<ol><li>直接在github页面上面<br><img src="https://upload-images.jianshu.io/upload_images/7177220-52841b598e3056d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ol><p>当前切换到了master分支，如果文本框输入后一个新的分支名字后，确认，就会创建一个分支指向master分支。要创建一个分支指向develop分支，就将当前分支切换到develop上面。</p><p>这一切都用鼠标可以完成，很直观简洁。</p><ol start="2"><li>通过git bash。<br>如果我要在服务器创建一个新的分支bugfix指向develop，这做不到。只能通过push命令，让这一次push跟踪到develop，在develop分支上面生成新的快照，并将新的bugfix指向新的版本快照。</li></ol><p>在本地的develop分支<code>chekout -b</code>一个<code>bugfix</code>分支，然后执行<code>git branch -u origin/bugfix</code>来追踪远程的<code>bugfix</code>分支(这时他不存在)，然后执行<code>git push origin bugfix</code>。</p><p>由于我们本地追踪的远程分支<code>origin/bugfix</code>不存在，而本地分支<code>bugfix</code>是在<code>develop</code>基础上创建的，因此新建在服务器会基于<code>develop</code>分支新建一个<code>bugfix</code>分支，最后达到新建分支的目的。</p><hr><p>结论：还是直接去github创建分支简单点，也不容易出错。<br></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git跟踪远程分支，查看本地分支追踪和远程分支的关系</title>
    <link href="/2018/07/01/git/git%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E8%BF%BD%E8%B8%AA%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E5%85%B3%E7%B3%BB/"/>
    <url>/2018/07/01/git/git%E8%B7%9F%E8%B8%AA%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%EF%BC%8C%E6%9F%A5%E7%9C%8B%E6%9C%AC%E5%9C%B0%E5%88%86%E6%94%AF%E8%BF%BD%E8%B8%AA%E5%92%8C%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF%E7%9A%84%E5%85%B3%E7%B3%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="跟踪远程分支"><a href="#跟踪远程分支" class="headerlink" title="跟踪远程分支"></a>跟踪远程分支</h2><p>如果用<code>git push</code>指令时，当前分支没有跟踪远程分支（没有和远程分支建立联系），那么就会git就会报错</p><pre><code>There is no tracking information for the current branch.Please specify which branch you want to merge with.</code></pre><p>因为当前分支没有追踪远程指定的分支的话，当前分支指定的版本快照不知道要作为服务器哪一个分支的版本快照的子节点。简单来说就是：不知道要推送给哪一个分支。<br>那么如何建立远程分支：</p><ol><li>克隆时自动将创建好的<code>master</code>分支追踪<code>origin/master</code>分支<pre><code>git clone 服务器地址</code></pre></li><li><pre><code>git checkout -b develop origin/develop</code></pre>在远程分支的基础上建立<code>develop</code>分支，并且让<code>develop</code>分支追踪<code>origin/develop</code>远程分支。</li><li><pre><code>git branch --set-upstream branch-name origin/branch-name</code></pre>将<code>branch-name</code>分支追踪远程分支<code>origin/branch-name</code></li><li><pre><code>git branch -u origin/serverfix</code></pre>设置当前分支跟踪远程分支origin/serverfix</li></ol><h2 id="查看本地分支和远程分支的跟踪关系"><a href="#查看本地分支和远程分支的跟踪关系" class="headerlink" title="查看本地分支和远程分支的跟踪关系"></a>查看本地分支和远程分支的跟踪关系</h2><pre><code>git branch -vv</code></pre><p>比如输入</p><pre><code>$ git branch -vv  develop   08775f9 [origin/develop] develop  feature_1 b41865d [origin/feature_1] feature_1* master    1399706 [my_github/master] init commit</code></pre><p><code>develop</code>分支跟踪<code>origin/develop</code><br><code>feature_1</code>分支跟踪<code>origin/feature_1</code><br><code>master</code>跟踪了<code>my_github/master</code>，且当前分支为<code>master</code>分支</p><p>那么假如我此时想要将master的改变推送到origin服务器的master分支上：</p><pre><code>$ git checkout master//切换到master分支...$ git branch -u origin/master//将当前分支跟踪origin/masterBranch &#39;master&#39; set up to track remote branch &#39;master&#39; from &#39;origin&#39;.</code></pre><p>之后就可以执行git add和git commit了<br>现在再查看一下本地和远程的分支关系：</p><pre><code>$ git branch -vv  develop   08775f9 [origin/develop] develop  feature_1 b41865d [origin/feature_1] feature_1* master    1399706 [origin/master] init commit</code></pre><p>master已经跟踪了origin/master了<br></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git多人协作模拟，图解</title>
    <link href="/2018/07/01/git/git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%A8%A1%E6%8B%9F%EF%BC%8C%E5%9B%BE%E8%A7%A3/"/>
    <url>/2018/07/01/git/git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%A8%A1%E6%8B%9F%EF%BC%8C%E5%9B%BE%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>说明，为了制图方便，因此将版本快照用<code>普通的数字</code>来表示，实际上不严谨，应该像官网用<code>SHA-1</code> 值如<code>92ec2</code>来表示版本快照更加合适。</p></blockquote><p>现在有两个人协作开发一个项目，master分支是稳定版，随时可发布，develop分支是开发版，是平时开发用的分支。</p><p>由Peter和Tony负责开发这个项目，两个人各自完成开发，测试后，<code>push</code>到服务器就可以下班。</p><p>此时在github或者gitlab上的<code>.git</code>表示的代码仓库版本情况如图</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-dc1eaec579917410.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>现在Peter和Tony两人各自打开git bash输入</p><pre><code>git clone 服务器地址</code></pre><p><code>git clone</code>指令做了4个事情：</p><ol><li>git自动将整个代码仓库包括<code>.git</code>文件夹下载下来。</li><li>自动将服务器的<code>master</code>和<code>develop</code>分支分别修改为<code>origin/master</code>和<code>origin/develop</code>，并创建一个master分支指向<code>origin/master</code>分支指向的分支。</li><li>并自动执行了<code>git branch --set-upstream-to master origin/master</code>来设置本地<code>master</code>分支跟踪<code>origin/master</code>分支。</li><li>并将<code>HEAD</code>指向master，使得工作目录全部切换到master指向的<strong>版本快照–&gt;3</strong><br><img src="https://upload-images.jianshu.io/upload_images/7177220-fcf78898bebfc417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/7177220-d37ae374ddc3ea19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ol><blockquote><p>注意：除非执行<code>git fetch</code>或者<code>git pull</code>来更新两个远程分支<code>origin/master</code>和<code>origin/develop</code>，否则远程分支将永远不变，分别指向版本快照<code>3</code>和<code>5</code></p></blockquote><h2 id="现在单独看向Peter的操作："><a href="#现在单独看向Peter的操作：" class="headerlink" title="现在单独看向Peter的操作："></a>现在单独看向Peter的操作：</h2><p>Peter在执行了<code>git clone 服务器地址</code>之后，因为要在换到develop分支上开发，而不是在master分支上开发，因此执行如下指令：</p><pre><code>//创建一个develop分支指向origin/develop分支指向的版本快照，//HEAD指向develop分支（即切换到develop分支）。git checkout -b develop origin/develop</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-39554b0018a7bedf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>此时Peter可以开始在develop分支上用<code>git add</code>和<code>git commit</code>继续开发了，现在Peter开发到了一个满意的阶段，经过测试后，打算<code>git push</code>到远程分支。<br><img src="https://upload-images.jianshu.io/upload_images/7177220-6249d19f318b7639.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Peter开发到了满意的版本快照&lt;7&gt;的阶段"><br>执行</p><pre><code>git push origin develop</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-9a7e6eb652aea306.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="原本develop指向5，现在将7作为5的下一个结点，并将develop指向7"></p><p>push成功，因为服务器的版本没有更新，因此直接push即成功了，现在看向Tony开发的怎么样了</p><h2 id="Tony做的怎么样了"><a href="#Tony做的怎么样了" class="headerlink" title="Tony做的怎么样了"></a>Tony做的怎么样了</h2><p><img src="https://upload-images.jianshu.io/upload_images/7177220-73fc3058e0bf890c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="Tony从5开始，开发到了11"><br>现在Tony也打算将自己的新的开发提交到服务器上去。（我们知道这会失败，但是来看看发生了什么）<br>执行</p><pre><code>$ git push origin developTo github.com:这个项目的包名.git ! [rejected]        dev -&gt; dev (non-fast-forward)error: failed to push some refs to &#39;git@github.com:这个项目的包名.git&#39;hint: Updates were rejected because the tip of your current branch is behindhint: its remote counterpart. Integrate the remote changes (e.g.hint: &#39;git pull ...&#39;) before pushing again.hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</code></pre><p>英文提示说Tony提交的push被拒绝了，因为Tony的远程分支<code>origin/develop</code>落后于服务器的<code>develop</code>分支。且可以考虑用<code>git pull</code>来更新合并本地分支。</p><p>而<code>git pull</code>其实是两个命令<code>git fetch</code>和<code>git merge</code>按顺序执行。<br>我们执行</p><pre><code>git fetch origin</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-31c923e4a02c0102.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="origin/develop原本指向5，现在和服务器的develop同步，指向7"><br>执行</p><pre><code>git merge origin/develop</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-21451a0dc84005bc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="merge成功后会生成一个新的版本快照，它由11和7合并而来，因此有两个父结点，此处定义它为12"></p><p>现在已经同步好了，执行</p><pre><code>git push origin develop</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-f0065661723533a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="12作为7的子节点被添加，并且develop指向12"></p><hr><p>好了，现在Tony和Peter都完成了提交，改下班了。</p><p></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Dagger2</title>
    <link href="/2018/06/30/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/Dagger2/"/>
    <url>/2018/06/30/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/Dagger2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>例子来自<a href="https://www.jianshu.com/p/24af4c102f62" target="_blank" rel="noopener">https://www.jianshu.com/p/24af4c102f62</a></p></blockquote><h1 id="只用-Inject和-Component完成依赖注入："><a href="#只用-Inject和-Component完成依赖注入：" class="headerlink" title="只用@Inject和@Component完成依赖注入："></a>只用@Inject和@Component完成依赖注入：</h1><ol><li>在gradle添加依赖，用<code>@Inject</code>和<code>@Component</code>为相应的字段和类打上注解</li><li>build project</li><li>Dagger2会在<code>app.build.generated.source.apt.debug.com.text.包名</code>生成代码。<ol><li><code>DaggerXXXComponent.java</code></li><li><code>XXX_MembersInjector.java</code></li><li><code>XXX_Factory.java</code></li></ol></li></ol><p>举一个例子：<br>MainAcitvity对象依赖Pot对象，Pot对象依赖Rose对象。</p><ol><li><p>用<code>@Inject</code>标注要被实例化的引用（在这里是<code>MainActivity</code>中的<code>Pot pot</code>字段，<code>Pot</code>中的<code>Rose rose</code>字段）<strong>&lt;Dagger2会为他们生成一个注入器类Injector&gt;</strong></p></li><li><p>用<code>@Inject</code>标注要被实例化的类的构造方法（在这里是<code>Pot</code>类和<code>Rose</code>类要被实例化）<strong>&lt;Dagger2会为Pot和Rose生成对应的工厂类&gt;</strong></p></li><li><p>用<code>@Component</code>标注一个接口<strong>&lt;Dagger2会为其生成XXXComponent类&gt;</strong></p><pre><code>public class MainActivity extends AppCompatActivity { private static final String TAG = &quot;MainActivity&quot;; @Inject public Pot pot;//MainActivity依赖Pot对象 @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main); }}</code></pre><pre><code>public class Pot { private Rose rose;//Pot对象依赖Rose对象 @Inject public Pot(Rose rose){     this.rose=rose; } public String show(){     return rose.whisper(); }}</code></pre><pre><code>public class Rose { //Rose对象没有任何依赖 @Inject public Rose() { } public String whisper(){     return &quot;热恋&quot;; }}</code></pre><pre><code>@Componentpublic interface MainActivityComponent { void inject(MainActivity activity);}</code></pre><p>点击build project，生成了：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-e3046a306f48b02e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>现在可以使用：</p><pre><code>public class MainActivity extends AppCompatActivity { private static final String TAG = &quot;MainActivity&quot;; @Inject public Pot pot; @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);     //此时pot还指向null，不可用     DaggerMainActivityComponent.create().inject(this);//实现pot的实例化     //此时pot已经指向对象，可用 }}</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-e251c2c7ab62b9d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p></li></ol><p>现在分析Dagger2生成的四个类<br><code>DaggerMainActivityComponent</code><br><code>MainActivity_MembersInjector</code><br><code>Pot_Factory</code><br><code>Rose_Factory</code></p><h3 id="Pot-Factory和Rose-Factory"><a href="#Pot-Factory和Rose-Factory" class="headerlink" title="Pot_Factory和Rose_Factory"></a>Pot_Factory和Rose_Factory</h3><p><code>XXX_Factory implements Fatory&lt;XXX&gt;</code><br><code>Factory&lt;XXX&gt; implements Provider&lt;XXX&gt;</code><br>也就是工厂类的最终抽象是<code>Provider</code><br><img src="https://upload-images.jianshu.io/upload_images/7177220-8e357281c58cbefb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><pre><code>public enum Rose_Factory implements Factory&lt;Rose&gt; {  INSTANCE;  @Override  public Rose get() {//get()方法返回泛型&lt;Rose&gt;实例，用来生成对象    return new Rose();  }  public static Factory&lt;Rose&gt; create() {//create()方法用来生成工厂对象    return INSTANCE;  }}</code></pre><pre><code>public final class Pot_Factory implements Factory&lt;Pot&gt; {//因为Pot类的构造方法有参数，参数对象要提前Pot对象实例化，因此持有一个参数对象的类的工厂类，//用来创建参数对象。  private final Provider&lt;Rose&gt; roseProvider;  public Pot_Factory(Provider&lt;Rose&gt; roseProvider) {    assert roseProvider != null;    this.roseProvider = roseProvider;  }  @Override  public Pot get() {//get()方法返回泛型&lt;Pot&gt;实例，用来生成对象    return new Pot(roseProvider.get());  }  //create()方法用来生成工厂对象  public static Factory&lt;Pot&gt; create(Provider&lt;Rose&gt; roseProvider) {    return new Pot_Factory(roseProvider);  }}</code></pre><h3 id="MainActivity-MembersInjector"><a href="#MainActivity-MembersInjector" class="headerlink" title="MainActivity_MembersInjector"></a>MainActivity_MembersInjector</h3><p>由MainActivity的引用上的@Inject注解生成</p><pre><code>@Injectpublic Pot pot;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-c2ec45a6d0d2fe3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>代码如下</p><pre><code>public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; {//持有Pot的工厂类，用来生成Pot对象  private final Provider&lt;Pot&gt; potProvider;  public MainActivity_MembersInjector(Provider&lt;Pot&gt; potProvider) {    assert potProvider != null;    this.potProvider = potProvider;  }//静态方法供外部调用，用来创建这个注入器  public static MembersInjector&lt;MainActivity&gt; create(Provider&lt;Pot&gt; potProvider) {    return new MainActivity_MembersInjector(potProvider);  }//依赖注入的直接入口，将传入的MainActivity对象的引用变量，用工厂类生成其实例,//实现依赖注入。  @Override  public void injectMembers(MainActivity instance) {    if (instance == null) {      throw new NullPointerException(&quot;Cannot inject members into a null reference&quot;);    }    instance.pot = potProvider.get();//用工厂类对象创建对象。  }}</code></pre><h3 id="DaggerMainActivityComponent"><a href="#DaggerMainActivityComponent" class="headerlink" title="DaggerMainActivityComponent"></a>DaggerMainActivityComponent</h3><p><img src="https://upload-images.jianshu.io/upload_images/7177220-c8e1b0825b152a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><pre><code>/** * 持有工厂类和注入器类的引用。 * 注入器的实例化需要工厂类对象作为参数。 * 因此Component类连接工厂类和注入器类，最后通过注入器类来完成工作。 *  *  * inject方法直接调用注入器的injectMembers(),注入器中的方法才是注入的直接入口 *  */public class DaggerMainActivityComponent {    public final class DaggerMainActivityComponent implements MainActivityComponent {        private Provider&lt;Pot&gt; potProvider;//工厂类        private MembersInjector&lt;MainActivity&gt; mainActivityMembersInjector;//注入器        private DaggerMainActivityComponent(com.test.traindagger.DaggerMainActivityComponent.Builder builder) {            assert builder != null;            initialize(builder);        }        public static com.test.traindagger.DaggerMainActivityComponent.Builder builder() {            return new com.test.traindagger.DaggerMainActivityComponent.Builder();        }        public static MainActivityComponent create() {            return builder().build();        }        @SuppressWarnings(&quot;unchecked&quot;)        private void initialize(final com.test.traindagger.DaggerMainActivityComponent.Builder builder) {            //实例化工厂类            this.potProvider = Pot_Factory.create(Rose_Factory.create());            //依赖工厂类来实例化注入器            this.mainActivityMembersInjector = MainActivity_MembersInjector.create(potProvider);        }        //就是我们在使用的时候用的inject方法        //调用注入器的injectMembers（上下文）来实现注入        @Override        public void inject(MainActivity activity) {            mainActivityMembersInjector.injectMembers(activity);        }        public static final class Builder {            private Builder() {}            public MainActivityComponent build() {                return new com.test.traindagger.DaggerMainActivityComponent(this);            }        }    }}</code></pre><h1 id="加入-Module和-Provide"><a href="#加入-Module和-Provide" class="headerlink" title="加入@Module和@Provide"></a>加入@Module和@Provide</h1><p>使用场景:</p><ol><li>无法为第三方库中的类中的构造方法去加上<code>@Inject</code>，也就无法通过这种方式让Dagger2为其生成工厂类</li><li>当使用了依赖倒置，构造器上的参数就是抽象的（接口或抽象类），Dagger2无法通过构造函数上的<code>@Inject</code>将其参数中的接口实例化，因为他并不知道实现类是谁。</li></ol><p>比如<strong>场景1</strong>：将上面的<code>Rose</code>类，抽象出来一个<code>Flower</code>类，并将<code>Pot</code>类中的所有<code>Rose</code>引用替换为<code>Flower</code>引用，因此<code>Rose</code>在这里实现了依赖倒置，那么Dagger2无法通过<code>Rose</code>类的构造方法为<code>Rose</code>类生成工厂类，而<code>Pot</code>类没有使用依赖倒置，因此<code>Pot</code>类的构造方法依然可以使用<code>@Inject</code>来让Dagger2为<code>Pot</code>生成工厂类。</p><pre><code>public class Pot {    private Flower flower;//将Rose引用替换为了Flower，依赖倒置    @Inject    public Pot(Flower flower){        this.flower=flower;    }    public String show(){        return flower.whisper();    }}</code></pre><pre><code>public class Rose extends Flower{//原本有@Inject，现在去掉了这里的@InJect，因为Dagger2无法定位到这个类的构造函数，//这个注解留着也没有用//不过不去掉也不会出错，依然可以通过编译，//因为Dagger2已经不是从这里生成Rose的工厂方法了    public Rose(){    }    public String whisper(){        return &quot;热恋&quot;;    }}</code></pre><p>在这个场景下，工厂类的生成就和这个类没有什么关系了，那么就要通过另一种方式生成工厂类，就是通过重新创建一个Module类，由他来创建工厂类。</p><pre><code>@Module//@表示这个类是一个创建工厂类的入口，可以说是工厂类的工厂类。public class FlowerModule {    @Provides//标注这个方法作为工厂方法，生成Flower对象。    Flower provideFlower(){        //项目需求变动后，要改Flower接口的实现类的时候，就改这里，比如return new Lily();        return new Rose();    }}</code></pre><p>再为Component接口的注解添加参数</p><pre><code>@Component(modules = FlowerModule.class)public interface MainActivityComponent {    void inject(MainActivity activity);}</code></pre><p>现在build project，多出了这个类</p><pre><code>public final class FlowerModule_ProvideFlowerFactory implements Factory&lt;Flower&gt; {    private final FlowerModule module;//持有一个Module引用，通过他来实例化泛型&lt;Flower&gt;    public FlowerModule_ProvideFlowerFactory(FlowerModule module) {        assert module != null;        this.module = module;    }    //调用module.provideXXX()来返回实例    @Override    public Flower get() {        return Preconditions.checkNotNull(                module.provideFlower(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);    }    //创建自己    public static Factory&lt;Flower&gt; create(FlowerModule module) {        return new FlowerModule_ProvideFlowerFactory(module);    }}</code></pre><p>而DaggerMainActivityComponent的变化如下：</p><pre><code>public final class DaggerMainActivityComponent implements MainActivityComponent {    private Provider&lt;Flower&gt; provideFlowerProvider;//新加入的创建Flower的工厂类    private Provider&lt;Pot&gt; potProvider;    private MembersInjector&lt;MainActivity&gt; mainActivityMembersInjector;    private DaggerMainActivityComponent(com.test.traindagger.DaggerMainActivityComponent.Builder builder) {        assert builder != null;        initialize(builder);    }    public static com.test.traindagger.DaggerMainActivityComponent.Builder builder() {        return new com.test.traindagger.DaggerMainActivityComponent.Builder();    }    public static MainActivityComponent create() {        return builder().build();    }    @SuppressWarnings(&quot;unchecked&quot;)    private void initialize(final com.test.traindagger.DaggerMainActivityComponent.Builder builder) {        //通过FlowerModule作为参数创建工厂类        this.provideFlowerProvider = FlowerModule_ProvideFlowerFactory.create(builder.flowerModule);        this.potProvider = Pot_Factory.create(provideFlowerProvider);        this.mainActivityMembersInjector = MainActivity_MembersInjector.create(potProvider);    }    @Override    public void inject(MainActivity activity) {        mainActivityMembersInjector.injectMembers(activity);    }    public static final class Builder {        private FlowerModule flowerModule;        private Builder() {}        public MainActivityComponent build() {            if (flowerModule == null) {                this.flowerModule = new FlowerModule();//实例化Module类，就是工厂类的工厂类            }            return new com.test.traindagger.DaggerMainActivityComponent(this);        }        public com.test.traindagger.DaggerMainActivityComponent.Builder flowerModule(FlowerModule flowerModule) {            this.flowerModule = Preconditions.checkNotNull(flowerModule);            return this;        }    }}</code></pre><p>build project之后的使用：</p><pre><code>//此时pot还指向null    DaggerMainActivityComponent.builder()            .flowerModule(new FlowerModule())//将这个方法暴露给调用者的意义：让调用者可以更改传入哪个Module来生成工厂类。            .build()            .inject(this);//此时pot已经指向对象</code></pre><p>es.jianshu.io/upload_images/7177220-e251c2c7ab62b9d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)</p><p>现在分析Dagger2生成的四个类<br><code>DaggerMainActivityComponent</code><br><code>MainActivity_MembersInjector</code><br><code>Pot_Factory</code><br><code>Rose_Factory</code></p><h3 id="Pot-Factory和Rose-Factory-1"><a href="#Pot-Factory和Rose-Factory-1" class="headerlink" title="Pot_Factory和Rose_Factory"></a>Pot_Factory和Rose_Factory</h3><p><code>XXX_Factory implements Fatory&lt;XXX&gt;</code><br><code>Factory&lt;XXX&gt; implements Provider&lt;XXX&gt;</code><br>也就是工厂类的最终抽象是<code>Provider</code><br><img src="https://upload-images.jianshu.io/upload_images/7177220-8e357281c58cbefb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><pre><code>public enum Rose_Factory implements Factory&lt;Rose&gt; {  INSTANCE;  @Override  public Rose get() {//get()方法返回泛型&lt;Rose&gt;实例，用来生成对象    return new Rose();  }  public static Factory&lt;Rose&gt; create() {//create()方法用来生成工厂对象    return INSTANCE;  }}</code></pre><pre><code>public final class Pot_Factory implements Factory&lt;Pot&gt; {//因为Pot类的构造方法有参数，参数对象要提前Pot对象实例化，因此持有一个参数对象的类的工厂类，//用来创建参数对象。  private final Provider&lt;Rose&gt; roseProvider;  public Pot_Factory(Provider&lt;Rose&gt; roseProvider) {    assert roseProvider != null;    this.roseProvider = roseProvider;  }  @Override  public Pot get() {//get()方法返回泛型&lt;Pot&gt;实例，用来生成对象    return new Pot(roseProvider.get());  }  //create()方法用来生成工厂对象  public static Factory&lt;Pot&gt; create(Provider&lt;Rose&gt; roseProvider) {    return new Pot_Factory(roseProvider);  }}</code></pre><h3 id="MainActivity-MembersInjector-1"><a href="#MainActivity-MembersInjector-1" class="headerlink" title="MainActivity_MembersInjector"></a>MainActivity_MembersInjector</h3><p>由MainActivity的引用上的@Inject注解生成</p><pre><code>@Injectpublic Pot pot;</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/7177220-c2ec45a6d0d2fe3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>代码如下</p><pre><code>public final class MainActivity_MembersInjector implements MembersInjector&lt;MainActivity&gt; {//持有Pot的工厂类，用来生成Pot对象  private final Provider&lt;Pot&gt; potProvider;  public MainActivity_MembersInjector(Provider&lt;Pot&gt; potProvider) {    assert potProvider != null;    this.potProvider = potProvider;  }//静态方法供外部调用，用来创建这个注入器  public static MembersInjector&lt;MainActivity&gt; create(Provider&lt;Pot&gt; potProvider) {    return new MainActivity_MembersInjector(potProvider);  }//依赖注入的直接入口，将传入的MainActivity对象的引用变量，用工厂类生成其实例,//实现依赖注入。  @Override  public void injectMembers(MainActivity instance) {    if (instance == null) {      throw new NullPointerException(&quot;Cannot inject members into a null reference&quot;);    }    instance.pot = potProvider.get();//用工厂类对象创建对象。  }}</code></pre><h3 id="DaggerMainActivityComponent-1"><a href="#DaggerMainActivityComponent-1" class="headerlink" title="DaggerMainActivityComponent"></a>DaggerMainActivityComponent</h3><p><img src="https://upload-images.jianshu.io/upload_images/7177220-c8e1b0825b152a96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><pre><code>/** * 持有工厂类和注入器类的引用。 * 注入器的实例化需要工厂类对象作为参数。 * 因此Component类连接工厂类和注入器类，最后通过注入器类来完成工作。 *  *  * inject方法直接调用注入器的injectMembers(),注入器中的方法才是注入的直接入口 *  */public class DaggerMainActivityComponent {    public final class DaggerMainActivityComponent implements MainActivityComponent {        private Provider&lt;Pot&gt; potProvider;//工厂类        private MembersInjector&lt;MainActivity&gt; mainActivityMembersInjector;//注入器        private DaggerMainActivityComponent(com.test.traindagger.DaggerMainActivityComponent.Builder builder) {            assert builder != null;            initialize(builder);        }        public static com.test.traindagger.DaggerMainActivityComponent.Builder builder() {            return new com.test.traindagger.DaggerMainActivityComponent.Builder();        }        public static MainActivityComponent create() {            return builder().build();        }        @SuppressWarnings(&quot;unchecked&quot;)        private void initialize(final com.test.traindagger.DaggerMainActivityComponent.Builder builder) {            //实例化工厂类            this.potProvider = Pot_Factory.create(Rose_Factory.create());            //依赖工厂类来实例化注入器            this.mainActivityMembersInjector = MainActivity_MembersInjector.create(potProvider);        }        //就是我们在使用的时候用的inject方法        //调用注入器的injectMembers（上下文）来实现注入        @Override        public void inject(MainActivity activity) {            mainActivityMembersInjector.injectMembers(activity);        }        public static final class Builder {            private Builder() {}            public MainActivityComponent build() {                return new com.test.traindagger.DaggerMainActivityComponent(this);            }        }    }}</code></pre><h1 id="加入-Module和-Provide-1"><a href="#加入-Module和-Provide-1" class="headerlink" title="加入@Module和@Provide"></a>加入@Module和@Provide</h1><p>使用场景:</p><ol><li>无法为第三方库中的类中的构造方法去加上<code>@Inject</code>，也就无法通过这种方式让Dagger2为其生成工厂类</li><li>当使用了依赖倒置，构造器上的参数就是抽象的（接口或抽象类），Dagger2无法通过构造函数上的<code>@Inject</code>将其参数中的接口实例化，因为他并不知道实现类是谁。</li></ol><p>比如<strong>场景1</strong>：将上面的<code>Rose</code>类，抽象出来一个<code>Flower</code>类，并将<code>Pot</code>类中的所有<code>Rose</code>引用替换为<code>Flower</code>引用，因此<code>Rose</code>在这里实现了依赖倒置，那么Dagger2无法通过<code>Rose</code>类的构造方法为<code>Rose</code>类生成工厂类，而<code>Pot</code>类没有使用依赖倒置，因此<code>Pot</code>类的构造方法依然可以使用<code>@Inject</code>来让Dagger2为<code>Pot</code>生成工厂类。</p><pre><code>public class Pot {    private Flower flower;//将Rose引用替换为了Flower，依赖倒置    @Inject    public Pot(Flower flower){        this.flower=flower;    }    public String show(){        return flower.whisper();    }}</code></pre><pre><code>public class Rose extends Flower{//原本有@Inject，现在去掉了这里的@InJect，因为Dagger2无法定位到这个类的构造函数，//这个注解留着也没有用//不过不去掉也不会出错，依然可以通过编译，//因为Dagger2已经不是从这里生成Rose的工厂方法了    public Rose(){    }    public String whisper(){        return &quot;热恋&quot;;    }}</code></pre><p>在这个场景下，工厂类的生成就和这个类没有什么关系了，那么就要通过另一种方式生成工厂类，就是通过重新创建一个Module类，由他来创建工厂类。</p><pre><code>@Module//@表示这个类是一个创建工厂类的入口，可以说是工厂类的工厂类。public class FlowerModule {    @Provides//标注这个方法作为工厂方法，生成Flower对象。    Flower provideFlower(){        //项目需求变动后，要改Flower接口的实现类的时候，就改这里，比如return new Lily();        return new Rose();    }}</code></pre><p>再为Component接口的注解添加参数</p><pre><code>@Component(modules = FlowerModule.class)public interface MainActivityComponent {    void inject(MainActivity activity);}</code></pre><p>现在build project，多出了这个类</p><p>```<br>public final class FlowerModule_ProvideFlowerFactory implements Factory<Flower> {<br>    private final FlowerModule module;//持有一个Module引用，通过他来实例化泛型<Flower></p><pre><code>public FlowerModule_ProvideFlowerFactory(FlowerModule module) {    assert module != null;    this.module = module;}//调用module.provideXXX()来返回实例@Overridepublic Flower get() {    return Preconditions.checkNotNull(            module.provideFlower(), &quot;Cannot return null from a non-@Nullable @Provides method&quot;);}//创建自己public static Factory&lt;Flower&gt; create(F</code></pre>]]></content>
    
    
    <categories>
      
      <category>第三方库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>git-clone做了什么</title>
    <link href="/2018/06/29/git/git-clone%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <url>/2018/06/29/git/git-clone%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>git官方教程：<a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF" target="_blank" rel="noopener">3.5 Git 分支 - 远程分支</a></p></blockquote><p>打开一个directory，输入</p><pre><code>git initgit clone &lt;远程地址&gt;</code></pre><p>发生了如下图所示的事情<br><img src="https://upload-images.jianshu.io/upload_images/7177220-27803b3fdee9a2eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="来自官方文档"><br>上方是服务器的仓库，<code>master</code>指向<code>f4265</code>，当克隆仓库之后，整个仓库的所有文件，包括<code>.git</code>文件，全部下载到本地的diretory。</p><p>git的<code>clone</code>命令将远程仓库在本地命名为origin，创建一个指向它的 master 分支的指针，并且在本地将其命名为 origin/master（<code>如第二个图的origin/master指针</code>），同时创建一个master指针，并将<code>HEAD</code>指针指向这个master指针（<code>如第二个图的master指针</code>），这样就有工作的基础，并且工作目录变成master指针指向的快照。</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-a23047d9b10ad933.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="自己做的带HEAD的图"><br></p>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Please-configure--Android-SDK</title>
    <link href="/2018/06/26/Android-Studio%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/Please-configure--Android-SDK/"/>
    <url>/2018/06/26/Android-Studio%E9%94%99%E8%AF%AF%E8%AE%B0%E5%BD%95/Please-configure--Android-SDK/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7177220-32a3bd76b1e77473.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><hr><p>解决方法：</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-8f91fcc8d3cf7781.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></p>]]></content>
    
    
    <categories>
      
      <category>Android-Studio错误记录</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>简易线程池</title>
    <link href="/2018/06/20/java%E5%B9%B6%E5%8F%91/%E7%AE%80%E6%98%93%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2018/06/20/java%E5%B9%B6%E5%8F%91/%E7%AE%80%E6%98%93%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p>来自《Java并发编程的艺术》</p><p>一个简易的线程池的实现。三个类：<br><code>ThreadPool</code>线程池接口<br><code>DefaultThreadPool</code>线程池接口实现<br><code>Worker</code>工作线程</p><p><strong>线程池的工作逻辑：</strong><br><img src="https://upload-images.jianshu.io/upload_images/7177220-d55d05bfd844144c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>全部代码</p><pre><code>package ConcurrencyArt;import java.util.ArrayList;import java.util.Collections;import java.util.LinkedList;import java.util.List;import java.util.concurrent.atomic.AtomicLong;interface ThreadPool&lt;Job extends Runnable&gt; {    void execute(Job job);//执行一个Job,这个Job需要实现Runnable    void shutdown();//关闭线程池    void addWorkers(int m);//增加工作者线程    void removeWorkers(int m);//减少工作者线程    int getJobSize();//得到正在等待执行的任务数量}public class DefaultThreadPool&lt;Job extends Runnable&gt; implements ThreadPool&lt;Job&gt; {    private static final int MAX_WORKER_NUMBERS = 10;//线程池最大限制数    private static final int DEFAULT_WORKER_NUMBERS = 5;//线程池默认的数量    private static final int MIN_WORKER_NUMBERS = 1;//线程池最小的数量    private final LinkedList&lt;Job&gt; jobs = new LinkedList&lt;&gt;();//工作列表    private final List&lt;Worker&gt; workers = Collections.synchronizedList(new ArrayList&lt;&gt;());//工作者列表    private int workerNum = DEFAULT_WORKER_NUMBERS;//工作者线程的数量    private AtomicLong threadNum = new AtomicLong();//线程编号生成    public DefaultThreadPool() {        initializeWorkers(DEFAULT_WORKER_NUMBERS);    }    public DefaultThreadPool(int num) {        workerNum = num &gt; MAX_WORKER_NUMBERS ? MAX_WORKER_NUMBERS : num &lt; MIN_WORKER_NUMBERS ? MIN_WORKER_NUMBERS : num;        initializeWorkers(workerNum);    }    //初始化线程工作者    private void initializeWorkers(int num) {        for (int i = 0; i &lt; num; i++) {            Worker worker = new Worker();            workers.add(worker);            Thread thread = new Thread(worker, &quot;ThreadPool-Worker-&quot; + threadNum.incrementAndGet());            thread.start();        }    }    @Override    public void execute(Job job) {        if (job != null) {            synchronized (jobs) {                jobs.addLast(job);                jobs.notify();//在worker的run方法中的while循环中，调用了jobs.wait();            }        }    }    @Override    public void shutdown() {        for (Worker worker : workers) {            worker.shutdown();        }    }    @Override    public void addWorkers(int m) {        synchronized (jobs) {            if (m + this.workerNum &gt; MAX_WORKER_NUMBERS) {                m = MAX_WORKER_NUMBERS - this.workerNum;            }            initializeWorkers(m);            this.workerNum += m;        }    }    @Override    public void removeWorkers(int m) {        synchronized (jobs) {            if (m &gt;= this.workerNum) {                throw new IllegalArgumentException(&quot;beyond workNum&quot;);            }            int count = 0;            while (count &lt; m) {                Worker worker = workers.get(count);                if (workers.remove(worker)) {                    worker.shutdown();                    count++;                }            }            this.workerNum -= count;        }    }    @Override    public int getJobSize() {        return jobs.size();    }    //工作者，负责消费任务。    class Worker implements Runnable {        private volatile boolean running = true;//在这里通过volatile boolean而不是interrupt方法来安全地中断线程        @Override        public void run() {            while (running) {                Job job = null;                synchronized (jobs) {                    while (jobs.isEmpty()) {//当工作队列为空时，所有的工作者线程均等待在工作队列上。                        try {                            jobs.wait();                        } catch (InterruptedException e) {                            Thread.currentThread().interrupt();                            return;//感知到外部对工作者线程的中断操作，返回。                        }                    }                    job = jobs.removeFirst();                }                if (job != null) {                    try {                        //job，作为一个Runnable的实现类，在这里并未将其变成线程并start()，                        // 而是将其的run方法放在工作者线程中执行，这样真正的多线程是指工作者线程，                        //而提交进来的Job只是作为一个应该异步执行的任务。                        job.run();                    } catch (Exception ex) {                        //忽略job执行中的exception                    }                }            }        }        public void shutdown() {            running = false;        }    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Future相关类解释</title>
    <link href="/2018/06/19/java%E5%B9%B6%E5%8F%91/Future%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E9%87%8A/"/>
    <url>/2018/06/19/java%E5%B9%B6%E5%8F%91/Future%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h2 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h2><p>一个Future代表一个异步计算的结果。他提供了5个方法来确认计算是否完成，来等待异步任务的完成，来获取异步计算的结果。当计算完成，计算结果有且只能有通过<code>get()</code>方法来获取，并且会阻塞调用者线程直到异步计算的任务完成。取消只能通过<code>cancel()</code>方法。他提供了额外的方法来决定任务正常完成还是被取消。一旦一个计算任务完成，他将不再能够被取消。如果你要用Future是为了能够取消异步任务而不要他的返回结果，那么可以使用Future&lt;?&gt;并返回null作为异步任务的执行结果。</p><h2 id="RunnableFuture接口"><a href="#RunnableFuture接口" class="headerlink" title="RunnableFuture接口"></a>RunnableFuture接口</h2><p>表示一个可以run的Future, <code>run</code>方法的成功执行标识着Future的完成并运行他的调用者通过<code>get()</code>来获取他的执行结果。</p><pre><code>//除非run方法被取消，否则设置这个Future作为这个计算运行的结果。void run();</code></pre><h2 id="FutureTask-implements-RunnableFuture"><a href="#FutureTask-implements-RunnableFuture" class="headerlink" title="FutureTask implements RunnableFuture"></a>FutureTask<V> implements RunnableFuture<V></h2><p></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java线程池相关类解释，整理自Java文档</title>
    <link href="/2018/06/19/java%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E9%87%8A%EF%BC%8C%E6%95%B4%E7%90%86%E8%87%AAJava%E6%96%87%E6%A1%A3/"/>
    <url>/2018/06/19/java%E5%B9%B6%E5%8F%91/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9B%B8%E5%85%B3%E7%B1%BB%E8%A7%A3%E9%87%8A%EF%BC%8C%E6%95%B4%E7%90%86%E8%87%AAJava%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="接口Executor"><a href="#接口Executor" class="headerlink" title="接口Executor:"></a>接口Executor:</h2><p>一个可以执行被提交的Runnable的对象。该接口提供了一种任务提交的解耦方案，体现在每个task如何运行，使用，调度等。<br>Executor接口并不严格要求task的执行过程是异步的，在最简单的情况下，一个Executor可以直接将task放在调用者的线程中执行：</p><pre><code>class DirectExecutor implements Executor{  public void execute(Runnable r){    r.run();  }}</code></pre><p>但更常见的情况一般是：task会被放置在其他线程而非调用者线程执行。<br>许多Executor接口的实现会给task如何以及何时被调用加上限制。</p><pre><code>void execute(Runnable command);</code></pre><p>Runnable可在新线程，线程池，或者调用者线程执行。</p><h2 id="接口ExecutorService（Executor的拓展）"><a href="#接口ExecutorService（Executor的拓展）" class="headerlink" title="接口ExecutorService（Executor的拓展）"></a>接口ExecutorService（Executor的拓展）</h2><p>是一个提供了<code>termination</code>和返回Future来追踪一个或多个异步tasks的对象。</p><p><code>termination</code>：指executor没有正在执行的task，没有等待执行的task，且没有新的task可以被接收。</p><p><code>shutdown();</code>新的task不再被接收，已提交的task会执行完毕，重复调用该方法没有其他效果。该方法不会阻塞调用者线程来等待task去执行完毕，若要阻塞当前线程，该调用<code>awaitTermination();</code></p><p><code>shutdownNow();</code>尝试停止所有正在执行的task，停止正在等待的task，返回等待执行的task的List<Runnable>。但并不保证能成功停止正在执行的线程，因为该方法的实现一般就是用<code>Thread#interrupt()</code>，那么就要求线程本身就能正确根据<code>interrupt()</code>方法来停止自身。</p><p><code>isShutdown()</code>返回true如果调用过<code>shutdown()</code>或者<code>shutdownNow()</code>。</p><p><code>isTerminated();</code>如果全部task都在调用shutdown()后完成了，将返回true，若调用<code>isTerminated()</code>之前没有调用过<code>shutdown()</code>或<code>shutdownNow()</code>，该方法永远返回false。</p><p><code>awaitTermination(long timeout,Timeunit unit</code>) throws InterruptedExeption;  阻塞调用者的线程，直到所有task在shutdown后完成，或者timeout超时，或者当前线程被interrupted。</p><p><code>Future&lt;T&gt;  submit(Callable&lt;T&gt;)</code>提交一个有返回值的任务（Callble）并返回一个Future对象。可通过Future#get()来返回任务处理完成的结果。若要为获取一个任务的执行结果而阻塞当前调用者线程，可以</p><pre><code>result=exec.submit(aCallable).get();</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android消息机制流程图，Handler,Looper,MessageQueue</title>
    <link href="/2018/06/13/Android/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%8CHandler,Looper,MessageQueue/"/>
    <url>/2018/06/13/Android/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%8CHandler,Looper,MessageQueue/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7177220-9572257fb5606ac8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Volley具体流程图（配代码）</title>
    <link href="/2018/06/11/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/Volley%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%88%E9%85%8D%E4%BB%A3%E7%A0%81%EF%BC%89/"/>
    <url>/2018/06/11/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/Volley%E5%85%B7%E4%BD%93%E6%B5%81%E7%A8%8B%E5%9B%BE%EF%BC%88%E9%85%8D%E4%BB%A3%E7%A0%81%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>只简要分析Volley大体原理，无细节，无Volley使用教程。</p><hr><p>使用Volley时必要的两步：</p><pre><code>RequestQueue queue= Volley.newRequestQueue(context);1queue.add(request);  //request可以是StringRequest,ImageRequest,JsonRequestd等。</code></pre><p>第一步通过<code>Volley.newRequestQueue(Context)</code>初始化<code>queue</code>，第二步往<code>queue</code>中添加具体请求。</p><h2 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h2><p><img src="https://upload-images.jianshu.io/upload_images/7177220-5ff1cb794f8a63b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><h2 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h2><p><img src="https://upload-images.jianshu.io/upload_images/7177220-dadd1d6aa55ad823.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><pre><code>本地磁盘缓存==&gt;Cache接口的实现类：DiskBasedCache  Cache接口中定义了内部类Entry封装了响应体的数据DiskBasedCache定义了对磁盘读写的操作，规定了默认的缓存大小为5M，缓存路径为getCacheDir()/Volley</code></pre><p>突然发现把程序的逻辑走向用笔和纸写出来思路会非常清晰，原稿如下<br><img src="https://upload-images.jianshu.io/upload_images/7177220-1c9d206fac5a23d8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" srcset="/img/loading.gif" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/7177220-de7d92a7ba79c65d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" srcset="/img/loading.gif" alt=""></p><p>官网图：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-3085aaa6e7800839.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></p>]]></content>
    
    
    <categories>
      
      <category>第三方库</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>View简要工作原理</title>
    <link href="/2018/06/10/View/View%E7%AE%80%E8%A6%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <url>/2018/06/10/View/View%E7%AE%80%E8%A6%81%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><code>ViewRootImpl</code>对象=&gt;<code>performTraversals()</code></p><pre><code>private void performTraversals() {//上下近800行代码。  performMeasure();  performLayout();  performDraw();}</code></pre><pre><code>private void performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec) {//mView是DecorView对象  mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);     }</code></pre><p>layout和draw同理，下面是measure,layout,draw的机制==&gt;<br><img src="https://upload-images.jianshu.io/upload_images/7177220-c9545e3b3f8d3a26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="measure"><br><img src="https://upload-images.jianshu.io/upload_images/7177220-ef5ccca356973742.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="layout"><br><img src="https://upload-images.jianshu.io/upload_images/7177220-6d62245c67804605.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="draw"><br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>红黑树</title>
    <link href="/2018/06/04/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <url>/2018/06/04/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>没有删除功能。来自多方网络资料。</p><p>主要参考：<br><a href="https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/%E7%BA%A2%E9%BB%91%E6%A0%91</a><br>如果天空不死：<a href="http://www.cnblogs.com/skywang12345/p/3624343.html#top" target="_blank" rel="noopener">http://www.cnblogs.com/skywang12345/p/3624343.html#top</a></p><pre><code>package DataStructureAndAlgor;public class RBTree&lt;T extends Comparable&lt;T&gt;&gt; {    private class Node {        boolean color;        T key;        Node left;        Node right;        Node parent;        Node(boolean color, T key, Node left, Node right, Node parent) {            this.color = color;            this.key = key;            this.left = left;            this.right = right;            this.parent = parent;        }    }    private Node root;    private static final boolean RED = false;    private static final boolean BLACK = true;    /*     * 对红黑树的节点(x)进行左旋转     *     * 左旋示意图(对节点x进行左旋)：     *      px                              px     *     /                               /     *    x                               y     *   /  \      --(左旋)-&gt;            / \                #     *  lx   y                         x    ry     *     /   \                     /  \     *    ly   ry                   lx   ly     *     *     */    private void leftRotate(Node x) {        //取x的右结点为y        Node y = x.right;        //将y的左子树完全分离为x的右子树        x.right = y.left;        if (y.left != null) {            y.left.parent = x;        }        y.parent = x.parent;//y指向新的父结点        //新的父结点指向y(以下)        if (x.parent == null) {//如果x的父结点为null，说明x是根节点            this.root = y;        } else {//如果x不是根节点            if (x.parent.left == x) {//如果x是左子树                x.parent.left = y;            } else {//如果x是右子树                x.parent.right = y;            }        }        y.left = x;        x.parent = y;        //TODO:我觉得可以试试返回当前根节点的方法，可能更简洁。    }    /*     * 对红黑树的节点(y)进行右旋转     *     * 右旋示意图(对节点y进行左旋)：     *            py                               py     *           /                                /     *          y                                x     *         /  \      --(右旋)-&gt;            /  \                     #     *        x   ry                         lx     y     *       / \                                   / \                   #     *      lx  rx                                rx  ry     *     */    private void rightRotate(Node y) {        Node x = y.left;        y.left = x.right;        if (x.right != null) {            x.right.parent = y;        }        x.parent = y.parent;        if (y.parent == null) {//y是根节点            this.root = x;        } else {//y不是根节点            if (y.parent.left == y) {//y在左                y.parent.left = x;            } else {//y在右                y.parent.right = x;            }        }        x.right = y;        y.parent = x;    }    public void insert(T key) {        root = insertNode(root, key, null);        Node node = search(root, key);        insert_case1(node);    }    private Node search(Node node, T key) {        if (node == null) {            return null;        }        int cmp = key.compareTo(node.key);        if (cmp &lt; 0) {            return search(node.left, key);        } else if (cmp &gt; 0) {            return search(node.right, key);        } else {            return node;        }    }    /**     * @param node   插入的根起点     * @param key    插入的值     * @param parent node的父结点     * @return     */    private Node insertNode(Node node, T key, Node parent) {        if (node == null) {            return new Node(RED, key, null, null, parent);//结点颜色初始化为RED        } else {            int cmp = key.compareTo(node.key);            if (cmp &lt; 0) {                node.left = insertNode(node.left, key, node);            } else if (cmp &gt; 0) {                node.right = insertNode(node.right, key, node);            } //else{key equals node.key,二叉树不允许存在相同的值的结点。}        }        return node;    }    private Node grandparent(Node node) {        return node.parent.parent;    }    private Node uncle(Node node) {        if (node.parent == grandparent(node).left) {            return grandparent(node).right;        } else {            return grandparent(node).left;        }    }    //当前节点为父结点：直接把结点涂成黑色。    private void insert_case1(Node n) {        if (n.parent == null) {            n.color = BLACK;        } else {            insert_case2(n);        }    }    //当前节点的父结点为黑色：啥也不用做。    private void insert_case2(Node n) {        if (n.parent.color == BLACK) {            return;        } else {            insert_case3(n);        }    }    //当前结点的父结点是红色,且叔叔结点是红色。    private void insert_case3(Node n) {        if (uncle(n) != null &amp;&amp; uncle(n).color == RED) {            n.parent.color = BLACK;            uncle(n).color = BLACK;            grandparent(n).color = RED;            insert_case1(grandparent(n));        } else {            insert_case4(n);        }    }    //此时当前结点，父结点，祖父结点，三者呈之字形，将其调整为一字型。    private void insert_case4(Node n) {        if (n == n.parent.right &amp;&amp; n.parent == grandparent(n).left) {            leftRotate(n.parent);            n = n.left;        } else if (n == n.parent.left &amp;&amp; n.parent == grandparent(n).right) {            rightRotate(n.parent);            n = n.right;        }        insert_case5(n);    }    //此时当前结点，父结点，祖父结点，三者呈一字型。    private void insert_case5(Node n) {        n.parent.color = BLACK;        grandparent(n).color = RED;        if (n == n.parent.left &amp;&amp; n.parent == grandparent(n).left) {            rightRotate(grandparent(n));        }else {            leftRotate(grandparent(n));        }    }    private void print(Node node,int depth){        if (node!=null){            for (int i=0;i&lt;depth;i++){                System.out.print(&quot;--&quot;);            }            System.out.print(node.key);            System.out.println();//换行            depth++;            print(node.left,depth);            print(node.right,depth);        }    }    public void print(){        print(root,0);    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单链表反转</title>
    <link href="/2018/06/03/%E7%AE%97%E6%B3%95/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/"/>
    <url>/2018/06/03/%E7%AE%97%E6%B3%95/%E5%8D%95%E9%93%BE%E8%A1%A8%E5%8F%8D%E8%BD%AC/</url>
    
    <content type="html"><![CDATA[<pre><code>public class SingleLinkedList {    private class Node {        private Node next;        private int value;        Node(Node next, int value) {            this.next = next;            this.value = value;        }    }    private Node head;    private Node last;    private int size;    public SingleLinkedList() {        Node firstNode = new Node(null, 0);        head = firstNode;        last = firstNode;        size = 0;    }    public void add(int value) {        Node node = new Node(null, value);        last.next = node;        last = node;        size++;    }    public void clear() {        size = 0;        last = head;    }    //将链表倒进数组，再从数组逆序拿出，耗费更多内存。    public void reverse() {        int oldSize = size;        Node cursor = head.next;        Node[] nodes = new Node[oldSize];        for (int i = 0; i &lt; oldSize; i++) {//save all value to the nodes            nodes[i] = cursor;            cursor = cursor.next;        }        clear();//clear the linkedList        for (int i = oldSize - 1; i &gt;= 0; i--) {            add(nodes[i].value);        }    }    private void print(Node node) {        if (node != null) {            System.out.print(node.value + &quot; &quot;);            print(node.next);        }    }    public void print() {        print(head.next);    }    //在原址上操作，通过递归从尾结点开始，将结点指针反转。    private Node reverseHead(Node node) {        if (node == null || node.next == null) {            return node;        }        Node newHead = reverseHead(node.next);        node.next.next = node;        node.next = null;        return newHead;    }    public void reverseHead() {        last = head.next;        head.next = reverseHead(head.next);    }}</code></pre><p>reverseHead方法的图解：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-b89fb3892d97dd67.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>剩下的画图跟着代码走一遍。<br></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉堆</title>
    <link href="/2018/06/02/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E5%A0%86/"/>
    <url>/2018/06/02/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E5%A0%86/</url>
    
    <content type="html"><![CDATA[<p>《数据结构与算法：java语言描述》源码</p><pre><code>package DataStructureAndAlgor;import java.nio.BufferUnderflowException;/** * 由数组实现的堆，小根堆。 * &lt;p&gt; * 堆的定义： * 1. 堆中某个节点的值总是不大于或不小于其父节点的值（将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆） * 2. 堆总是一棵完全二叉树 * &lt;p&gt; * 当堆用数组实现： * 1. 位置0不放元素，从位置1开始放。 * 2. 数组任一位置i上的元素，左子树在位置2i，右子树在位置(2i+1)，父结点在[i/2]上。 * * @param &lt;T&gt; *//*    回顾的时候要画出这个模型，图上的数字代表数组下标，0下标为null。                1             /      \            2         3                    /  \       / \         4     5    6    7        / \    / \       8  9   10 11        */public class BinaryHeap&lt;T extends Comparable&lt;T&gt;&gt; {    private static final int DEFAULT_CAPACITY = 10;    private int currentSize;    private T[] array;    public BinaryHeap() {        this(DEFAULT_CAPACITY);    }    public BinaryHeap(int capacity) {        currentSize = 0;        array = (T[]) new Comparable[capacity + 1];    }    public BinaryHeap(T[] items) {        currentSize = items.length;        array = (T[]) new Comparable[(currentSize + 2) * 11 / 10];        int i = 1;        for (T item : items) {            array[i++] = item;        }        buildHeap();    }    public void insert(T x) {        //通过上滤（percolate up），将新元素在堆中上滤直到找出正确位置。时间复杂度：O(logN)        if (currentSize == array.length - 1) {            enlargeArray(array.length * 2 + 1);        }        int hole = ++currentSize;        for (; hole &gt; 1 &amp;&amp; x.compareTo(array[hole / 2]) &lt; 0; hole /= 2) {/*(hole/2)表示父结点的位置*/            array[hole] = array[hole / 2];        }        array[hole] = x;    }    public T findMin() {        if (isEmpty()) {            throw new BufferUnderflowException();        }        return array[1];//array[0]是不放元素的，array[1]才是root    }    public T deleteMin() {        if (isEmpty()) {            throw new BufferUnderflowException();        }        T minItem = findMin();        array[1] = array[currentSize--];//直接将最后一个元素覆盖第一个元素        //TODO :是否需要array[currentSize+1]=null;？        percolateDown(1);//覆盖之后，开始“下滤”        return minItem;    }    private boolean isEmpty() {        return currentSize == 0;    }    public void makeEmpty() {        currentSize = 0;    }    private void percolateDown(int hole) {//   O(logN)        int child;        T tmp = array[hole];//要&quot;下滤&quot;的元素。        for (; hole * 2 &lt;= currentSize; hole = child) {//hole*2&lt;=currentSize是保证左子树下标不越界;            child = hole * 2;                      //hole=child是下滤的直接操作。            if (child != currentSize &amp;&amp; array[child + 1].compareTo(array[child]) &lt; 0) {//TODO：可以测试一下第一个判断条件的必要性                child++;//如果右子树&lt;左子树，下标换到右子树去。            }            if (array[child].compareTo(tmp) &lt; 0) {//如果孩子结点小于父结点                array[hole] = array[child];//将孩子结点&quot;上移&quot;，hole&quot;下滤&quot;。            } else {                break;            }        }        array[hole] = tmp;    }    private void buildHeap() {        for (int i = currentSize / 2; i &gt; 0; i--) {//除以二是因为后面的都是完全二叉树叶子结点，不需要下滤。            percolateDown(i);        }    }    private void enlargeArray(int newSize) {        T[] old = array;        array = (T[]) new Comparable[newSize];        for (int i = 0; i &lt; old.length; i++) {            array[i] = old[i];        }    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程中断interrupt</title>
    <link href="/2018/05/31/java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%ADinterrupt/"/>
    <url>/2018/05/31/java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%ADinterrupt/</url>
    
    <content type="html"><![CDATA[<hr><blockquote><p>以下内容完全来自于《java核心技术卷Ⅰ 》</p></blockquote><p>当线程的run方法执行方法体中最后一条语句后,并经由执行return语句返回时,或者出现了在方法中没有捕获的异常时,线程将终止。在Java的早期版本中,还有一个stop方法,其他线程可以调用它终止线程。但是,这个方法现在已经被弃用了。</p><p>有一种可以强制线程终止的方法。然而, interrupt方法可以用来请求终止线程。</p><p>当对一个线程调用interrupt方法时线程的中断状态将被置位。这是每一个线程都具有的boolean标志。每个线程都应该不时地检查这个标志,以判断线程是否被中断。</p><p>要想弄清中断状态是否被置位，首先调用静态的Thread.currentThread方法获得当前线程，然后调用isInterrupted()方法：</p><pre><code>while(!Thread.currentThread().isInterrupted() &amp;&amp; more work to do){  do more work}</code></pre><p>但是，如果线程被阻塞，就无法检测中断状态。这是产生InterruptedException异常的地方。当在一个被阻塞的线程（调用sleep或wait）上调用interrupt方法时，阻塞调用将会被InterruptedException异常终点。</p><p>没有任何语言方面的需求要求一个被中断的线程应该终止。中断一个线程不过是引起它的注意。被中断的线程可以决定如何响应中断。某些线程是如此重要以至于应该处理完异常后,继续执行,而不理会中断。但是,更普遍的情况是,线程将简单地将中断作为一个终止的请求。这种线程的run方法具有如下形式:</p><pre><code>public void run(){  try{    ...      while(!Thread.currentThread().isInterrupted() &amp;&amp; more work to do){          do more work        }  }catch(InterruptedException e){    //thread was interrupted during sleep or wait  }finally{    cleanup , if required  }   //exiting the run method terminates the thread}</code></pre><p>如果在每次工作迭代之后都调用sleep方法(或者其他的可中断方法), isInterrupted检测既没有必要也没有用处。如果在中断状态被置位时调用sleep方法,它不会休眠。相反,它将清除这一状态(!)并抛出InterruptedException。因此,如果你的循环调用sleep,不会检测中断状态。相反,要如下所示捕获InterruptedException异常:</p><pre><code>public void run(){  try{    ...    while(more work to do）{      do more work      Thread.sleep(delay);    }  }catch(InterruptedException e){     //thread was interrupted during sleep  }finally{    cleanup, if required  }  //exiting the run method terminateds the thread}</code></pre><p><strong>注释</strong>:有两个非常类似的方法, interrupted和isInterrupted, interrupted方法是一个静态方法,它检测当前的线程是否被中断。而且,调用interrupted方法会清除该线程的中断 “状态。另一方面, isInterrupted方法是一个实例方法,可用来检验是否有线程被中断。调用这个方法不会改变中断状态。</p><p>在很多发布的代码中会发现InterruptedException异常被抑制在很低的层次上，像这样：</p><pre><code>void mySubTask{  ...  try{sleep(delay)}  catch(InterruptedExcpetion e{}//DON&#39;T IGNORE!  ...}</code></pre><p>不要这样做！如果不认为在catch子句中做这一处理有什么好处的话，仍然有两种合理的选择：</p><ol><li>在catch子句中调用Thread.currentThread().interrupt来设置中断状态。于是，调用者可以对其进行检测。<pre><code>void mySubTask{...try{sleep(delay)}catch(InterruptedExcpetion e{ Thread.currentThread.interrupt();}...}</code></pre></li><li>或者，更好的选择是，用throws InterruptedException将异常抛出，留给调用者。  </li></ol><p>void mySubTask{<br>  …<br>  try{sleep(delay)}<br>  catch(InterruptedExcpetion e{}//DON’T IGNORE!<br>  …<br>}</p><ul><li><code>void interrupt()</code><br>向线程发送中断请求,线程的中断状态将被设置为true,如果目前该线程被一个sleep调用阻塞,那么, InterruptedException异常被抛出。</li><li><code>static boolean interrupted()</code><br>测试当前线程(即正在执行这一命令的线程)是否被中断。注意,这是一个静态方法。”这一调用会产生副作用-它将当前线程的中断状态重置为false。</li><li><code>boolean isInterrupted()</code><br>测试线程是否被终止。不像静态的中断方法,这一调用不改变线程的中断状态。</li><li><code>static Thread currentThread()</code><br>返回代表当前执行线程的Thread对象<br></li></ul>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java不可变对象</title>
    <link href="/2018/05/29/Java/Java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/"/>
    <url>/2018/05/29/Java/Java%E4%B8%8D%E5%8F%AF%E5%8F%98%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<ol><li>定义：<br>如果某个对象在被创建后，其状态（实例变量）不能被修改，那么这个对象就称为不可变对象。</li><li>优点： <ol><li>不可变对象一定是线程安全的（不可变，别的线程修改不了）。</li><li>可作为Map的键值和Set的元素。</li></ol></li><li>编写不可变类：<ol><li>所有字段都是private final。</li><li>没有任何public的方法来修改字段。</li><li>不依赖外部可变对象的引用。（如果依赖外部可变对象，那么当外部可变对象修改时，引用变量会指向新的对象，违反不可变对象的定义）</li><li>不能逸出任何可变对象的引用变量。（逸出引用变量后，外部可以通过引用变量修改对象）。<pre><code>import java.util.Date;</code></pre></li></ol></li></ol><p>public final class ImmutableObject {<br>    private final int age;</p><pre><code>private final String name;//不可变引用，且创建后指向不可变对象private final Date date;//不可变引用，可变对象public ImmutableObject(int age, String name, Date date) {    this.age = age;    this.name = name;    //如果写成this.date=date;就依赖了外部对象。    //因此要重新创建一个Date实例    this.date = new Date(date.getTime());}public int getAge() {    return age;}public String getName() {    return name;}public Date getDate() {    //如果写成return date;就逸出了当前对象的引用，调用者可以    //通过该引用修改Date实例的属性    return new Date(date.getTime());}</code></pre><p>}</p><p>```</p><blockquote><p>thanks <a href="https://my.oschina.net/jackieyeah/blog/205198" target="_blank" rel="noopener">https://my.oschina.net/jackieyeah/blog/205198</a><br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AVL树</title>
    <link href="/2018/05/27/%E7%AE%97%E6%B3%95/AVL%E6%A0%91/"/>
    <url>/2018/05/27/%E7%AE%97%E6%B3%95/AVL%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://www.cnblogs.com/skywang12345/p/3577479.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3577479.html</a></p><h2 id="AVL树本质上还是一棵二叉搜索树，它的特点是："><a href="#AVL树本质上还是一棵二叉搜索树，它的特点是：" class="headerlink" title="AVL树本质上还是一棵二叉搜索树，它的特点是："></a>AVL树本质上还是一棵二叉搜索树，它的特点是：</h2><p>1.本身首先是一棵二叉搜索树。<br>2.带有平衡条件：每个结点的左右子树的高度之差的绝对值（平衡因子）最多为1。<br>也就是说，AVL树，本质上是带了平衡功能的二叉查找树（二叉排序树，二叉搜索树）。</p><p>以下为四种不平衡的临界条件，分别为LL（leftleft）,LR（leftright）,RL,RR。<br><img src="https://upload-images.jianshu.io/upload_images/7177220-83255f2429ce767e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>当每次到达这四种不平衡的临界条件时，都进行<strong>旋转树</strong>操作，那么树就能维持平衡：</p><pre><code>private AVLTreeNode leftLeftRotation(AVLTreeNode node) {        checkNull(node);        AVLTreeNode  leftChild = node.left;        node.left =  leftChild.right;         leftChild.right = node;        //reset the height        node.height = max(height(node.left), height(node.right)) + 1;         leftChild.height = max(height( leftChild.left), height( leftChild.right)) + 1;        return  leftChild;    }    private AVLTreeNode rightRightRotation(AVLTreeNode node) {        checkNull(node);        AVLTreeNode  rightChild = node.right;        node.right =  rightChild.left;         rightChild.left = node;        node.height = max(height(node.left), height(node.right)) + 1;         rightChild.height = max(height( rightChild.left), height( rightChild.right)) + 1;        return  rightChild;    }    private AVLTreeNode leftRightRotation(AVLTreeNode node) {        node.left = rightRightRotation(node.left);//先对node.left旋转        return leftLeftRotation(node);//后对自己旋转    }    private AVLTreeNode rightLeftRotation(AVLTreeNode node) {        node.right = leftLeftRotation(node.right);        return rightRightRotation(node);    }</code></pre><p>结合插入和删除，AVL树的实现：</p><pre><code>package DataStructureAndAlgor;/** * AVL树 * 回顾的时候，最好把LL,RR,LR,RL旋转的四张图画出来，好理解。 * * @param &lt;T&gt; */public class AVLTree&lt;T extends Comparable&lt;T&gt;&gt; {    class AVLTreeNode {        T key;        int height;        AVLTreeNode left;        AVLTreeNode right;        public AVLTreeNode(T key, AVLTreeNode left, AVLTreeNode right) {            this.key = key;            this.left = left;            this.right = right;            this.height = 0;//初始化的结点的height都是0，因为都是作为叶子结点添加到树中的。        }    }    private AVLTreeNode mRoot;    private int height(AVLTreeNode tree) {        if (tree != null) {            return tree.height;        }        return 0;    }    public int height() {        return height(mRoot);    }    public int height(T key) {        AVLTreeNode node = search(mRoot, key);        return height(node);    }    private int max(int a, int b) {        return a &gt; b ? a : b;    }    private AVLTreeNode leftLeftRotation(AVLTreeNode node) {        checkNull(node);        AVLTreeNode  leftChild = node.left;        node.left =  leftChild.right;         leftChild.right = node;        //reset the height        node.height = max(height(node.left), height(node.right)) + 1;         leftChild.height = max(height( leftChild.left), height( leftChild.right)) + 1;        return  leftChild;    }    private AVLTreeNode rightRightRotation(AVLTreeNode node) {        checkNull(node);        AVLTreeNode  rightChild = node.right;        node.right =  rightChild.left;         rightChild.left = node;        node.height = max(height(node.left), height(node.right)) + 1;         rightChild.height = max(height( rightChild.left), height( rightChild.right)) + 1;        return  rightChild;    }    private AVLTreeNode leftRightRotation(AVLTreeNode node) {        node.left = rightRightRotation(node.left);//先对node.left旋转        return leftLeftRotation(node);//后对自己旋转    }    private AVLTreeNode rightLeftRotation(AVLTreeNode node) {        node.right = leftLeftRotation(node.right);        return rightRightRotation(node);    }    private void checkNull(AVLTreeNode node) {        if (node == null) {            throw new NullPointerException();        }    }    /**     * 将结点插入到AVL树种，并返回根节点。     *     * @param tree AVL树的根节点     * @param key  待插入的结点的值。     * @return 根节点     */    private AVLTreeNode insert(AVLTreeNode tree, T key) {        if (tree == null) {//递归终点            tree = new AVLTreeNode(key, null, null);        } else {            int cmp = key.compareTo(tree.key);//compare result            if (cmp &lt; 0) {                tree.left = insert(tree.left, key);//递归插入                //插入结点后，若AVLTree失去平衡，旋转树。                if (height(tree.left) - height(tree.right) == 2) {//说明是tree结点出问题(必须是left-right，否则得负值)                    if (key.compareTo(tree.left.key) &lt; 0) {//这里如果写成tree.right.key会报空指针异常                        tree = leftLeftRotation(tree);                    } else {                        tree = leftRightRotation(tree);                    }                }            } else if (cmp &gt; 0) {                tree.right = insert(tree.right, key);//递归插入                if (height(tree.right) - height(tree.left) == 2) {//说明是tree结点出问题(必须是left-right，否则得负值)                    if (key.compareTo(tree.right.key) &lt; 0) {//这里如果写成tree.left.key会报空指针异常                        tree = rightLeftRotation(tree);                    } else {                        tree = rightRightRotation(tree);                    }                }            } else {  //cmp==0;                System.out.println(&quot;添加失败！不允许添加相同的结点！&quot;);            }        }        tree.height = max(height(tree.left), height(tree.right)) + 1;        return tree;    }    public void insert(T key) {        mRoot = insert(mRoot, key);    }    /**     * 删除树中的结点z, 返回根节点     *     * @param tree 从tree结点开始找寻要删除的结点z     * @param z    待删除的根节点     * @return 根节点     */    private AVLTreeNode remove(AVLTreeNode tree, AVLTreeNode z) {        if (tree == null || z == null) {            return null;        }        int cmp = z.key.compareTo(tree.key);        if (cmp &lt; 0) {//待删除的结点在tree的左子树            tree.left = remove(tree.left, z);            if (height(tree.right) - height(tree.left) == 2) {//如果删除后tree失去平衡, 进行调节                AVLTreeNode r = tree.right;                if (height(r.left) &gt; height(r.right)) {                    tree = rightLeftRotation(tree);                } else {                    tree = rightRightRotation(tree);                }            }        } else if (cmp &gt; 0) {//待删除的结点在tree的右子树            tree.right = remove(tree.right, z);            if (height(tree.left) - height(tree.right) == 2) {//失去平衡                AVLTreeNode l = tree.left;                if (height(l.left) &lt; height(l.right)) {                    tree = leftRightRotation(tree);                } else {                    tree = leftLeftRotation(tree);                }            }        } else {//cmp==0,tree是要删除的结点            if (tree.left != null &amp;&amp; tree.right != null) {//tree的左右孩子非空                if (height(tree.left) &gt; height(tree.right)) {                    /*                    如果tree的左子树比右子树高，则                    （1）找出tree的左子树中的最大结点                    （2）将该最大结点的值赋值给tree                     (3) 删除该最大结点 。                     采用该方法的好处是：删除结点之后，AVL树仍然是平衡的。                     */                    AVLTreeNode max = maximum(tree.left);                    tree.key = max.key;                    tree.left = remove(tree.left, max);                } else {                    /*                    如果tree的右子树比左子树高或相等，则                    （1） 找出tree的右子树中的最小结点                    （2） 将该最小结点的值赋值给tree                     (3) 删除该最大结点                    采用该方法的好处是：删除结点之后，AVL树仍然是平衡的。                     */                    AVLTreeNode min = minimum(tree.right);                    tree.key = min.key;                    tree.right = remove(tree.right, min);                }            } else {                tree = (tree.left != null) ? tree.left : tree.right;            }        }        if (tree != null) {//删除叶子结点的时候，这个tree是会返回null的。            tree.height = max(height(tree.left), height(tree.right)) + 1;        }        return tree;    }    public void remove(T key) {        AVLTreeNode z = search(mRoot, key);        if (z != null) {            mRoot = remove(mRoot, z);        }    }    private void preOrderPrint(AVLTreeNode root, int depth) {        if (root != null) {            System.out.println();//换行            for (int i = 0; i &lt; depth; i++) {//for循环来打印value前的空格                System.out.print(&quot;--&quot;);//结点深度越大，空格越多            }            System.out.print(root.key);            depth++;            preOrderPrint(root.left, depth);            preOrderPrint(root.right, depth);        }    }    public void print() {        preOrderPrint(mRoot, 0);    }    private AVLTreeNode search(AVLTreeNode node, T key) {        if (node == null) {            return null;        }        int cmp = key.compareTo(node.key);        if (cmp &lt; 0) {            return search(node.left, key);        } else if (cmp &gt; 0) {            return search(node.right, key);        } else {            return node;        }    }    private AVLTreeNode maximum(AVLTreeNode tree) {        if (tree == null) {            return null;        }        while (tree.right != null) {            tree = tree.right;        }        return tree;    }    private AVLTreeNode minimum(AVLTreeNode tree) {        if (tree == null) {            return null;        }        while (tree.left != null) {            tree = tree.left;        }        return tree;    }    public T maximum() {        AVLTreeNode p = maximum(mRoot);        if (p != null) {            return p.key;        }        return null;    }    public T minimum() {        AVLTreeNode p = minimum(mRoot);        if (p != null) {            return p.key;        }        return null;    }}</code></pre><p>测试：</p><pre><code>public class Main {    public static void main(String[] args) {        AVLTree&lt;Integer&gt; tree = new AVLTree&lt;&gt;();        int arr[] = {33, 22, 4, 7, 0, 60, 13, 32, 21, 99, 6, 15, 27, 2};        for (int i = 0; i &lt; arr.length; i++) {            tree.insert(arr[i]);        }        tree.print();        System.out.println();        System.out.println(&quot;树的根结点高度：&quot; + tree.height());        System.out.println(&quot;删除结点33,32,27,60,99&quot;);        tree.remove(33);        tree.remove(32);        tree.remove(27);        tree.remove(60);        tree.remove(99);        tree.print();        System.out.println();        System.out.println(&quot;树的根结点高度：&quot; + tree.height());    }}</code></pre><p>打印：</p><pre><code>22--7----4------0--------2------6----15------13------21--33----32------27----60------99树的根结点高度：5990删除结点33,32,27,60,997--4----0------2----6--15----13----22------21树的根结点高度：4</code></pre><p>AVLTreeNode rightLeftRotation(AVLTreeNode node) {<br>        node.right = leftLeftRotation(node.right);<br>        return rightRightRotation(node);<br>    }</p><pre><code>结合插入和删除，AVL树的实现：</code></pre><p>package DataStructureAndAlgor;<br>/**</p><ul><li><p>AVL树</p></li><li><p>回顾的时候，最好把LL,RR,LR,RL旋转的四张图画出来，好理解。</p></li><li></li><li><p>@param <T></p></li><li><p>/<br>public class AVLTree&lt;T extends Comparable<T>&gt; {</p><p>  class AVLTreeNode {</p><pre><code>  T key;  int height;  AVLTreeNode left;  AVLTreeNode right;  public AVLTreeNode(T key, AVLTreeNode left, AVLTreeNode right) {      this.key = key;      this.left = left;      this.right = right;      this.height = 0;//初始化的结点的height都是0，因为都是作为叶子结点添加到树中的。  }</code></pre><p>  }</p><p>  private AVLTreeNode mRoot;</p></li></ul><pre><code>private int height(AVLTreeNode tree) {    if (tree != null) {        return tree.height;    }    return 0;}public int height() {    return height(mRoot);}public int height(T key) {    AVLTreeNode node = search(mRoot, key);    return height(node);}private int max(int a, int b) {    return a &gt; b ? a : b;}private AVLTreeNode leftLeftRotation(AVLTreeNode node) {    checkNull(node);    AVLTreeNode  leftChild = node.left;    node.left =  leftChild.right;     leftChild.right = node;    //reset the height    node.height = max(height(node.left), height(node.right)) + 1;     leftChild.height = max(height( leftChild.left), height( leftChild.right)) + 1;    return  leftChild;}private AVLTreeNode rightRightRotation(AVLTreeNode node) {    checkNull(node);    AVLTreeNode  rightChild = node.right;    node.right =  rightChild.left;     rightChild.left = node;    node.height = max(height(node.left), height(node.right)) + 1;     rightChild.height = max(height( rightChild.left), height( rightChild.right)) + 1;    return  rightChild;}private AVLTreeNode leftRightRotation(AVLTreeNode node) {    node.left = rightRightRotation(node.left);//先对node.left旋转    return leftLeftRotation(node);//后对自己旋转}private AVLTreeNode rightLeftRotation(AVLTreeNode node) {    node.right = leftLeftRotation(node.right);    return rightRightRotation(node);}private void checkNull(AVLTreeNode node) {    if (node == null) {        throw new NullPointerException();    }}/** * 将结点插入到AVL树种，并返回根节点。 * * @param tree AVL树的根节点 * @param key  待插入的结点的值。 * @return 根节点 */private AVLTreeNode insert(AVLTreeNode tree, T key) {    if (tree == null) {//递归终点        tree = new AVLTreeNode(key, null, null);    } else {        int cmp = key.compareTo(tree.key);//compare result        if (cmp &lt; 0) {            tree.left = insert(tree.left, key);//递归插入            //插入结点后，若AVLTree失去平衡，旋转树。            if (height(tree.left) - height(tree.right) == 2) {//说明是tree结点出问题(必须是left-right，否则得负值)                if (key.compareTo(tree.left.key) &lt; 0) {//这里如果写成tree.right.key会报空指针异常                    tree = leftLeftRotation(tree);                } else {                    tree = leftRightRotation(tree);                }            }        } else if (cmp &gt; 0) {            tree.right = insert(tree.right, key);//递归插入            if (height(tree.right) - height(tree.left) == 2) {//说明是tree结点出问题(必须是left-right，否则得负值)                if (key.compareTo(tree.right.key) &lt; 0) {//这里如果写成tree.left.key会报空指针异常                    tree = rightLeftRotation(tree);                } else {                    tree = rightRightRotation(tree);                }            }        } else {  //cmp==0;            System.out.println(&quot;添加失败！不允许添加相同的结点！&quot;);        }    }    tree.height = max(height(tree.left), height(tree.right)) + 1;    return tree;}public void insert(T key) {    mRoot = insert(mRoot, key);}/** * 删除树中的结点z, 返回根节点 * * @param tree 从tree结点开始找寻要删除的结点z * @param z    待删除的根节点 * @return 根节点 */private AVLTreeNode remove(AVLTreeNode tree, AVLTreeNode z) {    if (tree == null || z == null) {        return null;    }    int cmp = z.key.compareTo(tree.key);    if (cmp &lt; 0) {//待删除的结点在tree的左子树        tree.left = remove(tree.left, z);        if (height(tree.right) - height(tree.left) == 2) {//如果删除后tree失去平衡, 进行调节            AVLTreeNode r = tree.right;            if (height(r.left) &gt; height(r.right)) {                tree = rightLeftRotation(tree);            } else {                tree = rightRightRotation(tree);            }        }    } else if (cmp &gt; 0) {//待删除的结点在tree的右子树        tree.right = remove(tree.right, z);        if (height(tree.left) - height(tree.right) == 2) {//失去平衡            AVLTreeNode l = tree.left;            if (height(l.left) &lt; height(l.right)) {                tree = leftRightRotation(tree);            } else {                tree = leftLeftRotation(tree);            }        }    } else {//cmp==0,tree是要删除的结点        if (tree.left != null &amp;&amp; tree.right != null) {//tree的左右孩子非空            if (height(tree.left) &gt; height(tree.right)) {                /*                如果tree的左子树比右子树高，则                （1）找出tree的左子树中的最大结点                （2）将该最大结点的值赋值给tree                 (3) 删除该最大结点 。                 采用该方法的好处是：删除结点之后，AVL树仍然是平衡的。                 */                AVLTreeNode max = maximum(tree.left);                tree.key = max.key;                tree.left = remove(tree.left, max);            } else {                /*                如果tree的右子树比左子树高或相等，则                （1） 找出tree的右子树中的最小结点                （2） 将该最小结点的值赋值给tree                 (3) 删除该最大结点                采用该方法的好处是：删除结点之后，AVL树仍然是平衡的。                 */                AVLTreeNode min = minimum(tree.right);                tree.key = min.key;                tree.right = remove(tree.right, min);            }        } else {            tree = (tree.left != null) ? tree.left : tree.right;        }    }    if (tree != null) {//删除叶子结点的时候，这个tree是会返回null的。        tree.height = max(height(tree.left), height(tree.right)) + 1;    }    return tree;}public void remove(T key) {    AVLTreeNode z = search(mRoot, key);    if (z != null) {        mRoot = remove(mRoot, z);    }}private void preOrderPrint(AVLTreeNode root, int depth) {    if (root != null) {        System.out.println();//换行        for (int i = 0; i &lt; depth; i++) {//for循环来打印value前的空格            System.out.print(&quot;--&quot;);//结点深度越大，空格越多        }        System.out.print(root.key);        depth++;        preOrderPrint(root.left, depth);        preOrderPrint(root.right, depth);    }}public void print() {    preOrderPrint(mRoot, 0);}private AVLTreeNode search(AVLTreeNode node, T key) {    if (node == null) {        return null;    }    int cmp = key.compareTo(node.key);    if (cmp &lt; 0) {        return search(node.left, key);    } else if (cmp &gt; 0) {        return search(node.right, key);    } else {        retur</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>二叉树前序、中序、后序遍历，和直观打印。</title>
    <link href="/2018/05/27/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E5%92%8C%E7%9B%B4%E8%A7%82%E6%89%93%E5%8D%B0%E3%80%82/"/>
    <url>/2018/05/27/%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%89%8D%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%EF%BC%8C%E5%92%8C%E7%9B%B4%E8%A7%82%E6%89%93%E5%8D%B0%E3%80%82/</url>
    
    <content type="html"><![CDATA[<pre><code>//前序遍历public static void preOrderedPrint(TreeNode root){    if (root!=null){        System.out.print(root.value);        preOrderedPrint(root.leftNode);//删去了多余的if(root.leftNode!=null)的条件判断。        preOrderedPrint(root.rightNode);    }}//中序遍历public static void inOrderedPrint(TreeNode root){    if (root!=null){        inOrderedPrint(root.leftNode);        System.out.print(root.value);        inOrderedPrint(root.rightNode);    }}//后序遍历public static void postOrderedPrint(TreeNode root){    if (root!=null){        postOrderedPrint(root.leftNode);        postOrderedPrint(root.rightNode);        System.out.print(root.value);    }}</code></pre><p>用如下的完全二叉树结构来做试验：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-8fbb5962aa2f6679.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><pre><code>TreeNode newOne=createTree(root,list);preOrderedPrint(newOne);</code></pre><p>打印：0137849256<br>很不直观有木有，于是写一个较为直观的方法：</p><pre><code class="java">public static void vividPreOrderedPrint(TreeNode root,int depth) {    if (root != null) {        System.out.println();//换行        for (int i=0;i&lt;depth;i++){//for循环来打印value前的空格            System.out.print(&quot;-&quot;);//结点深度越大，空格越多        }        System.out.print(root.value);        depth++;        vividPreOrderedPrint(root.leftNode,depth);        vividPreOrderedPrint(root.rightNode,depth);    }}</code></pre><pre><code>TreeNode newOne=createTree(root,list); vividPreOrderedPrint(newOne,0);</code></pre><p>打印：<br>0<br>-1<br>–3<br>—7<br>—8<br>–4<br>—9<br>-2<br>–5<br>–6<br>这就很清楚了，0是根节点，有一个“-”的是深度为1的结点，分别是1和2，有两个“-”的是深度为2的结点，分别是……<br></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HashMap半解析</title>
    <link href="/2018/05/27/Java/HashMap%E5%8D%8A%E8%A7%A3%E6%9E%90/"/>
    <url>/2018/05/27/Java/HashMap%E5%8D%8A%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>此篇文章是对源码的分析，但并没有贴大量源码。<br><img src="https://upload-images.jianshu.io/upload_images/7177220-d0e39ac8fdd373e8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br><img src="https://upload-images.jianshu.io/upload_images/7177220-996ee0b36ea10f52.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>3个接口前两个就不用多说了，Map&lt;K,V&gt;接口也应该对着中文版api文档看一下就明白了。</p><p>先看直接父类AbstractMap&lt;K,V&gt;：</p><h2 id="AbstractMap-lt-K-V-gt"><a href="#AbstractMap-lt-K-V-gt" class="headerlink" title="AbstractMap&lt;K,V&gt;"></a>AbstractMap&lt;K,V&gt;</h2><h3 id="内部类："><a href="#内部类：" class="headerlink" title="内部类："></a>内部类：</h3><ol><li><p><code>SimpleEntry&lt;K,V&gt;</code>:实现<code>Entry</code>接口，Entry的英文单词是条目的意思，接口里面都是一些对规定好的操作方法，看文档就行了。在类中只有<code>final key</code>和<code>value</code>两个字段，其中由于<code>key</code>是final的，因此初始化之后就不可变。实例方法都是对这两个变量的基本操作，没什么特别的。简单来说就是对<code>key</code>和<code>value</code>的一个封装。</p></li><li><p><code>SimpleImmutableEntry&lt;K,V&gt;</code>和上述没有太大差异，也是实现<code>Entry</code>接口，差异在于<code>key</code>和<code>value</code>都带有final，此外调用<code>setValue</code>会抛出异常。</p><h3 id="实例变量："><a href="#实例变量：" class="headerlink" title="实例变量："></a>实例变量：</h3></li><li><p><code>Set&lt;K&gt; keySet;</code></p></li><li><p><code>Collection&lt;V&gt; values;</code></p><h3 id="关键方法："><a href="#关键方法：" class="headerlink" title="关键方法："></a>关键方法：</h3></li><li><pre><code class="java"> public abstract Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</code></pre><p> 它是抽象方法，没有实现。它的返回值是一个类型为Entry的Set的对象，该Set对象中保存了Entry对象。也就是说有了这个方法，才能进行对真正的Entry&lt;K,V&gt;的操作。并且AbstractMap中许多方法都通过这个方法来直接返回Set对象，接着再操作，比如<code>Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</code>。我的疑问是，为什么不添加一个实例变量来保存这个Entry对象，而要每次都调用一个方法来返回对象。</p></li><li><pre><code class="java"> public Set&lt;K&gt; keySet(){...}</code></pre><p> 创建一个<code>AbstractSet</code>类（实现了<code>Set</code>接口）的子类的实现并返回。返回的对象的类中重写了<code>AbstractSet</code>的所有方法，其中重写的<code>iterator()</code>较为重要：</p><pre><code class="java"> public Iterator&lt;K&gt; iterator() {     return new Iterator&lt;K&gt;() {         //将entrySet.iterator的返回值作为当前要返回的迭代器         //当前对象就可以轻松实现对所有key的访问。         private Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();         public boolean hasNext() {return i.hasNext();}         public K next() {return i.next().getKey();}         public void remove() {i.remove();}     }; }</code></pre><p> 这样就对外界打开了可以访问key的接口，通过这个<code>keySet()</code>方法，可以拿到所有的key，但是这里如果对返回的<code>Set</code>中的key做出修改，那么也会影响整个<code>Map</code>中<code>Entry&lt;K,V&gt;</code>的key，因为返回的Set中的元素仍然指向原有<code>Entry&lt;K,V&gt;</code>中的引用。</p></li><li><pre><code class="java"> public Collection&lt;V&gt; values(){...}</code></pre><p> 上面的方法实现类似，直接拿entrySet().iterator()的返回值作为AbstractCollection子类的iterator方法的返回值，作用是类似的。</p></li></ol><hr><h2 id="JDK1-7-的HashMap"><a href="#JDK1-7-的HashMap" class="headerlink" title="JDK1.7 的HashMap"></a>JDK1.7 的HashMap</h2><h3 id="内部类：-1"><a href="#内部类：-1" class="headerlink" title="内部类："></a>内部类：</h3><ol><li><p><code>private static Holder</code>:保存了3个运行时才可确定的静态常量。</p></li><li><p><code>private static Entry&lt;K,V&gt;</code>:实现了<code>Map.Eentry&lt;K,V&gt;</code>接口，4个实例变量：</p><pre><code class="java"> final K key; V value; Entry&lt;K,V&gt; next;//通过这个引用使Entry具有了单链表的属性 int hash;</code></pre><p> 重写了equals，只要两个对象的key和value的值都equals，就返回true。</p></li><li><p><code>private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt;</code><br>是一个抽象类 ，直接看下源码。</p><pre><code class="java">private abstract class HashIterator&lt;E&gt; implements Iterator&lt;E&gt; { Entry&lt;K,V&gt; next;        // next entry to return int expectedModCount;   // For fast-fail int index;              // 用于记录遍历时外部类实例变量table(数组)中的下标 Entry&lt;K,V&gt; current;     // current entry //构造方法中，从index=0开始遍历table数组，遇到null，index++，直到 //遇到不为Null的Entry对象时，记录将当前Entry对象的引用保存到next中, //且index记录的是下一个下标的位置。 HashIterator() {     expectedModCount = modCount;     if (size &gt; 0) { // advance to first entry         Entry[] t = table;         while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)             ;     } } public final boolean hasNext() {     return next != null; } //返回下一个Entry&lt;K,V&gt;对象 final Entry&lt;K,V&gt; nextEntry() {     if (modCount != expectedModCount)         throw new ConcurrentModificationException();     Entry&lt;K,V&gt; e = next;     if (e == null)         throw new NoSuchElementException();     //如果Entry维护的链表的下一个结点是null，那么再次到table数组中遍历     //找到不为null的Entry对象并返回     //如果下一个结点不是null，就将下一个结点返回。     if ((next = e.next) == null) {         Entry[] t = table;         while (index &lt; t.length &amp;&amp; (next = t[index++]) == null)             ;     }     //用current记录当前Entry对象。     current = e;     return e; } public void remove() {     if (current == null)         throw new IllegalStateException();     if (modCount != expectedModCount)         throw new ConcurrentModificationException();     Object k = current.key;     current = null;     HashMap.this.removeEntryForKey(k);     expectedModCount = modCount; }}</code></pre><p>紧接着的是该抽象类的三个实现：</p></li><li><p><code>ValueIterator</code></p><pre><code class="java">private final class ValueIterator extends HashIterator&lt;V&gt; { public V next() {     return nextEntry().value; }}</code></pre></li><li><p><code>KeyIterator</code></p><pre><code class="java">private final class KeyIterator extends HashIterator&lt;K&gt; { public K next() {     return nextEntry().getKey(); }}</code></pre></li><li><p><code>EntryIterator</code></p><pre><code class="java">private final class EntryIterator extends HashIterator&lt;Map.Entry&lt;K,V&gt;&gt; { public Map.Entry&lt;K,V&gt; next() {     return nextEntry(); }}</code></pre></li><li><p><code>KeySet extends AbstractSet&lt;K&gt;</code>:保存了key对象的Set。</p></li><li><p><code>Values extends AbstractSet&lt;V&gt;</code>:保存了values对象的Set。</p></li><li><p><code>EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt;</code>：保存了Entry对象的Set。</p></li></ol><hr><blockquote><p>由于自己知识水平还不够，接下来本要写<code>JDK1.7 HashMap</code>·的方法的分析，但是有些方法自己都没理解明白，就更别说整理出来了。再加上<code>JDK1.8的HashMap</code>的Entry采用了<code>红黑树</code>来存储，我还是先学会红黑树再来吧。</p></blockquote><p>推荐一个写的很不错的博客，分析了JDK1.7和1.8的HashMap的源码，而且有图，<a href="https://allenwu.itscoder.com/hashmap-analyse" target="_blank" rel="noopener">https://allenwu.itscoder.com/hashmap-analyse</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java，重载的陷阱，静态分派，重写，动态分派。</title>
    <link href="/2018/05/23/JVM/Java%EF%BC%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E9%99%B7%E9%98%B1%EF%BC%8C%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%EF%BC%8C%E9%87%8D%E5%86%99%EF%BC%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E3%80%82/"/>
    <url>/2018/05/23/JVM/Java%EF%BC%8C%E9%87%8D%E8%BD%BD%E7%9A%84%E9%99%B7%E9%98%B1%EF%BC%8C%E9%9D%99%E6%80%81%E5%88%86%E6%B4%BE%EF%BC%8C%E9%87%8D%E5%86%99%EF%BC%8C%E5%8A%A8%E6%80%81%E5%88%86%E6%B4%BE%E3%80%82/</url>
    
    <content type="html"><![CDATA[<h2 id="本文描述的内容如题：重载的陷阱，静态分派，重写，动态分派"><a href="#本文描述的内容如题：重载的陷阱，静态分派，重写，动态分派" class="headerlink" title="本文描述的内容如题：重载的陷阱，静态分派，重写，动态分派"></a>本文描述的内容如题：重载的陷阱，静态分派，重写，动态分派</h2><pre><code class="java">public class StaticDispatch {    static abstract class Human{}    static class Man extends Human{}    static class Woman extends Human{}    public void sayHello(Human guy){        System.out.println(&quot;hello,guy!&quot;);    }    public void sayHello(Man guy){        System.out.println(&quot;hello,gentleman!&quot;);    }    public void sayHello(Woman guy){        System.out.println(&quot;hello,lady!&quot;);    }    public static void main(String[] args){        Human man=new Man();        Human woman=new Woman();        StaticDispatch sr=new StaticDispatch();        sr.sayHello(man);        sr.sayHello(woman);    }}//print://hello,guy!//hello,guy!</code></pre><p>我刚看代码的时候，是以为结果会是<code>hello,gentleman(换行)hello,lady!</code>这样的，但是为什么选择了参数为<code>Human</code>的重载方法呢？<br>要点总结如下：</p><ol><li>在<code>Human man=new Man()</code>中，<code>Human</code>被称为<strong>静态类型或外观类型</strong>，<code>Man</code>被称为<strong>实际类型</strong>。</li><li>编译器在编译程序的时候并不知道一个对象的实际类型是什么，只能在运行期才可确定；而静态类型是在编译器可知的。</li><li>上述代码中可以定义了两个静态类型相同但是实际类型不同的变量，但是虚拟机（或者说编译器）在重载时是通过参数的<strong>静态类型</strong>而不是<strong>实际类型</strong>作为判定依据。</li><li>因此，在编译阶段，Javac编译器会根据参数的<strong>静态类型</strong>决定使用哪个重载版本，所以选择了<code>sayHello(Human）</code>作为调用目标。</li><li>所有依赖<strong>静态类型</strong>来<strong>定位</strong>方法执行版本的分派动作称为<strong>静态分派</strong>，静态分派的典型应用是方法重载。</li></ol><blockquote><p>结论：确定<strong>重载哪个方法</strong>通过对象的<strong>静态类型</strong>。</p></blockquote><hr><h3 id="上述描述了静态分派，下文描述动态分派："><a href="#上述描述了静态分派，下文描述动态分派：" class="headerlink" title="上述描述了静态分派，下文描述动态分派："></a>上述描述了静态分派，下文描述动态分派：</h3><p>动态分派和重写有很密切的关联：</p><pre><code class="java">public class Main {    public static void main(String args[]) {        Human man=new Man();        Human woman=new Woman();        man.sayHello();        woman.sayHello();        man=new Woman();        man.sayHello();    }    static abstract class Human{        protected abstract void sayHello();    }    static class  Man extends Human{        @Override        protected void sayHello() {            System.out.println(&quot;man say hello&quot;);        }    }    static class Woman extends Human{        @Override        protected void sayHello() {            System.out.println(&quot;woman say hello&quot;);        }    }}/*打印:man say hellowoman say hellowoman say hello */</code></pre><p>这个打印结果是毫无悬念且理所当然的。<br>很明显，这里打印出不同的结果是因为对象的实际类型不同。具体的分析和解释由于我自己也不是很明白，因此推荐直接查看《深入理解java虚拟机》P253的内容。</p><blockquote><p>结论：<strong>重写的方法</strong>的调用，是根据<strong>运行期</strong>确定出的<strong>对象的实际类型</strong>，来确定具体调用哪个方法的。</p></blockquote><h2 id="总结：在实际的开发中，就是方法的重载那里要注意一下，是根据对象的静态类型来选择要重载哪个方法，而方法的重写则和平时没有什么区别。"><a href="#总结：在实际的开发中，就是方法的重载那里要注意一下，是根据对象的静态类型来选择要重载哪个方法，而方法的重写则和平时没有什么区别。" class="headerlink" title="总结：在实际的开发中，就是方法的重载那里要注意一下，是根据对象的静态类型来选择要重载哪个方法，而方法的重写则和平时没有什么区别。"></a>总结：在实际的开发中，就是方法的重载那里要注意一下，是根据对象的静态类型来选择要重载哪个方法，而方法的重写则和平时没有什么区别。</h2><p></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程生命周期和同步监视器是什么</title>
    <link href="/2018/05/21/java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9B%91%E8%A7%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2018/05/21/java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E5%90%8C%E6%AD%A5%E7%9B%91%E8%A7%86%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<p>###线程生命周期<br><strong>新建</strong>：<code>Thread thread=new Thread();</code>，用new关键字创建一个线程后，构造方法中将当前thread对象加入ThreadGroup，虚拟机为其分配内存。<br><strong>就绪</strong>：调用线程实例的<code>start()</code>，JVM为其创建方法调用栈和程序计数器，线程何时开始运行取决于JVM里线程调度器的调度。<br><strong>阻塞</strong>：如果处于就绪状态的线程获得了CPU,开始执行run方法的线程执行体,则该线程处于运行状态,如果计算机只有一个CPU,那么在任何时刻只有一个线程处于运行状态。当然,在一个多处理器的机器上,将会有多个线程并行执行;当线程数大于处理器数时,依然会存在多个线程在同一个CPU上轮换的现象。当一个线程开始运行后,它不可能一直处于运行状态(除非它的线程执行体足够短,瞬瞬间就执行结束了),线程在运行过程中需要被中断,目的是使其他线程获得执行的机会,线程调度的细节取决于底层平台所采用的策略。对于采用抢占式策略的系统而言,系统会给每个可执行的线程一个小时间段来处<br>理任务;当该时间段用完后,系统就会剥夺该线程所占用的资源源,让其他线程获得执行的机会。在选择下一个线程时,系统会考虑线程程的优先级。所有现代的桌面和服务器操作系统都采用抢占式调度策略,但一些小型设备如手机则可能采用协作式调度策略,在这样样的系统中,只有当一个线程调用了它的sleep或 yield方法后才会放弃所占用的资源一一也就是必须由该线程主动放弃所占用的资源。<br>以下情况线程将会进入阻塞：</p><ol><li>线程调用sleep()方法主动放弃所占用的处理器资源</li><li>线程调用了一个阻塞时IO方法，在该方法返回之前，该线程被阻塞</li><li>线程试图获得一个同步监视器（对象），但该同步监视器正在被别的线程所持有。</li><li>线程正在等待某个通知（notify）</li><li>程序调用了线程的suspend将该线程挂起。容易导致死锁，尽量避免。</li><li>线程调用了另一个线程的<code>join()</code>，则当前线程被阻塞，直到调用了<code>join()</code>的线程执行完成为止。</li></ol><p><img src="https://upload-images.jianshu.io/upload_images/7177220-1aed22cc2f8fb6b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br><strong>死亡</strong>：</p><ol><li>run或者call方法执行完成，线程正常结束</li><li>线程抛出一个未捕获的Exeption或者Error</li><li>直接调用线程的stop方法来结束该线程，容易导致死锁，不推荐使用。</li></ol><hr><h3 id="同步监视器"><a href="#同步监视器" class="headerlink" title="同步监视器"></a>同步监视器</h3><pre><code class="java">synchronized (obj){            //需要同步的代码//obj是同步监视器}public synchronized void foo(){//需同步的代码        //当前对象this是同步监视器}</code></pre><blockquote><p>《疯狂java讲义》：任何时刻只能有一个线程可以获得对同步监视器的锁定，当同步代码块执行完成之后，该线程会释放对该同步监视器的锁定。</p></blockquote><p>我的理解：不同的线程有不同的锁，当一个同步监视器（对象）被一个线程上锁之后，其他调用该方法的线程都无法破解这把独一无二的锁，只能阻塞，等到那条线程对同步监视器解锁后，其他线程才可以进入方法，给同步监视器上锁。</p><p>那么死锁是什么概念呢？<br><strong>条件</strong>：两个线程实例thread_1,thread_2，两个同步监视器objA, objB。<br><strong>开始</strong>：thread_1中调用一个以objA为同步监视器的同步方法fooA，同时thread_2中调用一个以objB为同步监视器的同步方法fooB。下一步,在fooA中，thread_1准备调用以objB为同步监视器的同步方法，同时，在fooB中，thread_2准备调用以objA为同步监视器的同步方法。<br><strong>此时开始出问题</strong>：由于objA和objB都被同时作为同步监听器，并且被上锁了，当thread_1想要对objB上锁的时候，发现objB已经被锁上了，并且还没解开，那么thread_1只能阻塞。同时thread_2想要对objA上锁的时候，也发现objA也被锁住了，也只能阻塞。两条线程同时阻塞，并且没有办法解锁，此时成为死锁。</p><pre><code class="java">public class Main {    public static void main(String args[]){        A a=new A();        B b=new B();        Thread thread_1=new Thread(new Runnable() {            @Override            public void run() {                    a.fooA(b);            }        });        Thread thread_2=new Thread(new Runnable() {            @Override            public void run() {                b.fooB(a);            }        });        thread_1.start();        thread_2.start();    }}class A{    public synchronized void fooA(B b){        try {            Thread.sleep(200);        } catch (InterruptedException e) {            e.printStackTrace();        }        b.last();    }    public synchronized void last(){    }}class  B{    public synchronized void fooB(A a){        try {            Thread.sleep(200);        } catch (InterruptedException e) {            e.printStackTrace();        }        a.last();    }    public synchronized void last(){    }}</code></pre><p>运行之后：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-1b7c5b11281f6d85.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>程序一直不能自动结束，需要手动停止，因为死锁导致阻塞。<br></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>内部类和静态内部类的加载</title>
    <link href="/2018/05/21/Java/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/"/>
    <url>/2018/05/21/Java/%E5%86%85%E9%83%A8%E7%B1%BB%E5%92%8C%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<pre><code class="java">public class Main {    static {        System.out.println(&quot;加载外部类&quot;);    }    public Main() {        System.out.println(&quot;外部类构造方法&quot;);    }    public void newInnerClassInstance() {        InnerClass innerClass = new InnerClass();    }    public void loadStaticInnerClass(){        StaticInnerClass.i=100;    }    public static void main(String[] args) throws Throwable {        Main main = new Main();        main.newInnerClassInstance();        main.loadStaticInnerClass();    }    private class InnerClass {        {            System.out.println(&quot;加载内部类&quot;);        }    }    static class StaticInnerClass {        static int i=0;        static {            System.out.println(&quot;加载静态内部类&quot;);        }    }}//print:/** * 加载外部类 * 外部类构造方法 * 加载内部类 * 加载静态内部类 */</code></pre><p>解释打印的原因：<br><strong>加载外部类</strong>: 当虚拟机启动时，我们指定的main方法的main类，由虚拟机来加载，因此肯定会初始化这个类。<br><strong>外部类构造方法</strong>：由语句<code>Main main=new Main();</code>引起<br><strong>加载内部类</strong>：由语句<code>main.newInnerClassInstance()#InnerClass innerClass = new InnerClass();</code>引起，由于内部类没有static块和纯static变量（常量的调用无法引起类加载），所以只能通过new或者反射来引起初始化，这里用new语句创建对象来初始化内部类，并用普通实例代码块来表示初始化了类（无法使用static块）。<br><strong>加载静态内部类</strong>：和普通类加载就没区别，本来静态内部类就和外部类没有太大关联，和普通的类十分接近。由于加载内部类已经用了new语句来初始化类了，这里就采用调用了静态字段的方法来使类初始化。</p><hr><p>此外，为什么非静态内部类不能有static字段、static方法、static块？</p><ul><li>首先，内部类对象必须天然地持有唯一的对外部类对象的引用，一个外部类对象可以有许多内部类对象的引用，但是一个内部类有且必须有唯一一个对外部类对象的引用。</li><li>暂时没有找到比较靠谱的解释，或许从虚拟机的角度来看会比较容易理解，待定…<br></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java变量初始化时的赋值</title>
    <link href="/2018/05/19/JVM/java%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E7%9A%84%E8%B5%8B%E5%80%BC/"/>
    <url>/2018/05/19/JVM/java%E5%8F%98%E9%87%8F%E5%88%9D%E5%A7%8B%E5%8C%96%E6%97%B6%E7%9A%84%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7177220-a4e59e0b910782d6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java类初始化</title>
    <link href="/2018/05/19/JVM/java%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2018/05/19/JVM/java%E7%B1%BB%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>虚拟机规范严格规定了<strong>有且只有</strong>5种情况必须立即对类进行初始化（而加载、验证、准备自然需要在此之前开始）：</p><ol><li>使用new关键字实例化对象的时候、读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。</li><li>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先出发其初始化。</li><li>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li><li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类)，虚拟机会先初始化这个主类。</li><li>当使用JDK1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实力最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化。</li></ol><p>哪些情况下不会对类进行初始化：</p><ol><li>通过子类引用父类的静态字段，不会导致子类初始化。<pre><code class="java">public class Main { public static void main(String[] args) throws Throwable {     System.out.println(SubClass.value); }}class SuperClass{ static {     System.out.println(&quot;SuperClass init!&quot;); } public static int value=123;}class SubClass extends SuperClass{ static {     System.out.println(&quot;SubClass init&quot;); }}//print://SuperClass init!//123</code></pre></li><li>通过数组定义来引用类，不会出发此类的初始化。<br>通过数组来引用的类，不会初始化此类，但是会初始化另一个由虚拟机自动生成的，继承于Object类的子类，数组对象中的属性和方法都实现在这个类里面。<pre><code class="java">public class Main { public static void main(String[] args) throws Throwable {     SuperClass[] a=new SuperClass[10]; }}//print nothing</code></pre></li><li>通过static final修饰的基本数据类型或String实例（或者称为常量）在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会出发定义 常量的类的初始化。<pre><code class="java">public class Main { public static void main(String[] args) throws Throwable {     System.out.println(ConstClass.HELLOWORLD);//print:hello world! }}class ConstClass{ static {     System.out.println(&quot;ConstClass init!&quot;); } public static final String HELLOWORLD=&quot;hello world!&quot;;}</code></pre>字符串HELLOWORLD在编译阶段存入了调用类Main的常量池中，因此对字符串的引用被转化为Main类对自身常量池的引用。实际上Main的class文件中并没有ConstClass类的符号引用入口，两个类在编译成class文件之后就不存在任何联系了。</li><li>接口的加载过程和类的加载过程有些不同。<br> 接口不能用静态语句，但编译器仍然会为接口生成“&lt;clint()&gt;”类构造器，用于初始化接口中所定义的成员变量（接口中的成员变量都是<code>static final</code>）。<br> 与类初始化的真正区别在于前面的初始化场景的第三种，当一个类在初始化时，要求其父类全部都已经初始化过了，但是接口初始化时，不要求其父类接口全部完成初始化，只有在真正使用到父类接口的时候（如引用接口中定义的常量）才会初始化</li></ol><p>来自《深入理解java虚拟机》<br></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《Java编程思想》中关于线程的描述</title>
    <link href="/2018/05/14/java%E5%B9%B6%E5%8F%91/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0/"/>
    <url>/2018/05/14/java%E5%B9%B6%E5%8F%91/%E3%80%8AJava%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%E3%80%8B%E4%B8%AD%E5%85%B3%E4%BA%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%8F%8F%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<p>最开始，线程只是用于分配单个处理器的处理时间的一种工具。但假如操作系统本身支持多个处理器，那么每个线程都可分配给一个不同的处理器，真正进入“并行运算”状态。从程序设计语言的角度看，多线程操作最有价值的特性之一就是程序员不必关心到底使用了多少个处理器。程序在逻辑意义上被分割为数个线程；假如机器本身安装了多个处理器，那么程序会运行得更快，毋需作出任何特殊的调校。</p><hr><p>利用对象，可将一个程序分割成相互独立的区域。我们通常也需要将一个程序转换成多个独立运行的子任务。象这样的每个子任务都叫作一个“线程”（Thread）。编写程序时，可将每个线程都想象成独立<br>运行，而且都有自己的专用CPU。一些基础机制实际会为我们自动分割CPU的时间。我们通常不必关心这些细节问题，所以多线程的代码编写是相当简便的。这时理解一些定义对以后的学习狠有帮助。“进程”是指一种“自包容”的运行程序，有自己的地址空间。“多任务”操作系统能同时运行多个进程（程序）——但实际是由于CPU分时机制的作用，使每个进程都能循环获得自己的CPU时间片。但由于轮换速度非常快，使得所有程序好象是在“同时”运行一样。“线程”是进程内部单一的一个顺序控制流。因此，一个进程可能容纳<br>了多个同时执行的线程。<br></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>element为int的二叉查找树</title>
    <link href="/2018/05/06/%E7%AE%97%E6%B3%95/element%E4%B8%BAint%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/"/>
    <url>/2018/05/06/%E7%AE%97%E6%B3%95/element%E4%B8%BAint%E7%9A%84%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<p>参照着《数据结构java语言描述》的伪码，自己实现的方法细节，最复杂的一个方法是<code>remove()</code></p><pre><code class="java">package DataStructure.Tree;public class IntTreeBag implements Cloneable {    private Node root;    public class Node {        Node(int element, Node left, Node right) {            this.element = element;            this.left = left;            this.right = right;        }        public Node getLeft() {            return left;        }        public Node getRight() {            return right;        }        private int element;        private Node left;        private Node right;        @Override        public String toString() {            return String.valueOf(element);        }    }    public IntTreeBag() {        this(0);    }    public IntTreeBag(int rootValue) {        root = new Node(rootValue, null, null);    }    public int size() {        return size(root);    }    private int size(Node node) {        if (node == null) {            return 0;        } else {            return 1 + size(node.left) + size(node.right);        }    }    public Node getRoot() {        return root;    }    public void add(int target) {        boolean done = false;        Node cursor = root;        while (!done) {            if (target &lt; cursor.element) {                if (cursor.left == null) {                    cursor.left = new Node(target, null, null);                    done = true;                } else {                    cursor = cursor.left;                }            } else if (target &gt; cursor.element) {                if (cursor.right == null) {                    cursor.right = new Node(target, null, null);                    done = true;                } else {                    cursor = cursor.right;                }            } else {//target==cursor.element                //查找二叉树还是暂时不做有相同结点的处理。//                if (cursor.left == null) {//                    cursor.left = new Node(target, null, null);//                    done = true;//                } else {//                    cursor = cursor.left;//                }                done=true;            }        }    }    /**     * 删除值为target的目标结点，巧妙地记录下游标结点的父结点，并判断     * 当前游标在左子树还是右子树，然后操作游标结点的父结点即可容易删除目标。     *     * 删除操作将目标分成5种类型来操作，分别是：     * 目标是根节点，目标左右结点为空，目标仅左结点为空，     * 目标仅右结点为空，目标左右结点非空     *     * @param target 目标     * @return 如果成功删除返回true，否则返回false     */    public boolean remove(int target) {        if (isEmpty()) {            return true;        }        Node parentOfCursor = null;//cursor的父结点        Node cursor = root;        boolean inLeft=false;//记录cursor是在左结点还是在右结点        boolean done = false;        while (!done) {            if (cursor==null){//没有找到target                return false;            }            if (target &lt; cursor.element) {                parentOfCursor = cursor;                cursor = cursor.left;                inLeft=true;            } else if (target &gt; cursor.element) {                parentOfCursor = cursor;                cursor = cursor.right;                inLeft=false;            } else {//target == cursor.element                if (cursor == root) {//cursor就是根结点, cursor没有向下搜索过, inLeft和parentOfCursor都还是初始值                    if (cursor.left == null) {                        root = root.right;                        done=true;                    } else {//root.left!=null                        if (root.left.right == null) {                            root.left.right = root.right;                            root = root.left;                            done=true;                        } else {                            root.element = getRightMostNode(root.left).element;                            removeRightMostNode(root.left);                            done=true;                        }                    }                } else if (cursor.left == null &amp;&amp; cursor.right == null) {//左右结点都为空                    if (inLeft){                        parentOfCursor.left=null;                        done=true;                    }else {                        parentOfCursor.right=null;                        done=true;                    }                }else if (cursor.left == null){//左结点为空，右结点不为空                    if (inLeft){                        parentOfCursor.left=cursor.right;                        done=true;                    }else {                        parentOfCursor.right=cursor.right;                        done=true;                    }                }else if (cursor.right == null){//右结点为空，左结点不为空                    if (inLeft){                        parentOfCursor.left=cursor.left;                        done=true;                    }else {                        parentOfCursor.right=cursor.left;                        done=true;                    }                }else {//左右两个子结点都不为空                    if (cursor.left.right==null){                        cursor.left.right=cursor.right;                        if (inLeft){                            parentOfCursor.left=cursor.left;                            done=true;                        }else {                            parentOfCursor.right=cursor.left;                            done=true;                        }                    }else {                        cursor.element=getRightMostNode(cursor.left).element;                        removeRightMostNode(cursor.left);                        done=true;                    }                }            }        }        return true;//能跳出while循环就是done=true，成功删除了。    }    public boolean isEmpty() {        return root == null;    }    /**     * remove the most left node of the rootNode     *     * @param rootNode .     * @return return true if remove target. return     * false if the left of rootNode is null.     */    public boolean removeLeftMostNode(Node rootNode) {        Node c = rootNode;        Node parentOfc = null;        while (c.left != null) {            parentOfc = c;            c = c.left;        }        if (parentOfc != null) {//rootNode.left!=null            parentOfc.left = null;            return true;        } else {            //rootNode.left==null.            return false;        }    }    public boolean removeRightMostNode(Node rootNode) {        Node c = rootNode;        Node parentOfc = null;        while (c.left != null) {            parentOfc = c;            c = c.right;        }        if (parentOfc != null) {            parentOfc.right = null;            return true;        } else {            return false;        }    }    public Node getLeftMostNode(Node rootNode) {        Node cursor = rootNode;        while (cursor.left != null) {            cursor = cursor.left;        }        return cursor;    }    public Node getRightMostNode(Node rootNode) {        Node cursor = rootNode;        while (cursor.right != null) {            cursor = cursor.right;        }        return cursor;    }    public int countOccurences(int target) {        int count = 0;        Node cursor = root;        while (cursor != null) {            if (target &lt; cursor.element) {                cursor = cursor.left;            } else if (target &gt; cursor.element) {                cursor = cursor.right;            } else if (target == cursor.element) {                cursor = cursor.left;                count++;            }        }        return count;    }    @Override    protected Object clone() throws CloneNotSupportedException {        super.clone();        return treeCopy(root);    }    //深度拷贝一个树，返回拷贝的全新的树的根节点。    private Node treeCopy(Node node) {        Node left, right;        if (node == null) {            return null;        } else {            left = treeCopy(node.left);            right = treeCopy(node.right);            return new Node(node.element, left, right);        }    }    /**     * 先序遍历打印     * @param node 根节点     */    public void preorderPrint(Node node){        if (node!=null){            System.out.println(node.element);            if (node.left!=null){                preorderPrint(node.left);            }            if (node.right!=null){                preorderPrint(node.right);            }        }    }    /**     * 添加一棵树，传入根结点即可     * 因为内部调用了add()，因此会过滤掉相同element的结点。     * @param node root of the tree to be added     */    public void addAll(Node node){        if (node!=null){            this.add(node.element);            if (node.left!=null){                addAll(node.left);            }            if (node.right!=null){                addAll(node.right);            }        }    }    public void addMany(int...elements){        for (int i=0;i&lt;elements.length;i++){            add(elements[i]);        }    }    /**     * 按从小到大的顺序打印，其实是中序遍历     * @param node 根节点     */    public void printInSequence(Node node){        if (node!=null){            if (node.left!=null){                printInSequence(node.left);            }            System.out.print(node.element+&quot; &quot;);            if (node.right!=null){                printInSequence(node.right);            }        }    }    /**     * 倒序打印，即从大到小打印树，也是中序遍历，     * 不过是先右结点，根节点，再左结点     * @param node     */    public void printInReverseSequence(Node node){        if (node!=null){            if (node.right!=null){                printInReverseSequence(node.right);            }            System.out.print(node.element+&quot; &quot;);            if (node.left!=null){                printInReverseSequence(node.left);            }        }    }}</code></pre><p>ht) {<br>            this.element = element;<br>            this.left = left;<br>            this.right = right;<br>        }<br>        public Node getLeft() {<br>            return left;<br>        }<br>        public Node getRight() {<br>            return right;<br>        }<br>        private int element;<br>        private Node left;<br>        private Node right;</p><pre><code>    @Override    public String toString() {        return String.valueOf(element);    }}public IntTreeBag() {    this(0);}public IntTreeBag(int rootValue) {    root = new Node(rootValue, null, null);}public int size() {    return size(root);}private int size(Node node) {    if (node == null) {        return 0;    } else {        return 1 + size(node.left) + size(node.right);    }}public Node getRoot() {    return root;}public void add(int target) {    boolean done = false;    Node cursor = root;    while (!done) {        if (target &lt; cursor.element) {            if (cursor.left == null) {                cursor.left = new Node(target, null, null);                done = true;            } else {                cursor = cursor.left;            }        } else if (target &gt; cursor.element) {            if (cursor.right == null) {                cursor.right = new Node(target, null, null);                done = true;            } else {                cursor = cursor.right;            }        } else {//target==cursor.element            //查找二叉树还是暂时不做有相同结点的处理。</code></pre><p>//                if (cursor.left == null) {<br>//                    cursor.left = new Node(target, null, null);<br>//                    done = true;<br>//                } else {<br>//                    cursor = cursor.left;<br>//                }<br>                done=true;<br>            }<br>        }<br>    }</p><pre><code>/** * 删除值为target的目标结点，巧妙地记录下游标结点的父结点，并判断 * 当前游标在左子树还是右子树，然后操作游标结点的父结点即可容易删除目标。 * * 删除操作将目标分成5种类型来操作，分别是： * 目标是根节点，目标左右结点为空，目标仅左结点为空， * 目标仅右结点为空，目标左右结点非空 * * @param target 目标 * @return 如果成功删除返回true，否则返回false */public boolean remove(int target) {    if (isEmpty()) {        return true;    }    Node parentOfCursor = null;//cursor的父结点    Node cursor = root;    boolean inLeft=false;//记录cursor是在左结点还是在右结点    boolean done = false;    while (!done) {        if (cursor==null){//没有找到target            return false;        }        if (target &lt; cursor.element) {            parentOfCursor = cursor;            cursor = cursor.left;            inLeft=true;        } else if (target &gt; cursor.element) {            parentOfCursor = cursor;            cursor = cursor.right;            inLeft=false;        } else {//target == cursor.element            if (cursor == root) {//cursor就是根结点, cursor没有向下搜索过, inLeft和parentOfCursor都还是初始值                if (cursor.left == null) {                    root = root.right;                    done=true;                } else {//root.left!=null                    if (root.left.right == null) {                        root.left.right = root.right;                        root = root.left;                        done=true;                    } else {                        root.element = getRightMostNode(root.left).element;                        removeRightMostNode(root.left);                        done=true;                    }                }            } else if (cursor.left == null &amp;&amp; cursor.right == null) {//左右结点都为空                if (inLeft){                    parentOfCursor.left=null;                    done=true;                }else {                    parentOfCursor.right=null;                    done=true;                }            }else if (cursor.left == null){//左结点为空，右结点不为空                if (inLeft){                    parentOfCursor.left=cursor.right;                    done=true;                }else {                    parentOfCursor.right=cursor.right;                    done=true;                }            }else if (cursor.right == null){//右结点为空，左结点不为空                if (inLeft){                    parentOfCursor.left=cursor.left;                    done=true;                }else {                    parentOfCursor.right=cursor.left;                    done=true;                }            }else {//左右两个子结点都不为空                if (cursor.left.right==null){                    cursor.left.right=cursor.right;                    if (inLeft){                        parentOfCursor.left=cursor.left;                        done=true;                    }else {                        parentOfCursor.right=cursor.left;                        done=true;                    }                }else {                    cursor.element=getRightMostNode(cursor.left).element;                    removeRightMostNode(cursor.left);                    done=true;                }            }        }    }    return true;//能跳出while循环就是done=true，成功删除了。}public boolean isEmpty() {    return root == null;}/** * remove the most left node of the rootNode * * @param rootNode . * @return return true if remove target. return * false if the left of rootNode is null. */public boolean removeLeftMostNode(Node rootNode) {    Node c = rootNode;    Node parentOfc = null;    while (c.left != null) {        parentOfc = c;        c = c.left;    }    if (parentOfc != null) {//rootNode.left!=null        parentOfc.left = null;        return true;    } else {        //rootNode.left==null.        return false;    }}public boolean removeRightMostNode(Node rootNode) {    Node c = rootNode;    Node parentOfc = null;    while (c.left != null) {        parentOfc = c;        c = c.right;    }    if (parentOfc != null) {        parentOfc.right = null;        return true;    } else {        return false;    }}public Node getLeftMostNode(Node rootNode) {    Node cursor = rootNode;    while (cursor.left != null) {        cursor = cursor.left;    }    return cursor;}public Node getRightMostNode(Node rootNode) {    Node cursor = rootNode;    while (cursor.right != null) {        cursor = cursor.right;    }    return cursor;}public int countOccurences(int target) {    int count = 0;    Node cursor = root;    while (cursor != null) {        if (target &lt; cursor.element) {            cursor = cursor.left;        } else if (target &gt; cursor.element) {            cursor = cursor.right;        } else if (target == cursor.element) {            cursor = cursor.left;            count++;        }    }    return count;}@Overrideprotected Object clone() throws CloneNotSupportedException {    super.clone();    return treeCopy(root);}//深度拷贝一个树，返回拷贝的全新的树的根节点。private Node treeCopy(Node node) {    Node left, right;    if (node == null) {        return null;    } else {        left = treeCopy(node.left);        right = treeCopy(node.right);        return new Node(node.element, left, right);    }}/** * 先序遍历打印 * @param node 根节点 */public void preorderPrint(Node node){    if (node!=null){        System.out.println(node.element);        if (node.left!=null){            preorderPrint(node.left);        }        if (node.right!=null){            preorderPrint(node.right);        }    }}/** * 添加一棵树，传入根结点即可 * 因为内部调用了add()，因此会过滤掉相同element的结点。 * @param node root of the tree to be added */public void addAll(Node node){    if (node!=null){        this.add(node.element);        if (node.left!=null){            addAll(node.left);        }        if (node.right!=null){            addAll(node.right);        }    }}public void addMany(int...elements){    for (int i=0;i&lt;elements.length;i++){        add(elements[i]);    }}/** * 按从小到大的顺序打印，其实是中序遍历 * @param node 根节点 */public void printInSequence(Node node){    if (node!=null){        if (node.left!=null){            printInSequence(node.left);        }        System.out.print(node.element+&quot; &quot;);        if (node.right!=null){            printInSequence(node.right);        }    }}/** * 倒序打印，即从大到小打印树，也是中序遍历， * 不过是先右结点，根节点，再左结点 * @param node */public void printInReverseSequence(Node node</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Activity启动模式脑图</title>
    <link href="/2018/05/02/Android/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%84%91%E5%9B%BE/"/>
    <url>/2018/05/02/Android/Activity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E8%84%91%E5%9B%BE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7177220-9750c552a41da7e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>总结于Android开发艺术探索》</p><hr><p>我发现书上的内容和官网的内容还是有点出入，从介绍顺序和介绍task，back stack的思想方面和书上有很大的不同，在次放google的这部分内容的连接：<a href="https://developer.android.com/guide/components/activities/tasks-and-back-stack" target="_blank" rel="noopener">https://developer.android.com/guide/components/activities/tasks-and-back-stack</a></p><p>郭霖：<br><a href="http://blog.csdn.net/guolin_blog/article/details/41087993" target="_blank" rel="noopener">Android任务和返回栈完全解析，细数那些你所不知道的细节</a><br><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组实现的优先队列</title>
    <link href="/2018/04/28/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    <url>/2018/04/28/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/01d4bb5571e1" target="_blank" rel="noopener">MyLoopQueue</a></p><pre><code class="java">package DataStructure;import java.util.NoSuchElementException;/** * 这是一个用数组实现的优先队列。 * * 该思路参考《数据结构Java语言描述》的page249。 * * 入队时通过指定优先级参数添加到优先队列，出队时，不同优先级之间优先级较高的先出队， * 相同优先级，先入先出。 * * 内部维护了一个队列数组，靠队列数组来简单地实现不同优先级队列的读写 * 当初始化时指定一个最高优先级，然后用for循环一次性把数组中的对象都new出来。 * add方法额外传入一个int表示优先级，然后利用这个int来访问数组中的元素，也便访问到对应优先级的队列了 * remove同理。 * @param &lt;T&gt; */public class PriorityQueue&lt;T&gt; {    private int highestPriority;//优先级从0到highestPriority    private MyLoopQueue[] queueArray;//MyLoopQueue是用数组实现的，不可自动扩容的循环队列。    private int currentMaxPriority;//当前最高的优先级。    public PriorityQueue(int highestPriority,int capacityOfEachPriority){        queueArray=new MyLoopQueue[highestPriority+1];        this.highestPriority=highestPriority;        currentMaxPriority=0;        for (int i=0;i&lt;=highestPriority;i++){            queueArray[i]=new MyLoopQueue(capacityOfEachPriority);        }    }    public void add(T element, int priority) {        if (priority&gt;highestPriority||priority&lt;0){            try {                throw new Exception(&quot;输入的优先级不合法，最大优先级为：&quot;+highestPriority+&quot;最小优先级为：0&quot;);            } catch (Exception e) {                e.printStackTrace();            }        }        if (priority&gt;currentMaxPriority){            currentMaxPriority=priority;        }        MyLoopQueue q=queueArray[priority];        q.add(element);    }    public T remove() {        MyLoopQueue q=queueArray[currentMaxPriority];        while (q.isEmpty() &amp;&amp; currentMaxPriority&gt;0){            q=queueArray[--currentMaxPriority];        }        T answer= (T) q.remove();        return answer;    }    public T peek() {        return (T) queueArray[currentMaxPriority].peek();    }}  </code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>链表实现队列</title>
    <link href="/2018/04/27/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <url>/2018/04/27/%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<pre><code class="javapackage">import java.util.NoSuchElementException;public class LinkedQueue&lt;T&gt; {    private class Node{        private Node next;        private T element;        Node(Node next, T element) {            this.next = next;            this.element = element;        }    }    private int size;    private Node headPointer;//指向链表头结点的指针；    private Node tailPointer;//指向链表尾结点的指针；    public LinkedQueue() {        Node blankNode=new Node(null,null);//什么也不存储的头结点，用于初始化链表，并同时被头指针和尾指针引用。        headPointer=blankNode;        tailPointer=blankNode;        size=0;    }    public void add(T element) {        Node newNode=new Node(null,element);        tailPointer.next=newNode;        tailPointer=newNode;        size++;    }    public T remove() {        if (isEmpty()){            throw new NoSuchElementException(&quot;队列为空！&quot;);        }        T answer;        Node first=headPointer.next;//headPointer引用blankNode，就是是头结点，他的下一项才是真正的链表的第一个结点。        answer=first.element;        headPointer.next=first.next;        first.next=null;        size--;        return answer;    }    public boolean isEmpty() {        return size==0;//return headPointer==tailPointer;    }    public int size(){        return size;    }    public T peek(){        if (isEmpty()){            throw new NoSuchElementException(&quot;队列为空！&quot;);        }        return headPointer.next.element;    }    @Override    public String toString() {        if (isEmpty()){            return &quot;[]&quot;;        }        StringBuilder sb=new StringBuilder(&quot;[&quot;);        Node cursor=headPointer.next;//指向第一个有意义的结点。        for (int i=0;i&lt;size;i++){            sb.append(cursor.element.toString());            if (i!=size-1){                sb.append(&quot;,&quot;);            }            cursor=cursor.next;        }        sb.append(&quot;]&quot;);        return sb.toString();    }}</code></pre><pre><code class="java">public class Main {    public static void main(String[] args) throws Throwable {        LinkedQueue&lt;String&gt; q=new LinkedQueue&lt;&gt;();        q.add(&quot;1&quot;);        q.add(&quot;2&quot;);        q.add(&quot;3&quot;);        System.out.println(q);//[1,2,3]        q.remove();        q.remove();        System.out.println(q);//[3]        q.add(&quot;4&quot;);        q.add(&quot;5&quot;);        q.add(&quot;6&quot;);        q.add(&quot;7&quot;);        System.out.println(q);//[3,4,5,6,7]    }</code></pre><hr><p>分解着一个一个方法来看如何用链表实现队列：</p><h2 id="1-构造方法"><a href="#1-构造方法" class="headerlink" title="1. 构造方法"></a>1. 构造方法</h2><p><img src="https://upload-images.jianshu.io/upload_images/7177220-a3498f69c87e18e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><pre><code class="java">//构造函数初始化链表//将全局变量指向一个blankNode头结点，这个头结点什么也不做，只是用来标记这是链表的开头。//方便操作public LinkedQueue() {    Node blankNode=new Node(null,null);//什么也不存储的头结点，用于初始化链表，并同时被头指针和尾指针引用。    headPointer=blankNode;    tailPointer=blankNode;    size=0;}</code></pre><h2 id="2-add"><a href="#2-add" class="headerlink" title="2. add"></a>2. add</h2><pre><code class="java">public void add(T element) {    Node newNode=new Node(null,element);//行1    tailPointer.next=newNode;//行2    tailPointer=newNode;//行3    size++;}//下面用图描述每行代码做了什么</code></pre><ol><li>行1：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-ea6800a0525a79dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li><li>行2：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-93812004a2e25d2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li><li>行3：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-bfbd29340983826a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ol><p>那么当调用了需多次add方法之后，就应该是这个样子：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-acf1fdfa1eff1301.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" srcset="/img/loading.gif" alt="image.png"></p><h2 id="3-remove"><a href="#3-remove" class="headerlink" title="3. remove"></a>3. remove</h2><pre><code class="java">public T remove() {    if (isEmpty()){        throw new NoSuchElementException(&quot;队列为空！&quot;);    }    T answer;    Node first=headPointer.next;//headPointer引用blankNode，就是是头结点，他的下一项才是真正的链表的第一个结点。    answer=first.element;    headPointer.next=first.next;//行1    first.next=null;//行2    size--;    return answer;}</code></pre><p>出队的操作，直接看图</p><ol><li><p>行1：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-f52f527a85eeaf0f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><ol start="2"><li>行2：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-04b57e35c28513bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ol></li></ol><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>数组实现固定长度的循环队列</title>
    <link href="/2018/04/27/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/"/>
    <url>/2018/04/27/%E7%AE%97%E6%B3%95/%E6%95%B0%E7%BB%84%E5%AE%9E%E7%8E%B0%E5%9B%BA%E5%AE%9A%E9%95%BF%E5%BA%A6%E7%9A%84%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<p>只要指定了初始大小之后就都还能用，后进后出，就是不能动态扩容，也不能指定了一次容量之后再变更容量，由于水平原因，在尝试复制数组的时候因为头指针和尾指针不知道如何处理，没能实现循环队列的动态扩容功能。<br>而官方的ArrayDeque是动态扩容的双端队列，可以去看那个的实现方法。</p><pre><code class="java">package DataStructure;import java.util.NoSuchElementException;public class MyLoopQueue&lt;T&gt; {    private T[] array;    private int front;    private int len;    private int rear;    @SuppressWarnings(&quot;unchecked&quot;)    public MyLoopQueue(int capacity) {        array = (T[]) new Object[capacity];        len = capacity;        front = 0;        rear = 0;    }    public MyLoopQueue(){        this(10);    }//    @SuppressWarnings(&quot;unchecked&quot;)//    private void ensureCapacity(int capacity) {//        T[] newArray = (T[]) new Object[capacity];////        System.arraycopy(array, 0, newArray, 0, len);//        array = newArray;//        //以上，array指向了新建的对象，并且成功完成赋值。//        len = capacity;//    }    public void add(T element) {        if (isFull()) {            throw new NoSuchElementException(&quot;队列已满！&quot;);        }        array[rear++] = element;        rear = rear == len ? 0 : rear;  //不能在add(element)里面直接动态扩容的原因：                                        //问题出在这一句，如果添加到最后一个下标，rear将==0。但是下一次调用add(element)时，                                        // 会将element放入0的位置，并覆盖之前的所有数据。    }    public T remove() {        if (isEmpty()) {            throw new NoSuchElementException(&quot;队列已空！&quot;);        }        T answer = array[front];        array[front++]=null;        front = front == len ? 0 : front;        return answer;    }    public boolean isEmpty() {        return size()==0;    }    public boolean isFull() {        return size()==len;    }    public int size() {        if (rear == front) {            return array[front] == null ? 0 : len;        } else if (rear &gt; front) {            return rear - front;        } else {            return rear + len - front;        }    }    public T peek() {        if (isEmpty()) {            throw new NoSuchElementException(&quot;队列为空！&quot;);        }        return array[front];    }    @Override    public String toString() {        StringBuilder sb = new StringBuilder();        sb.append(&quot;[&quot;);        if (isEmpty()) {            sb.append(&quot;]&quot;);            return sb.toString();        }        for (int i = 0; i &lt; size(); i++) {            T a = array[((front + i) % len)];            sb.append(a.toString());            if (i!=size()-1){                sb.append(&quot; , &quot;);            }        }        sb.append(&quot;]&quot;);        return sb.toString();    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java对象的创建、内存布局、对象访问</title>
    <link href="/2018/04/22/JVM/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E3%80%81%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/"/>
    <url>/2018/04/22/JVM/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E3%80%81%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80%E3%80%81%E5%AF%B9%E8%B1%A1%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="对象的创建："><a href="#对象的创建：" class="headerlink" title="对象的创建："></a>对象的创建：</h3><ol><li>检查被new的对象的类是否已经被加载，解析，初始化过。若没有，执行相应的类加载过程</li><li>分配内存（两种方式）<pre><code>         1. 指针碰撞：用Serial、ParNew等带Compact过程的垃圾收集器  2. 空闲列表：用CMS这种基于Mark-Sweep算法的垃圾收集器。</code></pre><ol start="3"><li>内存分配不是线程安全的：在并发情况下，可能出现在给对象A分配内存，指针还没来得及修改，对象B又使用了原来的指针来分配内存。解决方法：<ol><li>对分配内存空间的动作进行同步处理：用CAS配上失败重试。</li><li>把内存分配的动作按照不同线程分配到不同空间中进行：每个线程在堆中预先分配一小块本地线程分配缓冲（TLAB），哪个线程需要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。</li></ol></li><li>内存分配完后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这保证了比如声名int a;不用赋值也能直接使用（a=0），程序能访问到这些字段的数据类型所对应的零值。</li><li>虚拟机对对象进行必要的设置，如：对象是哪个类的实例，如何找到类的元数据信息，对象的HashCode，对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）中。</li><li>从虚拟机来看，新的对象已经产生，但是从Java程序来看，创建才刚刚开始，<init>方法还没执行，所有字段都还为零。所以执行new指令之后会接着执行<init>方法，把对象进行初始化，这样真正可用的对象才是完全产生出来。</li></ol></li></ol><h3 id="对象的内存布局："><a href="#对象的内存布局：" class="headerlink" title="对象的内存布局："></a>对象的内存布局：</h3><ol><li>对象头：<pre><code> 1. 存储对象自身的运行时数据：HashCode,GC分代年龄，锁状态标识，线程持有的锁，偏向线程ID，偏向时间戳等。 2. 类型指针：即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。 3. 若对象是个数组，对象头中还有一块用来记录数组长度。</code></pre></li><li>实例数据：<pre><code> 1. 对象真正存储的有效信息，也是程序代码中所定义的各种类型的字段内容。无论是父类继承的，还是子类自己定义的，都需要记录下来。实例数据的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义的顺序的影响。 2. 分配策略为：longs/doubles、ints、shorts/chars、bytes/booleans、oops(Ordinary Object Pointers)。相同宽度的字段总是被分配到一起。且父类定义的变量会出现在子类之前。</code></pre></li><li>对齐填充：占位符的作用。虚拟机要求对象大小必须是8字节的整数倍，而对象头大小刚好是8字节的倍数（1倍或2倍），因此当实例数据部分没有对齐时，就需要通过这部分来补齐。</li></ol><h3 id="对象访问："><a href="#对象访问：" class="headerlink" title="对象访问："></a>对象访问：</h3><p></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>String对象的intern()方法。</title>
    <link href="/2018/04/22/JVM/String%E5%AF%B9%E8%B1%A1%E7%9A%84intern()%E6%96%B9%E6%B3%95%E3%80%82/"/>
    <url>/2018/04/22/JVM/String%E5%AF%B9%E8%B1%A1%E7%9A%84intern()%E6%96%B9%E6%B3%95%E3%80%82/</url>
    
    <content type="html"><![CDATA[<p>该方法与JVM的运行时常量池有关，运行时常量池是JVM方法区的一部分。</p><ol><li><code>new String()</code>和<code>new String(“”)</code>都是申明一个新的空字符串，是空串不是null。</li><li><code>String a=&quot;你好&quot;;</code>在编译期确定字符串内容，放入常量池。</li><li><code>String a=new String(&quot;你好&quot;)</code>和<code>String a=&quot;你&quot;+new String(&quot;好&quot;)</code>是到了程序运行期，调用了String的构造函数了才能确定字符串内容的，不能放入常量池。</li><li><pre><code>String a=new String(&quot;abc&quot;);String b=a.intern();//引用a依然指向堆内存中的对象。//但是返回的对象赋值给b，那么引用b指向了新的对象：常量池中唯一的代表&quot;abc&quot;的对象。System.out.println(a==b);//false</code></pre></li><li>jdk 7之后讲常量池从方法区移动到了堆。常量池中不需要再存储一份新的对象了，可以直接存储堆中的引用。<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java运行时数据区</title>
    <link href="/2018/04/22/JVM/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    <url>/2018/04/22/JVM/java%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/</url>
    
    <content type="html"><![CDATA[<p>读《深入理解Java虚拟机》读书笔记<br><img src="https://upload-images.jianshu.io/upload_images/7177220-356870d534d67272.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><h3 id="程序计数器："><a href="#程序计数器：" class="headerlink" title="程序计数器："></a>程序计数器：</h3><ul><li>为了保证程序能够连续地执行下去，处理器必须具有某些手段来确定下一条指令的地址，而程序计数器正是起到这种作用。</li><li>用来记录当前线程所执行的字节码的行号。字节码解释器的工作就是通过改变程序计数器来选取下一条需要执行的字节码指令（分支，循环，跳转，异常，线程恢复等）。</li><li>JVM的多线程是通过线程轮流切换并分配处理器执行时间来实现的。在一个确定时刻，一个处理器都只会执行一条线程中的指令。因此为了线程切换后能恢复到正确执行位置，每条线程需要一个<strong>独立的程序计数器</strong>，各条线程之间计数器互不影响，独立存储。因此程序计数器的内存区域是<strong>线程私有</strong>的内存。</li></ul><h3 id="Java虚拟机栈："><a href="#Java虚拟机栈：" class="headerlink" title="Java虚拟机栈："></a>Java虚拟机栈：</h3><ul><li>线程私有的，生命周期和线程相同。他描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈桢用于存储局部变量表，操作数栈，动态链接，方法出口等信息。</li><li>每个方法从调用到执行完成，就对应一个栈桢在虚拟机栈中从入栈到出栈。</li><li>平时所泛指的内存中的“堆和栈”里的栈指的就是这部分，或者说是虚拟机栈中的局部变量表的部分。</li><li>局部变量表存放了编译期可知的：基本数据类型，引用数据类型（其实就是对象的内存地址的指针）和returnAddress类型（指向了一条字节码指令的地址）。</li><li>局部变量表所需的内存空间在编译器完成分配，当进入一个方法时，这个方法需要在桢中分配多大的局部变量控件是确定的。在方法运行期间不会改变局部变量表的大小。</li><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；如果虚拟机可以动态扩展，但是扩展时无法申请到足够的内存，抛出OutOfMemoryError。</li></ul><h3 id="本地方法栈："><a href="#本地方法栈：" class="headerlink" title="本地方法栈："></a>本地方法栈：</h3><ul><li>作用和本地方法栈类似，区别在于虚拟机栈为虚拟机执行Java方法服务，而本地方法栈为虚拟机使用到的Native方法服务。</li></ul><h3 id="Java堆："><a href="#Java堆：" class="headerlink" title="Java堆："></a>Java堆：</h3><ul><li>被所有线程共享的一块内存区域。</li><li>词内存区的唯一目的：存放所有的对象实例和数组。</li><li>Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError。</li></ul><h3 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h3><ul><li>各个线程共享的内存区域，用于存储：已被虚拟机加载的<strong>类信息，常量，静态变量，即时编译器编译后的代码</strong>等。</li><li>垃圾收集行为在该区域比较少出现</li><li>这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载。</li><li>当方法区无法满足内存分配需求时，将抛出OutOfMemoryError。</li></ul><h3 id="运行时常量池："><a href="#运行时常量池：" class="headerlink" title="运行时常量池："></a>运行时常量池：</h3><ul><li>Class文件中除了类的版本，字段，方法，接口等描述信息外，还有一项信息是常量池。</li><li>在编译器确定，在类加载后进入方法区的运行时常量池</li><li>并不一定只有编译器才能产生，运行期也可以将新的常量放入池中，比如String类对象的Intern()方法。</li><li>当常量池无法申请到内存时会抛出OutOfMemoryError（jdk7之后，常量池从方法区被移动到堆区，调用String#intern方法时，如果存在堆中的对象，会直接保存对象的引用，而不会重新创建对象。）</li></ul><h3 id="直接内存："><a href="#直接内存：" class="headerlink" title="直接内存："></a>直接内存：</h3><ul><li>不属于虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。但是这部分内存也会被频繁使用，并且可能报OOM。</li><li>JDK1.4后引入了NIO类：使用Native函数直接分配堆外内存，然后通过一个存储在java堆中的DirectByteBuffer对象作为这块堆内存的引用进行操作。这样能在一些场景中提高性能，因为避免了在JAVA堆和Native堆中来回复制数据。</li><li>直接内存不会受到Java堆大小的限制，但是会受到本机总内存（RAM等）大小和处理器寻址空间的限制。有时在配置-Xmx时因为忽略了直接内存，导致服务器各个内存区域总和大于物理内存限制，从而导致动态拓展时出现OOM。</li></ul><p></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java虚拟机是什么？</title>
    <link href="/2018/04/22/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2018/04/22/JVM/Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>一句话解释：它是一种基于下层的操作系统和硬件平台并利用<strong>软件方法</strong>来实现的抽象的计算机，可以在上面执行java的字节码程序。</p><p>JVM是Java程序运行的容器,但是他同时也是操作系统的一个进程,因此他也有他自己的运行的生命周期,也有自己的代码和数据空间。</p><p>JVM在整个jdk中处于最底层,负责与操作系统的交互,用来屏蔽操作系统环境,提供一个完整的Java运行环境,因此也叫虚拟计算机。</p><p>如果把Java原程序想象成我们的C++原程序，Java原程序编译后生成的字节码就相当于C++原程序编译后的80x86的<a href="https://baike.baidu.com/item/%E6%9C%BA%E5%99%A8%E7%A0%81" target="_blank" rel="noopener">机器码</a>（二进制<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6" target="_blank" rel="noopener">程序文件</a>），JVM<a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E6%9C%BA" target="_blank" rel="noopener">虚拟机</a>相当于80x86计算机系统，Java<a href="https://baike.baidu.com/item/%E8%A7%A3%E9%87%8A%E5%99%A8" target="_blank" rel="noopener">解释器</a>相当于80x86CPU。在80x86CPU上运行的是机器码，在Java解释器上运行的是Java字节码。Java解释器相当于运行Java<a href="https://baike.baidu.com/item/%E5%AD%97%E8%8A%82%E7%A0%81" target="_blank" rel="noopener">字节码</a>的“CPU”，但该“CPU”不是通过硬件实现的，而是用软件实现的。Java解释器实际上就是特定的平台下的一个应用程序。只要实现了特定平台下的解释器程序，Java字节码就能通过解释器程序在该平台下运行，这是Java跨平台的根本。当前，并不是在所有的平台下都有相应Java解释器程序，这也是Java并不能在所有的平台下都能运行的原因，它只能在已实现了Java解释器程序的平台下运行。<br></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Sat Apr 21 2018 00:00:00 GMT+0000 (Coordinated Universal Time)</title>
    <link href="/2018/04/21/%E6%97%A5%E8%AE%B0%E6%9C%AC/2018-04-21/"/>
    <url>/2018/04/21/%E6%97%A5%E8%AE%B0%E6%9C%AC/2018-04-21/</url>
    
    <content type="html"><![CDATA[<p>今天晚上做了虎牙的安卓的线上笔试，前面选择题都还好，问的算法都不算难，也考了一些计算机网络的问题，好在之前也了解过计算机网络的东西，但是了解的不是很详细，也没有自己写总结，导致当时看的东西现在又忘了，回头还是要找机会把网络的知识补回来。第二大题三个算法题全崩了，一个都不会，真是感叹啊，之前学的几个排序算法一个都用不上，真心不喜欢算法这一块的内容，不过以后还是慢慢地想办法补起来吧。<br>今天是4月21号了，还有两个月就要暑假了，目前还不知道暑假我能去哪里去实习，如果我很厉害的话，早就可以找到实习了。唉…<br>我还欠缺好多必要的东西啊。比如数据结构，树的一些算法，java集合也只懂ArrayList和LinkedList，hashMap稍微了解一些，但是也没有详细地去看过源码，真的是惭愧。java的JVM的内容我也不懂，android项目经验也很欠缺，明明网上也有那么多接口，自己是可以做的。<br>接下来的两个月日子里，可不能再松懈怠慢了，要好好学习，好好花时间钻研这些东西。<br>先列一个待学习列表吧，然后按照顺序一个一个去学好来。</p><ol><li>JVM深入的细节，面试稍微深入都会问到这方面，内存管理，gc这些的。不要停留在表面，要深入去理解，然后做笔记，记录。</li><li>树的排序算法，动手去实现，动手去解决，这都是基本的东西，面试肯定会问。</li><li>java集合类每一个的源码都去学习，先自己看，不懂就找网上的博客来看，弄懂来。</li><li>多做几个项目，上github上面去看别人的项目是怎么做的，先模仿着做几个，理解一下思路，再自己做。<br></li></ol>]]></content>
    
    
    <categories>
      
      <category>日记本</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>基本的sql语句</title>
    <link href="/2018/04/21/Android/%E5%9F%BA%E6%9C%AC%E7%9A%84sql%E8%AF%AD%E5%8F%A5/"/>
    <url>/2018/04/21/Android/%E5%9F%BA%E6%9C%AC%E7%9A%84sql%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>我没学过数据库，但是作为一个程序员得了解一些基本的语句，以下为来自网站<a href="https://www.codecademy.com/learn/learn-sql的学习笔记" target="_blank" rel="noopener">https://www.codecademy.com/learn/learn-sql的学习笔记</a></p><p>数据库4中数据类型：INTEGER(整型), TEXT(字符串类型),DATA(日期),REAL(浮点型)。</p><p>查询整张表：</p><pre><code class="sql">SELECT * FROM &lt;表名&gt;;</code></pre><p>创建表：</p><pre><code class="sql">CREATE TABLE table_name (   (列名) (数据类型),    column_2 data_type &lt;限制符&gt; &lt;限制符&gt; ...,    column_3 data_type);//**限制符是在创建表的时候规定的某一列的信息。有如下几类：1.PRIMARY KEY：表示这是主键，一张表只能有一个主键，当插入的row的主键在表中已经存在时，将无法将这条数据插入。2.UNIQUE:这一列的每一行的值都将不同，有点类似主键，唯一区别是一张表可以有多个UNIQUE列。3.NOT NULL:这一列必须有值，否则无法插入4.DEFAULT &lt;default_value&gt;:如果新的row没有给这一列赋值，当插入之后这一列会赋上一个默认值&lt;defalut_value&gt;。**//</code></pre><p>插入一行数据：</p><pre><code class="sql">INSERT INTO &lt;table_name&gt; (column1,column2,column3...) VALUES (value1,value2,value3...);</code></pre><p>查询：</p><pre><code class="sql">//查询表中的某一列数据：SELECT &lt;column_name&gt; FROM &lt;table_name&gt;;//查询表中的多列数据：SELECT &lt;column_1&gt;,&lt;column_2&gt;... FROM &lt;table_name&gt;;//查询表中的某列数据并以化名作为列名返回（table中的列名不会更改）SELECT &lt;某一列名&gt; AS &#39;化名&#39; FROM &lt;table_name&gt;;// DISTINCT关键字：过滤掉重复的值。SELECT DISTINCT &lt;column_name&gt; FROM &lt;table_name&gt;;//Where条件查询，条件语句的操作符包括：=, ！=, &gt;, &lt;, &gt;=, &lt;=SELECT &lt;column_name&gt; FROM &lt;table_name&gt; WHERE &lt;条件语句&gt;//LIKE//从表movies中选出name中&quot;_&quot;部分可以为任意一个字符的值。&quot;_&quot;是通配符SELECT * FROM movies WHERE name LIKE &#39;Se_en&#39;;</code></pre><p>更新：</p><pre><code class="sql">//在column_y=b的地方将column_x的值更新为a。//比如：UPDATE celebs SET age = 22 WHERE id = 1;UPDATE &lt;table_name&gt; SET &lt;column_x&gt;=a WHERE &lt;column_y&gt;=b;</code></pre><p>为表添加新的列：</p><pre><code class="sql">ALTER TABLE &lt;table_name&gt; ADD COLUMN &lt;column_name&gt; &lt;type&gt;;</code></pre><p>删除选中的行：</p><pre><code class="sql">//删除是所有column_name是Null的行。DELETE FROM &lt;table_name&gt; WHERE &lt;column_name&gt; IS NULL;</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Broadcast的细节</title>
    <link href="/2018/04/16/Android/Broadcast%E7%9A%84%E7%BB%86%E8%8A%82/"/>
    <url>/2018/04/16/Android/Broadcast%E7%9A%84%E7%BB%86%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<ol><li>通过Manifest文件注册的BroadcastReceiver<ol><li>当发送广播时，不能用LocalBroadcastManager（接收器会接收不到那条广播）。</li><li>不能在任何地方调用context.unregisterReceiver();否则报异常：java.lang.RuntimeException: Unable to start receiver com.solory.myapplication.MyLocalBroadcastReceiver: java.lang.IllegalArgumentException: Receiver not registered: com.solory.myapplication.MyLocalBroadcastReceiver@4a800704。</li><li>用Manifest文件注册的接收器就是全局性质的。</li></ol></li><li>通过context对象来注册的BroadcastReceiver。<ol><li>用context.registerReceiver注册，但是用LocalBroadcastManager发送，会导致接收不到广播。</li><li>用LocalBroadcastManager注册，用context注册，接受不到广播</li><li>要用本地广播的话，注册和发送都要用LocalBroadcastManager。</li><li>在onReceive里面开启一个工作线程，Activity在onCreate里面注册接收器，在onDestroy里面解绑接收器。此时退出Activity是结束不了onReceive里面的工作的（因为此时该进程有两个组件，组件Activity被销毁，但是组件BroadcastReceiver还在运行），除非外部手动强制结束该进程，或者系统因为内存紧张，需要强制结束掉该BroadcastReceiver组件（因为和Receiver关联的前台组件已退出，那么Receiver此时位于后台，优先级较低，系统会因为内存紧张而杀死该组件）。</li><li>当执行onReceive()的时候，Receiver被当作一个前台进程，在onReceive()内，该进程是不会被自动清理的，但是如果onRecive中开启了工作线程，onReceive返回后，线程依然执行，但是此时接收器所在进程的优先级就可能在后台（比如换到另一个Activity），那么虽然有线程在工作，但是若内存紧张，还是会将进程结束。因此不建议在onReceive中开启工作线程。如果非要用就用goAsyc()或者JobService,详情见官网。</li><li>官方文档说：本地广播可以在您的应用程序中用作通用的发布/订阅事件总线，而无需系统广播的任何开销。<br></li></ol></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Broadcast全解</title>
    <link href="/2018/04/16/Android/Broadcast%E5%85%A8%E8%A7%A3/"/>
    <url>/2018/04/16/Android/Broadcast%E5%85%A8%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>Android系统的app可以从系统或者其他app发送或者接受广播消息。类似于(发布-订阅模式)。</p><p>app可以注册来接收特定的广播。当一条广播被发送时，系统自动地将这条广播引导到已经注册来接收那类广播的app。</p><p>一般来说，广播可以被用作跨应用的和正常用户流程之外的通信系统。</p><h3 id="接收广播"><a href="#接收广播" class="headerlink" title="接收广播"></a>接收广播</h3><p>app可以通过两种方法来注册接受广播：</p><ol><li><p>manifest文件中注册</p><pre><code class="xml">&lt;receiver android:name=&quot;.MyBroadcastReceiver&quot;  android:exported=&quot;true&quot;&gt;        &lt;intent-filter&gt;            &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot;/&gt;            &lt;action android:name=&quot;android.intent.action.INPUT_METHOD_CHANGED&quot; /&gt;        &lt;/intent-filter&gt;    &lt;/receiver&gt;</code></pre><p> <code>intent-filters指明了这个receiver订阅的broadcast actions</code></p><ul><li><p>继承BroadcastReceiver并重写onReceive(Context context,Intent intent);</p><pre><code class="java">  public class MyBroadcastReceiver extends BroadcastReceiver {          private static final String TAG = &quot;MyBroadcastReceiver&quot;;          @Override          public void onReceive(Context context, Intent intent) {              StringBuilder sb = new StringBuilder();              sb.append(&quot;Action: &quot; + intent.getAction() + &quot;\n&quot;);              sb.append(&quot;URI: &quot; + intent.toUri(Intent.URI_INTENT_SCHEME).toString() + &quot;\n&quot;);              String log = sb.toString();              Log.d(TAG, log);              Toast.makeText(context, log, Toast.LENGTH_LONG).show();          }      }</code></pre><p>  当接收到广播时，接收器的onReceive会被调用，广播就封装在第二个参数Intent中。</p><hr><p>  系统的包管理器在安装应用程序时注册这个接收器。接收就成为了这个应用程序的独立入口，这意味着系统可以启动该应用程序并在这个app还未运行时传送广播。<br>  系统创建一个新的BroadcastReceiver组件对象来处理它收到的每个广播。此对象仅在调用onReceive(Context, Intent)期间有效。一旦代码从此方法返回，系统会认为该组件不再处于活动状态。</p></li></ul></li><li><p>context中注册。</p><ol><li>创建BroadcastReceiver对象。：<pre><code class="java"> BroadcastReceiver br = new MyBroadcastReceiver();</code></pre></li><li>创建一个IntentFilter对象，然后通过调用context对象的registerReceiver(BroadcastReceiver , IntentFilter)来注册接收器。<pre><code class="java"> IntentFilter filter = new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION); filter.addAction(Intent.ACTION_AIRPLANE_MODE_CHANGED); this.registerReceiver(br, filter);</code></pre></li><li>注意：如果要为本地广播接收器注册，应该调用<code>LocalBroadcastManager.registerReceiver(BroadcastReceiver,IntentFilter)</code>;<br> 与发送一条全局广播相比（系统内的所有应用都可能接收到），本地广播的优势：<ol><li>你的广播数据不会离开你的app,不用担心隐私问题</li><li>注册的是本地Receiver，别的app不可能给你发送广播了</li><li>相比全局广播，本地广播的sendBroadcast效率更高。</li></ol></li><li>context注册的Receiver的的生命周期：只要那个context对象一直有效，就一直可以接受广播。比如用Activity注册的，只要activity没有destroyed，Receiver一直有效。用Application的context注册的，只要app还在跑，Receiver就一直有效。</li></ol></li></ol><hr><p>由于本篇文章本来就是从官方文档学习的，下午看到了一篇翻译的也不错，因此后续内容不接着写了，看这里就行：<br><a href="http://www.passershowe.com/2017/04/05/Android-BroadcastReceiver/" target="_blank" rel="noopener">http://www.passershowe.com/2017/04/05/Android-BroadcastReceiver/</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线性查找,递归,二分查找,选择排序,插入排序,归并,快排</title>
    <link href="/2018/04/13/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE,%E9%80%92%E5%BD%92,%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE,%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F,%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F,%E5%BD%92%E5%B9%B6,%E5%BF%AB%E6%8E%92/"/>
    <url>/2018/04/13/%E7%AE%97%E6%B3%95/%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE,%E9%80%92%E5%BD%92,%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE,%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F,%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F,%E5%BD%92%E5%B9%B6,%E5%BF%AB%E6%8E%92/</url>
    
    <content type="html"><![CDATA[<p>阅读&lt;&lt;算法基础&gt;&gt;做下的笔记</p><pre><code class="java">public class Algorithms {    private Algorithms() {    }    public static Algorithms getInstance() {        return SingletonHolder.instance;    }    private static class SingletonHolder {        private static final Algorithms instance = new Algorithms();    }    /**     * 线性查找     *     * @param arrays 被查找的数组     * @param count  查找多少个，比如输入3，就只查找数组中对应下标0,1,2的三个元素     * @param data   要查找的值     * @param &lt;T&gt;    泛型T     * @return 如果找到了，返回最后一次出现的下标；如果没找到，返回-1。     */    public &lt;T&gt; int linearSearch(T[] arrays, int count, T data) {        int result = -1;        for (int i = 0; i &lt; count - 1; i++) {            if (data.equals(arrays[i])) {                result = i;            }        }        return result;    }    //与上面的方法的区别：在循环体内若找到了data，直接返回第一个找到的下标。    public &lt;T&gt; int betterLinearSearch(T[] arrays, int count, T data) {        int result = -1;        for (int i = 0; i &lt; count - 1; i++) {            if (arrays[i].equals(data)) {                return i;            }        }        return result;    }    /**     * 相比上面两个算法，该算法效率更高，因为：     * 上面用for循环时，除了循环体中的判断，还要进行for循环条件的i&lt;count-1的判断；循环做两次判断。     * 该算法的while循环，只有循环条件的判断；循环做一次判断     *     * @param arrays 同上     * @param count  同上     * @param data   同上     * @param &lt;T&gt;    同上     * @return 同上     */    public &lt;T&gt; int sentinelLinearSearch(T[] arrays, int count, T data) {        //lastIndex是要查找的最后一个元素的下标，如果输入的查找个数count&gt;数组元素个数，        // 赋值其为数组最末尾下标，反之赋值count-1。        int lastIndex = count &gt; arrays.length ? arrays.length - 1 : count - 1;        //保存要查找的最末尾的值        T lastData = arrays[lastIndex];        //将要查找的最末尾的值赋值为data（为了while循环最后可以退出）（后面再还原）        arrays[lastIndex] = data;        int i = 0;        //如果data不等于数组从0开始的元素，i自增        while (!data.equals(arrays[i])) {            i++;        }        //将先前改变的数组末尾的值还原        arrays[lastIndex] = lastData;        //如果i&lt;lastIndex，说明while循环中匹配到了。如果data等于此时array末尾元素，说明也匹配到了        if (i &lt; lastIndex || data.equals(arrays[lastIndex])) {            return i;        } else {            return -1;        }    }    /**     * factorial.n : 递归     * 递归的两个特性：     * 1、必须有一个或多个不用递归而直接计算出结果的基础情况。     * 2、每个递归调用最终能迭代到基础情况。     *     * @param n     * @return     */    public int factorial(int n) {        if (n == 0) {            return 1;        } else {            return n * factorial(n - 1);        }    }    //错误，递归迭代不到基础情况    @Deprecated    public int badFactorial(int n) {        if (n == 0) {            return 1;        } else {            return badFactorial(n + 1) / (n + 1);        }    }    /**     * 递归线性查找     * 基础情况是第一个if语句和第一个else if语句，else语句进行递归     * 最后要么到第一个基础情况结束，要么第二个基础情况结束。     *     * @param array 被查找的数组     * @param start 开始下标     * @param end   结束下标     * @param data  要查找的元素     * @param &lt;T&gt;   泛型     * @return 如果找到，返回找到的第一个元素的下标；否则返回-1     */    public &lt;T&gt; int recursiveLinearSearch(T[] array, int start, int end, T data) {        if (start &gt; end) {            return -1;        } else if (data.equals(array[start])) {            return start;        } else {//!data.equals(array[start])            return recursiveLinearSearch(array, start + 1, end, data);        }    }    /**     * 二分查找（while循环）     *     * @param array 从小到大排序的有序数组     * @param end   要查找的终点     * @param data  要查找的数据     * @param &lt;T&gt;   实现了Comparable接口的类型     * @return 找到返回找到的下标，否则返回-1。     */    public &lt;T extends Comparable&lt;T&gt;&gt; int binarySearch(T[] array, int end, T data) {        if (end &gt; array.length - 1) {            //如果end超出数组边界            end = array.length - 1;        }        int start = 0;        while (start &lt; end) {            int middle = (start + end) / 2;            int compareResult = data.compareTo(array[middle]);            if (compareResult == 0) {                return middle;            } else if (compareResult &lt; 0) {                end = middle - 1;            } else {                start = middle + 1;            }        }        return -1;    }    /**     * 二分查找（递归）     *     * @param array 从小到大排序的有序数组     * @param start 起点     * @param end   终点     * @param data  要查找的数据     * @param &lt;T&gt;   实现了Comparable接口的类型     * @return 同上     */    public &lt;T extends Comparable&lt;T&gt;&gt; int recursiveBinarySearch(T[] array, int start, int end, T data) {        if (end &gt; array.length - 1) {//如果end超出数组边界            end = array.length - 1;        }        if (start &lt; 0) {//如果start超出数组边界            start = 0;        }        if (start &gt; end) {            return -1;        } else {            int middle = (start + end) / 2;            int compareResult = data.compareTo(array[middle]);            if (compareResult == 0) {                return middle;            } else if (compareResult &lt; 0) {                return recursiveBinarySearch(array, start, middle - 1, data);            } else {//compareResult&gt;0                return recursiveBinarySearch(array, middle + 1, end, data);            }        }    }    /**     * 选择排序法     *     * @param array     * @return     */    public int[] selectionSort(int[] array) {        for (int i = 0; i &lt; array.length - 1; i++) {            int temp = array[i];            int minIndex = i;            //查找最小值的外部的变量minValue。            int minValue = array[i];            for (int j = i + 1; j &lt; array.length; j++) {                if (array[j] &lt; minValue) {                    minValue = array[j];//一定要在这里将array[j]记录下来，赋值给minValue                    minIndex = j;                }            }            if (minIndex != i) {                array[i] = array[minIndex];                array[minIndex] = temp;            }        }        return array;    }    private int findMin(int[] array, int start, int end) {        int min = array[start];        int index = start;        for (int i = start + 1; i &lt; end; i++) {            if (array[i] &lt; min) {                index = i;                min = array[i];            }        }        return index;    }    public int[] anotherSelectionSort(int[] array) {        for (int i = 0, len = array.length; i &lt; len - 1; i++) {            int temp = array[i];            int min = findMin(array, i, len);            array[i] = array[min];            array[min] = temp;        }        return array;    }    /**     * 插入排序     *     * @param array    插入排序的数组     * @param endIndex 排序的最后的下标     */    public void insertionSort(int[] array, int endIndex) {        for (int i = 1; i &lt;= endIndex; i++) {            //由于下方while循环的第一次迭代会覆盖array[i],所以必须讲array[i]保存在key中            int key = array[i];            int j = i - 1;            while (j &gt;= 0 &amp;&amp; key &lt; array[j]) {//如果j没有越界，并且在前面找到比自己小的array[j]                //把array[j]往后移动一个位置                array[j + 1] = array[j];                //自己递减，以便下次循环接着往前找                j--;            }            //最后将key放到挪开的那个空的位置上去            array[j + 1] = key;        }    }    /**     * 归并排序法     *     * @param array 要被归并排序的数组     * @param p     previous,起点下标     * @param r     rear,终点下标     */    public void mergeSort(int[] array, int p, int r) {        if (p &gt;= r) {//如果起点大于等于终点,说明递归到了基础情况,返回.            return;        } else {            int q = (p + r) / 2;//取中间的那个数            //分成两部分来递归,注意!mergeSort()执行完,就说明排好一次序,            // 因此merge()方法总能拿到数组内部两截排序好的情况.            mergeSort(array, p, q);//前半截            mergeSort(array, q + 1, r);//后半截            //递归到最小的基础情况,开始归并排序.            merge(array, p, q, r);        }    }    /**     * 真正执行归并的算法     * 有点复杂,忘了的话还是看书回忆原理.     * &lt;p&gt;     * 传入的数组分为两截,从p到q和q+1到r,都是有序的.(如果两截都只有一个元素也成为两部分各自是有序的)     * 将这两部分有序数组分别拷贝到两个新的数组中,因为是有序的,从下标0开始循环递归比较两个新的数组.     * 较小的那个放入array中,依次递归下去,最后将生成新的有序的array.     * &lt;p&gt;     * &quot;哨兵&quot;处理的思路:     * 两个新拷贝的数组b,c一定率先有一方全部&quot;出队&quot;,并且游标自增,     * 那么下一轮的判断条件就会造成数组越界(游标自增到了数组外面),     * 新的做法是给数组b,c额外多申请一个空间,放入MAX值.     * 那么当b或c中有意义的元素全部出队之后,游标到了哨兵的位置,且此时不会数组越界.     * 因为哨兵是MaxValue,所以下一轮以及之后的所有比较,都会让另一个数组出队,直到有意义的元素全部出队.     * k=r,排序结束.     *     * @param array 要归并排序的数组     * @param p     起点下标     * @param q     中点下标     * @param r     终点下标     */    private void merge(int[] array, int p, int q, int r) {        int n1 = q - p + 1;//新数组b的长度        int n2 = r - q;//新数组c的长度        int[] b = new int[n1 + 1];//用于拷贝,为了下面的操作不用每次判断是否数组越界,额外地多申请一个地址,用&quot;哨兵&quot;技巧,所以n1+1.        int[] c = new int[n2 + 1];//用于拷贝,同上        /*关于为什么要拷贝出新的数组而不在原址上操作,是因为在上原址操作更加麻烦,性能更差,详见&lt;&lt;算法基础&gt;&gt;page.44*/        for (int i = 0, len = b.length; i &lt; len - 1; i++) {            b[i] = array[p + i];//拷贝        }        for (int i = 0, len = c.length; i &lt; len - 1; i++) {            c[i] = array[q + 1 + i];//拷贝        }        //将两个数组最末尾的元素设成最大值,做&quot;哨兵&quot;.        b[n1] = Integer.MAX_VALUE;        c[n2] = Integer.MAX_VALUE;        int i = 0, j = 0;//i是数组b的开始下标,j是数组c的开始下标.        for (int k = p; k &lt;= r; k++) {//开始排序,k是原数组array的开始下标,从p取到r.            if (b[i] &lt;= c[j]) {                array[k] = b[i];                i++;            } else {                array[k] = c[j];                j++;            }        }    }    /**     * 快速排序法     *     * @param array 快排数组     * @param p     起点下标     * @param r     终点下标     */    public void quickSort(int[] array, int p, int r) {        if (p &gt;= r) {            //基础情况,数组为空,返回            return;        } else {            //将数组划分成各自无序的left组和right组两部分，但是left组全部小于right组。            //q就是分界线。            int q = partition(array, p, r);            quickSort(array, p, q - 1);//递归下去，让left组也这样分            quickSort(array, q + 1, r);//递归下去，让right组也这样分            //最后结果是数组只有两个元素，一个left一个right，接着递归下去就是基础情况，return。        }    }    /**     * 划分     * 结果：     * 将传入的数组划分成left和right两组     * 选择array[r]作为主元，小于array[r]的都进入left组，大于array[r]的都进入right组。     * 最后q作为分界线返回。     *     * 变量说明：     * 将数组array分成四部分：left组，right组，unknown组，主元r。     * left组全部小于主元且无序，right全部大于主元且无序，unknown组是待排序的元素的组。     *     * 算法中有四个指针p,r,q,u。     * 其中q和u会变动。     * q是指向right组的第一个元素，u组指向unknown组的第一个元素。     *     * @param array 要划分的数组     * @param p 起点下标     * @param r 终点下标     * @return 返回分界线指针（也就是主元）的下标。     */    private int partition(int[] array, int p, int r) {        int q = p;//q指向right组的第一个元素        for (int u = p; u &lt; r; u++) {//u指向unknown组的第一个元素            if (array[u] &lt;= array[r]) {//如果未知元素小于主元                //那么让right组的第一个元素和unknown交换                int temp = array[q];                array[q] = array[u];                array[u] = temp;                //q++,让q继续正确指向right组第一个元素                q++;                //这样就让unknown组较小的元素放到了right组左边,即Left组            }//else{                //就是array[u]&gt;array[r]                //那么就是u++,让unknown指针后移,刚好把对应元素放进了right组.            // }        }        //最后让主元和right组第一个元素互换即可        //(主元到达分割线位置,原位置的元素依然在right组,只是跑到最后去了 )        int temp = array[q];        array[q] = array[r];        array[r] = temp;        return q;    }}</code></pre><p>快排的partision的指针图示：<br><img src="https://upload-images.jianshu.io/upload_images/7177220-4bb073f1082d2330.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>的类型<br>     * @return 找到返回找到的下标，否则返回-1。<br>     */<br>    public &lt;T extends Comparable<T>&gt; int binarySearch(T[] array, int end, T data) {<br>        if (end &gt; array.length - 1) {<br>            //如果end超出数组边界<br>            end = array.length - 1;<br>        }</p><pre><code>    int start = 0;    while (start &lt; end) {        int middle = (start + end) / 2;        int compareResult = data.compareTo(array[middle]);        if (compareResult == 0) {            return middle;        } else if (compareResult &lt; 0) {            end = middle - 1;        } else {            start = middle + 1;        }    }    return -1;}/** * 二分查找（递归） * * @param array 从小到大排序的有序数组 * @param start 起点 * @param end   终点 * @param data  要查找的数据 * @param &lt;T&gt;   实现了Comparable接口的类型 * @return 同上 */public &lt;T extends Comparable&lt;T&gt;&gt; int recursiveBinarySearch(T[] array, int start, int end, T data) {    if (end &gt; array.length - 1) {//如果end超出数组边界        end = array.length - 1;    }    if (start &lt; 0) {//如果start超出数组边界        start = 0;    }    if (start &gt; end) {        return -1;    } else {        int middle = (start + end) / 2;        int compareResult = data.compareTo(array[middle]);        if (compareResult == 0) {            return middle;        } else if (compareResult &lt; 0) {            return recursiveBinarySearch(array, start, middle - 1, data);        } else {//compareResult&gt;0            return recursiveBinarySearch(array, middle + 1, end, data);        }    }}/** * 选择排序法 * * @param array * @return */public int[] selectionSort(int[] array) {    for (int i = 0; i &lt; array.length - 1; i++) {        int temp = array[i];        int minIndex = i;        //查找最小值的外部的变量minValue。        int minValue = array[i];        for (int j = i + 1; j &lt; array.length; j++) {            if (array[j] &lt; minValue) {                minValue = array[j];//一定要在这里将array[j]记录下来，赋值给minValue                minIndex = j;            }        }        if (minIndex != i) {            array[i] = array[minIndex];            array[minIndex] = temp;        }    }    return array;}private int findMin(int[] array, int start, int end) {    int min = array[start];    int index = start;    for (int i = start + 1; i &lt; end; i++) {        if (array[i] &lt; min) {            index = i;            min = array[i];        }    }    return index;}public int[] anotherSelectionSort(int[] array) {    for (int i = 0, len = array.length; i &lt; len - 1; i++) {        int temp = array[i];        int min = findMin(array, i, len);        array[i] = array[min];        array[min] = temp;    }    return array;}/** * 插入排序 * * @param array    插入排序的数组 * @param endIndex 排序的最后的下标 */public void insertionSort(int[] array, int endIndex) {    for (int i = 1; i &lt;= endIndex; i++) {        //由于下方while循环的第一次迭代会覆盖array[i],所以必须讲array[i]保存在key中        int key = array[i];        int j = i - 1;        while (j &gt;= 0 &amp;&amp; key &lt; array[j]) {//如果j没有越界，并且在前面找到比自己小的array[j]            //把array[j]往后移动一个位置            array[j + 1] = array[j];            //自己递减，以便下次循环接着往前找            j--;        }        //最后将key放到挪开的那个空的位置上去        array[j + 1] = key;    }}/** * 归并排序法 * * @param array 要被归并排序的数组 * @param p     previous,起点下标 * @param r     rear,终点下标 */public void mergeSort(int[] array, int p, int r) {    if (p &gt;= r) {//如果起点大于等于终点,说明递归到了基础情况,返回.        return;    } else {        int q = (p + r) / 2;//取中间的那个数        //分成两部分来递归,注意!mergeSort()执行完,就说明排好一次序,        // 因此merge()方法总能拿到数组内部两截排序好的情况.        mergeSort(array, p, q);//前半截        mergeSort(array, q + 1, r);//后半截        //递归到最小的基础情况,开始归并排序.        merge(array, p, q, r);    }}/** * 真正执行归并的算法 * 有点复杂,忘了的话还是看书回忆原理. * &lt;p&gt; * 传入的数组分为两截,从p到q和q+1到r,都是有序的.(如果两截都只有一个元素也成为两部分各自是有序的) * 将这两部分有序数组分别拷贝到两个新的数组中,因为是有序的,从下标0开始循环递归比较两个新的数组. * 较小的那个放入array中,依次递归下去,最后将生成新的有序的array. * &lt;p&gt; * &quot;哨兵&quot;处理的思路: * 两个新拷贝的数组b,c一定率先有一方全部&quot;出队&quot;,并且游标自增, * 那么下一轮的判断条件就会造成数组越界(游标自增到了数组外面), * 新的做法是给数组b,c额外多申请一个空间,放入MAX值. * 那么当b或c中有意义的元素全部�</code></pre>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Comparable接口是什么</title>
    <link href="/2018/04/08/Java/Comparable%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <url>/2018/04/08/Java/Comparable%E6%8E%A5%E5%8F%A3%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    
    <content type="html"><![CDATA[<pre><code class="java">//Comparable接口：//实现了Comparable接口的类的对象，//可被Collections.sort(List)方法和Arrays.sort(Object[])方法自动地排序。//实现该接口的方法可以作为SortedMap的key//或者SortedSet中的element,但是需要额外地声名一个Comparatorpublic interface Comparable&lt;T&gt;{  public int compareTo(T o);}</code></pre><hr><p>Comparable是内部比较器，Comparator是外部比较器。</p><p>以下为Comparable和Comparator的测试程序：</p><pre><code class="java">import java.util.*;public class MainJava {    public static void main(String[] args) throws Exception {        ArrayList&lt;Person&gt; list=new ArrayList&lt;&gt;();        list.add(new Person(20,&quot;ccc&quot;));        list.add(new Person(30,&quot;AAA&quot;));        list.add(new Person(10,&quot;bbb&quot;));        list.add(new Person(40,&quot;ddd&quot;));        System.out.println(list);        Collections.sort(list);        System.out.println(list);        Collections.sort(list,new AscAgeComparator());        System.out.println(list);        Collections.sort(list,new DescAgeComparator());        System.out.println(list);    }    private static class Person implements Comparable&lt;Person&gt;{        public int age;        public String name;        public Person(int age, String name) {            this.age = age;            this.name = name;        }        @Override        public String toString() {            return name+&quot;-&quot;+ age;        }        boolean equals(Person person) {            return (this.age==person.age)&amp;&amp;this.name.equals(person.name);        }        @Override        public int compareTo(Person o) {            return this.name.compareTo(o.name);        }    }    private static class AscAgeComparator implements Comparator&lt;Person&gt;{        @Override        public int compare(Person o1, Person o2) {            return o1.age-o2.age;        }    }    private static class DescAgeComparator implements Comparator&lt;Person&gt;{        @Override        public int compare(Person o1, Person o2) {            return o2.age-o1.age;        }    }}</code></pre><p>打印：</p><pre><code>[ccc-20, AAA-30, bbb-10, ddd-40][AAA-30, bbb-10, ccc-20, ddd-40][bbb-10, ccc-20, AAA-30, ddd-40][ddd-40, AAA-30, ccc-20, bbb-10]Process finished with exit code 0</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>字符串中求出现次数最多字符</title>
    <link href="/2018/04/07/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%B1%82%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E5%AD%97%E7%AC%A6/"/>
    <url>/2018/04/07/%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%B1%82%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E6%9C%80%E5%A4%9A%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>思路：</p><ul><li>引入TreeSet：通过集合快速找到所有出现的字符串</li><li>引入ArrayList：为了快速排序，再通过StringBuilder生成排序后的字符串</li><li>通过String api中的基本方法indexOf和lastIndexOf来计算TreeSet中每个字符串的最大值</li><li>如果出现相同的，则把相同的都记录在一个列表中。</li><li>记录第一个出现次数最多的字符（为了计算多个字符串相同情况）</li><li>计算最大字符串列表中哪些才是真正出现次数最多的、</li></ul><pre><code class="java">import java.util.*;public class MainJava {    public static void main(String[] args) throws Exception {        String input = &quot;aavacadfdsfsdhshgWasdfasdfdddaaa&quot;;        System.out.println(&quot;the origin input is----&quot; + input);        new MainJava().doString(input);    }    public void doString(String input) {        char[] chars = input.toCharArray();        ArrayList&lt;String&gt; lists = new ArrayList&lt;&gt;();        TreeSet&lt;String&gt; set = new TreeSet&lt;&gt;();        for (int i = 0, length = chars.length; i &lt; length; i++) {            lists.add(String.valueOf(chars[i]));            set.add(String.valueOf(chars[i]));        }        System.out.println(set);        Collections.sort(lists);//将input字符串重排序        System.out.println(lists);        StringBuilder stringBuilder = new StringBuilder();        for (int i = 0, length = lists.size(); i &lt; length; i++) {            stringBuilder.append(lists.get(i));        }        input = stringBuilder.toString();        System.out.println(input);//打印重排序后的字符串        int max = 0;        String maxString = &quot;&quot;;        ArrayList&lt;String&gt; maxList = new ArrayList&lt;String&gt;();        Iterator it = set.iterator();//用Set的迭代器，刚好可以避免重复字符迭代的效率问题        while (it.hasNext()) {            String os = (String) it.next();            int begin = input.indexOf(os);//起始位置            int end = input.lastIndexOf(os);//结束位置            int value = end - begin + 1;//该字符一共多少个            if (value &gt; max) {                max = value;                maxString = os;                maxList.add(os);            } else if (value == max) {                //如果该字符刚好也是最大个数的字符，那么就添加进List记录就行。                maxList.add(os);            }        }        int index = 0;        for (int i = 0, len = maxList.size(); i &lt; len; i++) {            if (maxList.get(i).equals(maxString)) {                index = i;                break;            }        }        System.out.println(&quot;max data&quot;);        for (int i = index, len = maxList.size(); i &lt; len; i++) {            System.out.println(maxList.get(i) + &quot;&quot;);        }        System.out.println();        System.out.println(&quot;max&quot; + max);    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>hashCode是什么，hash表是什么？</title>
    <link href="/2018/04/07/Java/hashCode%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8Chash%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2018/04/07/Java/hashCode%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8Chash%E8%A1%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p> <a href="http://www.cnblogs.com/dolphin0520/p/3681042.html" target="_blank" rel="noopener">海子：浅谈Java中的hashcode方法</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java传值和传引用的真相</title>
    <link href="/2018/03/29/Java/Java%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E7%9C%9F%E7%9B%B8/"/>
    <url>/2018/03/29/Java/Java%E4%BC%A0%E5%80%BC%E5%92%8C%E4%BC%A0%E5%BC%95%E7%94%A8%E7%9A%84%E7%9C%9F%E7%9B%B8/</url>
    
    <content type="html"><![CDATA[<p><a href="http://zwmf.iteye.com/blog/1738574" target="_blank" rel="noopener">JAVA 对象引用，以及对象赋值</a></p><hr><p>上述文章可以作参考，但是最后总结说的，包括《thingking in Java》说的：“<code>不管是基本类型还是对象类型，都是传值</code>”。<br>我认为这句话会引起歧义，真正的真相是：不管Java参数的类型是什么，一律传递参数的副本。<br>《thingking in Java》中：“<code>When you&#39;re passing primitives into a method,you get a distinct copy of the primitive.When you&#39;re passing a reference into a method,you get a copy of the reference</code>”(如果Java是传值，那么传递的是值得副本；如果Java是传引用，那么传递的是引用的副本。)</p><p>注意，String类型也是对象型的变量，所以也是传引用的副本。</p><p><code>来自：《Java程序员面试宝典》</code><br></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于++x和x++</title>
    <link href="/2018/03/29/Java/%E5%85%B3%E4%BA%8E++x%E5%92%8Cx++/"/>
    <url>/2018/03/29/Java/%E5%85%B3%E4%BA%8E++x%E5%92%8Cx++/</url>
    
    <content type="html"><![CDATA[<pre><code class="java">public class MainJava {    public static void main(String[] args){        int a=5;        int b=a+ ++a;        System.out.println(b);        int c=5;        int d=c++ + ++c;        System.out.println(d);    }}</code></pre><p>打印：</p><pre><code>1112</code></pre><p>第二个打印结果是12是因为5+7。<br>首先c++，返回的是5，但是内存中已经改变了c的值，成了6，然后++c到内存中取回的是6，自增，返回7，所以是5+7=12。<br></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android图片下载过程控制-（开始，正在，结束，失败）</title>
    <link href="/2018/03/22/android%E5%9B%BE%E7%89%87/android%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6-%EF%BC%88%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%AD%A3%E5%9C%A8%EF%BC%8C%E7%BB%93%E6%9D%9F%EF%BC%8C%E5%A4%B1%E8%B4%A5%EF%BC%89/"/>
    <url>/2018/03/22/android%E5%9B%BE%E7%89%87/android%E5%9B%BE%E7%89%87%E4%B8%8B%E8%BD%BD%E8%BF%87%E7%A8%8B%E6%8E%A7%E5%88%B6-%EF%BC%88%E5%BC%80%E5%A7%8B%EF%BC%8C%E6%AD%A3%E5%9C%A8%EF%BC%8C%E7%BB%93%E6%9D%9F%EF%BC%8C%E5%A4%B1%E8%B4%A5%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<pre><code class="java">public class ImageDownloadControll {    private byte[] imageBytes;    private Handler handler=new Handler(){        @Override        public void handleMessage(Message msg) {            switch (msg.what){                case 0:                    Log.d(&quot;info&quot;,&quot;开始下载&quot;);                    break;                case 1:                    Log.d(&quot;info&quot;,&quot;正在下载&quot;);                    break;                case 2:                    Log.d(&quot;info&quot;,&quot;下载结束&quot;);                    break;                case 3:                    Log.d(&quot;info&quot;,&quot;下载失败&quot;);                    break;            }        }    };    public void download(ImageView imageView,String url){        try {            URL url1=new URL(url);            HttpURLConnection connection= (HttpURLConnection) url1.openConnection();            connection.setRequestMethod(&quot;GET&quot;);            connection.setReadTimeout(10*1000);            //开始下载            sendMessageByWhat(0);            InputStream is=connection.getInputStream();            ByteArrayOutputStream bos=new ByteArrayOutputStream();            byte[] bufferBytes=new byte[1024];            int length=-1;            while ((length=is.read(bufferBytes))!=-1){                //正在下载                sendMessageByWhat(1);                bos.write(bufferBytes,0,length);            }            imageBytes=bos.toByteArray();            sendMessageByWhat(2);            //下载结束            is.close();            bos.close();        } catch (IOException e) {            //下载失败            sendMessageByWhat(3);            e.printStackTrace();        }    }    private void sendMessageByWhat(int what){        Message msg=new Message();        msg.what=what;        handler.sendMessage(msg);    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>android图片</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android用线程池手动实现多图加载</title>
    <link href="/2018/03/22/android%E5%9B%BE%E7%89%87/android%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%9B%BE%E5%8A%A0%E8%BD%BD/"/>
    <url>/2018/03/22/android%E5%9B%BE%E7%89%87/android%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%9B%BE%E5%8A%A0%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<p>用一个固定大小为5的线程池来实现多图加载：</p><p>首先实现Runnble子类，下载图片：</p><pre><code class="java">/** * 进行图片下载任务 的线程 */public class ImageTask implements Runnable {    public ImageView imageView;    private String url;    private byte[] imageBytes;    private ImageTaskHandler handler;    public ImageTask(ImageView imageView, String url) {        this.imageView = imageView;        this.url = url;        handler = new ImageTaskHandler(this);    }    @Override    public void run() {        try {            URL url = new URL(this.url);            HttpURLConnection httpURLConnection = (HttpURLConnection) url.openConnection();            httpURLConnection.setRequestMethod(&quot;GET&quot;);            if (httpURLConnection.getResponseCode() == 200) {                InputStream is = httpURLConnection.getInputStream();                ByteArrayOutputStream bos = new ByteArrayOutputStream();                byte[] bytes = new byte[1024];                int length = -1;                while ((length = is.read(bytes)) != -1) {                    bos.write(bytes, 0, length);                }                imageBytes = bos.toByteArray();                Message msg = new Message();                msg.what = 0;                handler.sendMessage(msg);                bos.close();                is.close();            }        } catch (Exception e) {            Message msg = new Message();            msg.what = -1;            handler.sendMessage(msg);            e.printStackTrace();        }    }    public String getUrl() {        return url;    }    private static class ImageTaskHandler extends android.os.Handler {        private WeakReference&lt;ImageTask&gt; weakReference;        private ImageTask imageTask;        public ImageTaskHandler(ImageTask imageTask) {            this.weakReference = new WeakReference&lt;&gt;(imageTask);            this.imageTask = weakReference.get();        }        @Override        public void handleMessage(Message msg) {            if (imageTask != null) {                switch (msg.what) {                    case 0:                        Bitmap bitmap = BitmapFactory.decodeByteArray(imageTask.imageBytes, 0, imageTask.imageBytes.length);                        imageTask.imageView.setImageBitmap(bitmap);                        ImageLoader.getInstance(imageTask.imageView.getContext()).removeTask(imageTask);                        break;                    case -1:                        Toast.makeText(imageTask.imageView.getContext(), &quot;下载失败&quot;, Toast.LENGTH_SHORT).show();                        ImageLoader.getInstance(imageTask.imageView.getContext()).removeTask(imageTask);                        break;                }            }        }    }}</code></pre><p>将其和ExecutorService封装：</p><pre><code class="java">/** * 图片加载线程队列管理类 */public class ImageLoader {    private volatile static ImageLoader instance;    //Context的弱引用    private WeakReference&lt;Context&gt; weakContext;    //固定线程池    private ExecutorService executorService;    //保存下载任务的链表    private final LinkedList&lt;ImageTask&gt; taskLinkedList;    private ImageLoader(Context context){        weakContext=new WeakReference&lt;Context&gt;(context);        executorService= Executors.newFixedThreadPool(5);        taskLinkedList=new LinkedList&lt;&gt;();    }    public static ImageLoader getInstance(Context context){        if (instance==null){            synchronized (ImageLoader.class){                if (instance==null){                    instance=new ImageLoader(context);                }            }        }        return instance;    }    public void loadImage(ImageView imageView ,String url){        //首先判断该url是否已经在下载队列中        if (isTaskExisted(url,imageView)){            return;        }        ImageTask imageTask=new ImageTask(imageView,url);        synchronized (taskLinkedList){            taskLinkedList.add(imageTask);        }        executorService.execute(imageTask);        //添加到下载队列    }    /**     * LinkedList中是否存在此url     * @param url     * @return     */    private boolean isTaskExisted(String url,ImageView iv){        if (url==null){            return true;        }        synchronized (taskLinkedList){            for (int i=0;i&lt;taskLinkedList.size();i++){                ImageTask imageTask=taskLinkedList.get(i);                if (imageTask!=null&amp;&amp;url.equals(imageTask.getUrl())&amp;&amp;iv.getId()==imageTask.imageView.getId()){                    return true;                }            }        }        return false;    }    public void removeTask(ImageTask imageTask){        synchronized (taskLinkedList){            taskLinkedList.remove(imageTask);        }    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>android图片</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android图片压缩</title>
    <link href="/2018/03/22/android%E5%9B%BE%E7%89%87/android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/"/>
    <url>/2018/03/22/android%E5%9B%BE%E7%89%87/android%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<ol><li><p>质量压缩</p></li><li><p>尺寸压缩</p></li><li><p>缩放法压缩（matrix）</p></li><li><p>RGB_565法（比ARGB_888少一半）</p></li><li><p>createScaledBitmap<br>Bitmap所占用的内存=图片长度 x 图片宽度 x 一个像素点占用的字节数。</p><p>一些常用的bitmap压缩方法</p><pre><code class="java">public class Utils { /**  * 采样率压缩  *  * @param bitmap  * @param sampleSize 压缩的倍数 ，要是2的整数倍，否则四舍五入，比如是2，那么压缩后  *                   就是1/2  * @return  */ public static Bitmap getBitmap(Bitmap bitmap, int sampleSize) {     BitmapFactory.Options options = new BitmapFactory.Options();     options.inSampleSize = sampleSize;     ByteArrayOutputStream bos = new ByteArrayOutputStream();     bitmap.compress(Bitmap.CompressFormat.PNG, 100, bos);     byte[] bytes = bos.toByteArray();     return BitmapFactory.decodeByteArray(bytes, 0, bytes.length,options); } /**  * 图片质量压缩  *  * @param bitmap  * @param quality 0~100  * @return  */ public static Bitmap getBitmapByQuqlity(Bitmap bitmap, int quality) {     ByteArrayOutputStream bos = new ByteArrayOutputStream();     bitmap.compress(Bitmap.CompressFormat.JPEG, quality, bos);     byte[] bytes = bos.toByteArray();     return BitmapFactory.decodeByteArray(bytes, 0, bytes.length); } /**  * Matrix缩放  * @param bitmap  * @param scaleWidth 0~1  * @param scaleHeight 0~1  * @return  */ public static Bitmap getBitmapByMatrix(Bitmap bitmap, float scaleWidth, float scaleHeight) {     Matrix matrix = new Matrix();     matrix.postScale(scaleWidth, scaleHeight);     return Bitmap.createBitmap(bitmap, 0, 0,             bitmap.getWidth(), bitmap.getHeight(), matrix, true); } /**  * 按图片的格式配置压缩  * @param path 本地图片路径  * @param config ALPHA_8 , RGB_565, ARGB_4444, ARGB_8888  * @return  */ public static Bitmap getBitmapByFormatConfig(String path,Bitmap.Config config){     BitmapFactory.Options options=new BitmapFactory.Options();     options.inPreferredConfig=config;     return BitmapFactory.decodeFile(path,options); } /**  * 指定宽度和高度进行压缩  * @param bitmap  * @param concreteWidth 指定的具体宽度  * @param concreteHeight  指定的具体高度  * @return  */ public static Bitmap getBitmapBySize(Bitmap bitmap,int concreteWidth,int concreteHeight){     return Bitmap.createScaledBitmap(bitmap,concreteWidth,concreteHeight,true); } /**  * 更改图片格式的压缩  * @param bitmap  * @param compressFormat JPEG,PNG,WEBP  * @return  */ public static Bitmap getBitmapByFormat(Bitmap bitmap,Bitmap.CompressFormat compressFormat){     ByteArrayOutputStream bos=new ByteArrayOutputStream();     bitmap.compress(compressFormat,100,bos);     byte[] bytes=bos.toByteArray();     return BitmapFactory.decodeByteArray(bytes,0,bytes.length); }</code></pre></li></ol><p>}</p><p>```<br></p>]]></content>
    
    
    <categories>
      
      <category>android图片</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>HttpUrlConnection用字节下载图片，用Bitmap放入ImageView</title>
    <link href="/2018/03/22/android%E5%9B%BE%E7%89%87/HttpUrlConnection%E7%94%A8%E5%AD%97%E8%8A%82%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%EF%BC%8C%E7%94%A8Bitmap%E6%94%BE%E5%85%A5ImageView/"/>
    <url>/2018/03/22/android%E5%9B%BE%E7%89%87/HttpUrlConnection%E7%94%A8%E5%AD%97%E8%8A%82%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87%EF%BC%8C%E7%94%A8Bitmap%E6%94%BE%E5%85%A5ImageView/</url>
    
    <content type="html"><![CDATA[<pre><code class="java">public class MainActivity extends AppCompatActivity {    private ImageView iv_img;    private byte[] pics;    private MyHandler handler;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        handler=new MyHandler(this);        initView();    }    private void initView() {        iv_img = findViewById(R.id.iv_img);        Thread thread = new Thread(new Runnable() {            @Override            public void run() {                try {                    URL urL = new URL(&quot;https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png&quot;);                    HttpURLConnection httpURLConnection = (HttpURLConnection) urL.openConnection();                    httpURLConnection.setRequestMethod(&quot;GET&quot;);                    httpURLConnection.setReadTimeout(10000);                    if (httpURLConnection.getResponseCode() == 200) {                        InputStream inputStream = httpURLConnection.getInputStream();                        ByteArrayOutputStream bos = new ByteArrayOutputStream();                        byte[] bytes = new byte[1024];                        int length = -1;                        while ((length = inputStream.read(bytes)) != -1) {                            bos.write(bytes, 0, length);                        }                        pics = bos.toByteArray();                        bos.close();                        inputStream.close();                        Message message = new Message();                        message.what = 0;                        handler.sendMessage(message);                    }                } catch (Exception e) {                    e.printStackTrace();                }            }        });        thread.start();    }    private static class MyHandler extends Handler{        private WeakReference&lt;MainActivity&gt; weakReference;        MyHandler(MainActivity activity) {            weakReference=new WeakReference&lt;MainActivity&gt;(activity);        }        @Override        public void handleMessage(Message msg) {            MainActivity activity=weakReference.get();            if (activity!=null){                //handle the message below                switch (msg.what){                    case 0:                        Bitmap bitmap= BitmapFactory.decodeByteArray(activity.pics,0,activity.pics.length);                        activity.iv_img.setImageBitmap(bitmap);                        break;                }            }        }    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>android图片</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>图片三级缓存策略</title>
    <link href="/2018/03/21/android%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/"/>
    <url>/2018/03/21/android%E5%9B%BE%E7%89%87/%E5%9B%BE%E7%89%87%E4%B8%89%E7%BA%A7%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/7177220-76e564d8e2e6bb64.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>我们在现实一个图片的时候，按照顺序来是从内存中查找是否有图片缓存，有，直接读取，无，就查找本地文件，有，直接读取，无，通过网络获取。<br>按照这个步骤一个一个来建立相应的类：</p><p><strong>内存缓存</strong></p><pre><code class="java">public class MemoryCacheUtils {//    //强引用//    private HashMap&lt;String,Bitmap&gt; memoryCache=new HashMap&lt;&gt;();//    //软引用//    private HashMap&lt;String,SoftReference&lt;Bitmap&gt;&gt; softMemoryCache=new HashMap&lt;&gt;();    private LruCache&lt;String,Bitmap&gt; memoryCache;    public MemoryCacheUtils() {        //构造函数来实例化一个LruCache        long maxMemory=Runtime.getRuntime().maxMemory()/8;        this.memoryCache = new LruCache&lt;String,Bitmap&gt;((int)maxMemory){            @Override            protected int sizeOf(String key, Bitmap value) {                int byteCount= value.getByteCount();                return byteCount;            }        };    }    /**     * 从内存读取bitmap缓存     * @param url     * @return     */    public Bitmap getBitmapFromMemory(String url){        Bitmap bitmap=memoryCache.get(url);        return bitmap;    }    /**     * 设置Bitmap缓存到内存     * @param url     * @param bitmap     */    public void setBitmapToMemory(String url,Bitmap bitmap){        memoryCache.put(url,bitmap);    }}</code></pre><p><strong>本地缓存</strong></p><pre><code class="java">public class LocalCacheUtils {    /**     * 从本地文件中通过文件名读取缓存图片文件     * @param url     * @return     */    public Bitmap getBitmapFromLocal(String url) {        String fileName;        Bitmap bitmap=null;        try {            fileName=Md5.getMD5(url);            File file=new File(Environment.getExternalStorageDirectory()+&quot;/ImageZip/&quot;+fileName);            bitmap= BitmapFactory.decodeFile(file.getPath());        } catch (Exception e) {            Log.d(&quot;info&quot;,&quot;getBitmapFromLocal wrong&quot;);            e.printStackTrace();        }        return bitmap;    }    /**     * 保存缓存图片到本地     * @param url     * @param bitmap     */    public void setBitmapToLocal(String url, Bitmap bitmap) {        try {            String fileName=Md5.getMD5(url);            File file=new File(Environment.getExternalStorageDirectory()+&quot;/ImageZip/&quot;+fileName);            if (!file.getParentFile().exists()){                boolean mkdirs=file.getParentFile().mkdirs();                Log.d(&quot;info&quot;,&quot;mkdirs:&quot;+mkdirs);            }            bitmap.compress(Bitmap.CompressFormat.JPEG,100,new FileOutputStream(file));        }catch (Exception e){            Log.d(&quot;info&quot;,&quot;setBitmapToLocal wrong&quot;);            e.printStackTrace();        }    }}</code></pre><p><strong>网络缓存</strong><br>在这里网络请求图片用的是AsynTask。</p><pre><code class="java">public class NetCacheUtils {    //内存缓存工具类    private MemoryCacheUtils memoryCacheUtils;    //本地缓存工具类    private LocalCacheUtils localCacheUtils;    public NetCacheUtils(MemoryCacheUtils memoryCacheUtils, LocalCacheUtils localCacheUtils) {        this.memoryCacheUtils = memoryCacheUtils;        this.localCacheUtils = localCacheUtils;    }    public void getImageFromNet(ImageView imageView, String url){        new BitmapTask().execute(imageView,url);    }    class BitmapTask extends AsyncTask&lt;Object,Integer,Bitmap&gt;{        private ImageView imageView;        private String url;        @Override        protected Bitmap doInBackground(Object[] objects) {            imageView=(ImageView) objects[0];            url=(String) objects[1];            return downLoadBitmap(url);        }        @Override        protected void onProgressUpdate(Integer... values) {            super.onProgressUpdate(values);        }        @Override        protected void onPostExecute(Bitmap bitmap) {            super.onPostExecute(bitmap);            //设置给imageView            imageView.setImageBitmap(bitmap);            //保存到本地缓存            localCacheUtils.setBitmapToLocal(url,bitmap);            //保存到内存缓存            memoryCacheUtils.setBitmapToMemory(url,bitmap);        }    }    private Bitmap downLoadBitmap(String url){        try {            URL urL = new URL(url);            HttpURLConnection httpURLConnection = (HttpURLConnection) urL.openConnection();            httpURLConnection.setRequestMethod(&quot;GET&quot;);            httpURLConnection.setReadTimeout(10000);            if (httpURLConnection.getResponseCode() == 200) {                InputStream inputStream = httpURLConnection.getInputStream();                BitmapFactory.Options options=new BitmapFactory.Options();                options.inSampleSize=2;                options.inPreferredConfig=Bitmap.Config.ARGB_4444;                Bitmap bitmap=BitmapFactory.decodeStream(inputStream,null,options);                inputStream.close();                return bitmap;            }        } catch (Exception e) {            e.printStackTrace();        }        return null;    }}</code></pre><p>最后将这三个缓存工具类集成一下：</p><pre><code class="java">public class ImageCacheUtils {    private MemoryCacheUtils memoryCacheUtils;    private LocalCacheUtils localCacheUtils;    private NetCacheUtils netCacheUtils;    public ImageCacheUtils(MemoryCacheUtils memoryCacheUtils, LocalCacheUtils localCacheUtils, NetCacheUtils netCacheUtils) {        this.memoryCacheUtils = memoryCacheUtils;        this.localCacheUtils = localCacheUtils;        this.netCacheUtils = netCacheUtils;    }    public void display(ImageView imageView,String url){        //设置占位符        imageView.setImageResource(R.mipmap.ic_launcher);        Bitmap bitmap;        //从内存缓存中找        bitmap=memoryCacheUtils.getBitmapFromMemory(url);        if (bitmap!=null){            imageView.setImageBitmap(bitmap);            Log.d(&quot;info&quot;,&quot;从内存缓存加载图片&quot;);            return;        }        //内存缓存没有，从本地缓存找        bitmap=localCacheUtils.getBitmapFromLocal(url);        if (bitmap!=null){            imageView.setImageBitmap(bitmap);            Log.d(&quot;info&quot;,&quot;从本地缓存加载图片&quot;);            //将本地获取的缓存图片保存到内存中            memoryCacheUtils.setBitmapToMemory(url,bitmap);            return;        }        //本地缓存没有，最后从网络缓存找        Log.d(&quot;info&quot;,&quot;从网络加载图片&quot;);        netCacheUtils.getImageFromNet(imageView,url);    }}</code></pre><p>使用：</p><pre><code class="java">iv_img = findViewById(R.id.iv_img);ImageCacheUtils imageCacheUtils=new ImageCacheUtils(memoryCacheUtils,localCacheUtils,netCacheUtils);imageCacheUtils.display(iv_img,&quot;https://www.baidu.com/img/superlogo_c4d7df0a003d3db9b65e9ef0fe6da1ec.png&quot;);</code></pre><p>当第一次加载图片的时候，就会用网络去请求，后面就会通过内存或者本地sd卡去加载网络图片了。<br>当然上面几个类可以通过内部类和单例模式来达到更好的代码结构，为了简单不搞那些了。</p><hr><p>以上，图片的三级缓存策略<br>源码地址：<a href="https://github.com/William619499149/ImageCache" target="_blank" rel="noopener">github</a><br></p>]]></content>
    
    
    <categories>
      
      <category>android图片</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ScrollView嵌套ScrollView的滑动冲突</title>
    <link href="/2018/03/16/View/ScrollView%E5%B5%8C%E5%A5%97ScrollView%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/"/>
    <url>/2018/03/16/View/ScrollView%E5%B5%8C%E5%A5%97ScrollView%E7%9A%84%E6%BB%91%E5%8A%A8%E5%86%B2%E7%AA%81/</url>
    
    <content type="html"><![CDATA[<p>结论： 在自定义控件中如下重写<code>onInterceptTouchEvent</code>就告诉所有父View：<strong>不要拦截事件，让我消费！！</strong></p><pre><code class="java">    @Override    public boolean onInterceptTouchEvent(MotionEvent ev) {        getParent().requestDisallowInterceptTouchEvent(true);        return super.onInterceptTouchEvent(ev);    }</code></pre><hr><p>这是一个从源码角度分析<strong>滑动冲突的原因</strong><br>以及在源码中理解为<strong>何能解决滑动冲突</strong></p><p>这是MainActivity主界面的布局内容:<br><img src="https://upload-images.jianshu.io/upload_images/7177220-a1c94fc98e2b3989.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>xml:</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;ScrollView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;com.solory.learnview.MainActivity&quot;&gt;    &lt;LinearLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:orientation=&quot;vertical&quot;&gt;        &lt;Button            android:id=&quot;@+id/btn&quot;            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;           android:layout_margin=&quot;8dp&quot; /&gt;        &lt;ImageView            android:id=&quot;@+id/imageView&quot;            android:layout_width=&quot;105dp&quot;            android:layout_height=&quot;86dp&quot;            android:layout_margin=&quot;8dp&quot;            app:srcCompat=&quot;@mipmap/ic_launcher_round&quot; /&gt;        &lt;TextView            android:layout_width=&quot;wrap_content&quot;            android:layout_height=&quot;wrap_content&quot;            android:text=&quot;@string/article_1&quot;            android:textSize=&quot;36sp&quot; /&gt;        &lt;ScrollView            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;80dp&quot;            android:background=&quot;@color/colorPrimary&quot;&gt;            &lt;TextView                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;wrap_content&quot;                android:text=&quot;@string/article_2&quot; /&gt;        &lt;/ScrollView&gt;    &lt;/LinearLayout&gt;&lt;/ScrollView&gt;</code></pre><p>MainActivity不用动。<br>跑起来：<img src="https://upload-images.jianshu.io/upload_images/7177220-61629f4c1407b98d.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt=""></p><p>外面的ScrollView正常滑动，但是里面的那个ScrollView动不了。</p><h2 id="直接给出解决方案再看如何解决："><a href="#直接给出解决方案再看如何解决：" class="headerlink" title="直接给出解决方案再看如何解决："></a>直接给出解决方案再看如何解决：</h2><p>新建一个类继承ScrollView</p><pre><code class="java">public class MyScrollView extends ScrollView {    public MyScrollView(Context context) {        this(context,null);    }    public MyScrollView(Context context, AttributeSet attrs) {        this(context, attrs,0);    }    public MyScrollView(Context context, AttributeSet attrs, int defStyleAttr) {        super(context, attrs, defStyleAttr);    }    @Override    public boolean onInterceptTouchEvent(MotionEvent ev) {        //关键点在这            getParent().requestDisallowInterceptTouchEvent(true);        return super.onInterceptTouchEvent(ev);    }}</code></pre><p>buildProject,然后在xml中将里面的ScrollView修改成这个MyScrollView。</p><pre><code class="xml">...&lt;com.solory.learnview.MyScrollView    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;80dp&quot;    android:background=&quot;@color/colorPrimary&quot;&gt;    &lt;TextView        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:text=&quot;@string/article_2&quot; /&gt;&lt;/com.solory.learnview.MyScrollView&gt;...</code></pre><p>跑起来：<img src="https://upload-images.jianshu.io/upload_images/7177220-f8873d4196b57ca7.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt=""></p><h3 id="问题解决。"><a href="#问题解决。" class="headerlink" title="问题解决。"></a>问题解决。</h3><p>那么现在研究为什么，为什么在重写的<code>onInterceptTouchEvent(MotionEvent ev)</code>中神奇的一句代码<br><code>getParent().requestDisallowInterceptTouchEvent(true);</code>就把问题解决了？</p><p>好了。跟着我的思路来。</p><ul><li><p>先看ScollView源码中的onInterceptTouchEvent:</p><pre><code class="java">   @Override  public boolean onInterceptTouchEvent(MotionEvent ev) {      /*       * 这个方法决定了我们是否要拦截这个事件。       * 如果我们返回true, onMotionEvent方法将被调用，       * 我们将在那执行实际的滚动操作。       */      /*      * 最常见的情况:用户在拖拽中。      * 他在动他的手指。我们想要截取这个      * 事件.      */      final int action = ev.getAction();      if ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) {          return true;      }      if (super.onInterceptTouchEvent(ev)) {          return true;      }      /*       * 如果我们不能滚动，不要试图截取触摸。       */      if (getScrollY() == 0 &amp;&amp; !canScrollVertically(1)) {          return false;      }      ...      ...      ...</code></pre><p>  清晰明了，干净简单,后面还有一大段代码，就不放了。这里一进来就是一个判断，如果进来的是ACTION_MOVE, 那么直接返回true，直接拦截，那么后面就没他的子View什么事了（不懂的话去看一下ViewGroup的dispatchTouchEvent方法），event被传入他自己的onTouchEvent中去进行滚动操作了。</p></li><li><p>那么我们一开始内部的ScrollView滑动没有响应的原因就是，那时候手指是在滑动的，一直不断传入ACTION_MOVE, 所以event一直被外部的ScrollView在如上的操作中拦截了。</p></li><li><p>意思就是只要你手指在ScrollView上滑动，ScrollView内部的子View就永远接收不到任何事件，就是永远无响应。</p></li></ul><hr><p><strong>冲突的原因明白了，现在看如何解决的</strong></p><ul><li><p>回头看MyScrollView是如何解决的：</p><pre><code class="java">  @Override  public boolean onInterceptTouchEvent(MotionEvent ev) {      getParent().requestDisallowInterceptTouchEvent(true);      return super.onInterceptTouchEvent(ev);  }</code></pre><p>  意思就是取得父类，然后请求父类不拦截TouchEvent的意思。</p><p>  首先getParent就是返回父类，在这里是返回的那个LinearLayout，然后点<code>requestDisallowInterceptTouchEvent</code>进去看，发现是一个叫做ViewParent的接口中的抽象方法，<br>  <img src="https://upload-images.jianshu.io/upload_images/7177220-a1f99bb6a25fa2b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>  注释的英文：</p><pre><code>  当一个子View不想要他的父View和它的祖先View们拦截触摸事件的时候。调用该方法  他的父View应该将该方法接着向上传递给每一个祖先View们。</code></pre></li><li><p>抽象方法的话，看一下是谁实现了，因为继承的ScrollView，所以先看对应的ScrollView中的实现</p><pre><code class="java">  //-----ScrollView中      @Override  public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {      if (disallowIntercept) {      //我也不知道这个方法干嘛的，反正不影响整体思路，先跳过。          recycleVelocityTracker();      }      //无论如何，都会执行父类的该方法。      super.requestDisallowInterceptTouchEvent(disallowIntercept);  }</code></pre></li><li><p>那么我们查看父类中的实现，ViewGroup中：</p><pre><code class="java">  //-----ViewGroup中      @Override  public void requestDisallowInterceptTouchEvent(boolean disallowIntercept) {      if (disallowIntercept == ((mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != 0)) {          // We&#39;re already in this state, assume our ancestors are too          return;      }      if (disallowIntercept) {          mGroupFlags |= FLAG_DISALLOW_INTERCEPT;      } else {          mGroupFlags &amp;= ~FLAG_DISALLOW_INTERCEPT;      }      // Pass it up to our parent      if (mParent != null) {          mParent.requestDisallowInterceptTouchEvent(disallowIntercept);      }  }</code></pre><p>  意思就是将自己的FLAG更改，变成disallowIntercept，并且递归，只要有父View， 就把父View的FLAG同样设置。</p></li><li><p>大意为，设置了这个方法，MyScrollView就通过<strong>递归</strong>，告诉了他的父View和向上的所有祖先View：统统不要拦截事件！交给我来！</p></li><li><p>那这个FLAG是在哪里发挥作用？当然是在ViewGroup的<code>dispatchTouchEvent(MotionEvent event)</code>内部，并且用一个if条件先于<code>onInterceptMotionEvent(MotionEvent event)</code>来判断<br>  图片为证：<img src="https://upload-images.jianshu.io/upload_images/7177220-751013d1f8b9d6e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p></li></ul><hr><p>摸了摸老夫的胡须，嗯…，说的真好啊~</p><h2 id="但是！"><a href="#但是！" class="headerlink" title="但是！"></a>但是！</h2><pre><code class="java">//-----MyScrollView中@Override    public boolean onInterceptTouchEvent(MotionEvent ev) {        getParent().requestDisallowInterceptTouchEvent(true);        return super.onInterceptTouchEvent(ev);    }</code></pre><p>这段代码的<code>getParent().requestDisallowInterceptTouchEvent(true);</code>能执行到的前提是MyScrollView能执行<code>onInterceptTouchEvent</code>，也就是能执行<code>dispatchTouchEvent</code>，可是事件早都被外层的ScrollView拦截了，你还怎么获取父类然后请求不要拦截TouchEvent？<br><strong>当时我在这里思考了蛮久的，</strong> 那么我们返回到ScrollView的<code>onInterceptTouchEvent</code>里去看吧</p><pre><code class="java">     @Override    public boolean onInterceptTouchEvent(MotionEvent ev) {        final int action = ev.getAction();        if ((action == MotionEvent.ACTION_MOVE) &amp;&amp; (mIsBeingDragged)) {            return true;        }        if (super.onInterceptTouchEvent(ev)) {            return true;        }        if (getScrollY() == 0 &amp;&amp; !canScrollVertically(1)) {            return false;        }        ...        ...        ...</code></pre><p>他只拦截ACTION_MOVE，不拦截ACTION_DOWN，所以当ACTION_DOWN的那一次事件还是可以传到下面的子View去的，而利用这一点，MyScrollView利用第一次触碰那唯一的一次event，将他FLAG给改了，事件就可以顺利地传递到MyScrollView了~</p><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>在自定义控件中重写<code>onInterceptTouchEvent</code>就告诉所有父View：<strong>不要拦截事件，让我消费！！</strong><pre><code class="java">  @Override  public boolean onInterceptTouchEvent(MotionEvent ev) {      getParent().requestDisallowInterceptTouchEvent(true);      return super.onInterceptTouchEvent(ev);  }</code></pre></li></ul><p></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>View事件分发学习笔记</title>
    <link href="/2018/03/15/View/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2018/03/15/View/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<hr><p>首先推荐<strong>郭霖</strong>的真正的通俗易懂的View的事件分发文章：</p><p><a href="http://blog.csdn.net/guolin_blog/article/details/9097463" target="_blank" rel="noopener">Android事件分发机制完全解析，带你从源码的角度彻底理解(上)</a></p><blockquote><p>文章中讲述了几个要点：</p><ul><li>如果你在执行ACTION_DOWN的时候返回了false，后面一系列其它的action就不会再得到执行了。简单的说，就是当dispatchTouchEvent在进行事件分发的时候，只有前一个action返回true，才会触发后一个action。即消费事件才会继续有事件。</li><li>在dispatchMotionEvent方法中执行到了onTouchEvent中将MotionEvent对象传入switch中做ACTION_DOWN、ACTION_UP等判断的时候，默认地在结束switch之后马上返回true。也就是到了这一步，默认地就消费了事件。</li><li>如果你有一个控件是非enable的，那么给它注册onTouch事件将永远得不到执行。（默认地每一个控件的enable=true）,并且设置OnClickListener也得不到执行。</li></ul></blockquote><hr><h1 id="我自己的一点学习笔记："><a href="#我自己的一点学习笔记：" class="headerlink" title="我自己的一点学习笔记："></a>我自己的一点学习笔记：</h1><p>在View的dispatchTouchEvent(MotionEvent event)方法中，onTouch和onTouchEvent的优先级关系：<code>mOnTouchListener.onTouch&gt;onTouchEvent</code></p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-3dd405529c903a0a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><h3 id="onTouch"><a href="#onTouch" class="headerlink" title="onTouch:"></a>onTouch:</h3><p>由OnTouchListener接口控制，从外部setOnTouchListener来实现，返回true的话，就把事件拦截，则不会再执行下面的onTouchEvent。</p><pre><code class="java">button.setOnTouchListener(new View.OnTouchListener() {    @Override    public boolean onTouch(View v, MotionEvent event) {        eventLog(event);        return false;    }});</code></pre><h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent:"></a>onTouchEvent:</h3><p>伪码如下</p><pre><code class="java">public boolean onTouchEvent(MotionEvent event) {    boolean clickable =CLICKABLE;    //如果CLICKABLE为true，才接着判断MotionEvent。    if(clickable){        switch(action){            case MotionEvent.ACTION_UP:                ...                ...                ...                performClick();                break;            case  MotionEvent.ACTION_DOWN:                break;            case ..            ...        }    }}</code></pre><p>伪码的意思就是：</p><ul><li>如果View的CLICKABLE属性是false，那么onTouchEvent就不能根据传入的MotionEvent对象才进行操作。</li><li>注意ACTION_UP的最后面有一个performClick()方法，点进去==&gt;<pre><code class="java">public boolean performClick(){  ...  //这里的mOnClickListener就是===&gt;  //我们通过button.setOnClickListener(new 匿名内部类)传入的对象；  if(mOnClickListener!=null){      mOnClickListener.onClick(this);  }  ...}</code></pre>那么我们的onClick方法不会执行的原因可能有一种：</li><li>我们设置OnTouchListener.onTouch方法返回了true。</li><li><del>View的CLICKABLE是false</del>，这是不可能的，因为一旦setOnClickListener(),就会把CLICKABLE改为true==&gt;&gt;</li><li><img src="https://upload-images.jianshu.io/upload_images/7177220-9d5b336fe3e575b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ul><hr><p>此外，View的CLICKABLE默认就是false的，但是为什么button就算不设置OnClickListener也能被click呢？看一下Button的构造方法：</p><pre><code class="java">public class Button extends TextView {    public Button(Context context) {        this(context, null);    }    //看传入的第三个参数是R.attr.buttonStyle!!    public Button(Context context, AttributeSet attrs) {        this(context, attrs, com.android.internal.R.attr.buttonStyle);    }    public Button(Context context, AttributeSet attrs, int defStyleAttr) {        this(context, attrs, defStyleAttr, 0);    }    public Button(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {        super(context, attrs, defStyleAttr, defStyleRes);    }    //其他忽略    ...</code></pre><p>找到那个R.attr.buttonStyle关联的文件：<br>她在themes.xml文件中</p><pre><code class="xml">&lt;!-- Button styles --&gt;&lt;item name=&quot;buttonStyle&quot;&gt;@style/Widget.Button&lt;/item&gt;&lt;item name=&quot;buttonStyleSmall&quot;&gt;@style/Widget.Button.Small&lt;/item&gt;&lt;item name=&quot;buttonStyleInset&quot;&gt;@style/Widget.Button.Inset&lt;/item&gt;&lt;item name=&quot;buttonStyleToggle&quot;&gt;@style/Widget.Button.Toggle&lt;/item&gt;</code></pre><p>点进去buttonStyle==&gt;</p><p><img src="https://upload-images.jianshu.io/upload_images/7177220-b0e4a9776c2dca09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>Button通过style已经设置了clickable=true。<br></p>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fragment状态保存</title>
    <link href="/2018/03/11/Android/Fragment%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98/"/>
    <url>/2018/03/11/Android/Fragment%E7%8A%B6%E6%80%81%E4%BF%9D%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<p><a href="http://yifeng.studio/2016/12/19/android-fragment-state-saving-best-practices/" target="_blank" rel="noopener">译］Android Activity 和 Fragment 状态保存与恢复的最佳实践</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>RecyclerView和glide搭配中的图片混乱</title>
    <link href="/2018/03/11/Android/RecyclerView%E5%92%8Cglide%E6%90%AD%E9%85%8D%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%B7%B7%E4%B9%B1/"/>
    <url>/2018/03/11/Android/RecyclerView%E5%92%8Cglide%E6%90%AD%E9%85%8D%E4%B8%AD%E7%9A%84%E5%9B%BE%E7%89%87%E6%B7%B7%E4%B9%B1/</url>
    
    <content type="html"><![CDATA[<h3 id="这个bug可以说是折磨了我很久了，问了人，查了博客，最后找到了答案。"><a href="#这个bug可以说是折磨了我很久了，问了人，查了博客，最后找到了答案。" class="headerlink" title="这个bug可以说是折磨了我很久了，问了人，查了博客，最后找到了答案。"></a>这个bug可以说是折磨了我很久了，问了人，查了博客，最后找到了答案。</h3><p>首先要搞明白RecyclerView中的ViewHolder的复用机制是什么，在，以及由于复用机制和请求网络mix在一起之后会发生哪些可能的事故，强烈推荐一个好文：</p><blockquote><p><a href="http://blog.csdn.net/xyq046463/article/details/51800095" target="_blank" rel="noopener">RecyclerView中ViewHolder重用机制理解(解决图片错乱和闪烁问题)</a></p></blockquote><hr><p><img src="https://upload-images.jianshu.io/upload_images/7177220-043486f24787a3e7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="他的博客取来的图片"></p><p>总结一下就是：</p><ul><li>RecyclerView用的是我们自定义的内部类ViewHolder来复用的，也就是复用的是ViewHoler</li><li>当屏幕下滑，item1滑出可视区域，将item1的ViewHolder对象给item8复用，那么此时item1中ViewHolder对象中持有的变量都是item1的。</li><li>item1中的ViewHolder对象，在onBindViewHolder(MyViewHolder holder, int position)方法中对holder进行更新，但是如果在这里调用glide去从url加载图片到holder中的imageView对象的话，就有可能因为网络延迟，导致图片加载不出来，那么item8就会先显示item1的图片，过一会延迟之后，显示正确的item8该显示的图片</li></ul><p>上面博客加载图片用的是AsynTask，我用的是Glide框架，ViewHolder中3个TextView,一个ImageView,按照那个思路，我的处理方法如下：</p><pre><code class="java">@Override    public void onBindViewHolder(MyViewHolder holder, int position) {        if (holder == null) {            return;        }        holder.tvDesc.setText(resultsBeanList.get(position).getDesc());        holder.tvPublishedAt.setText(timeParse.getTime(resultsBeanList.get(position).getPublishedAt()));        Object who = resultsBeanList.get(position).getWho();        if (who != null) {            holder.tvWho.setText((String) who);        }else {            //防止ViewHolder复用导致上一个tvWho的内容遗留            holder.tvWho.setText(&quot;&quot;);        }        //处理imageView--------------        List&lt;String&gt; imagesUrl = resultsBeanList.get(position).getImages();        if (imagesUrl == null) {            //当ViewHolder复用的时候，如果当前返回的图片url为null，为了防止上一个复用的viewHolder图片            //遗留，要clear并且将图片设置为空。            Glide.with(fragment).clear(holder.ivImage);            holder.ivImage.setImageDrawable(null);            holder.ivImage.setTag(R.id.image_tag, position);            return;        }        Object tag=holder.ivImage.getTag(R.id.image_tag);        if (tag!=null&amp;&amp;(int) tag!= position) {            //如果tag不是Null,并且同时tag不等于当前的position。            //说明当前的viewHolder是复用来的            //Cancel any pending loads Glide may have for the view            //and free any resources that may have been loaded for the view.            Glide.with(fragment).clear(holder.ivImage);        }        String url = imagesUrl.get(0);        Glide.with(fragment)                .load(url + &quot;?imageView2/0/w/100&quot;)                .apply(options)                .into(holder.ivImage);        //给ImageView设置唯一标记。        holder.ivImage.setTag(R.id.image_tag, position);    }</code></pre><p>至此，不再图片混乱。<br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2018-02-08T08-13-24-479Z格式的时间解析</title>
    <link href="/2018/03/09/Android/2018-02-08T08-13-24-479Z%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%97%B6%E9%97%B4%E8%A7%A3%E6%9E%90/"/>
    <url>/2018/03/09/Android/2018-02-08T08-13-24-479Z%E6%A0%BC%E5%BC%8F%E7%9A%84%E6%97%B6%E9%97%B4%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>当服务器返回的格式为<br><code>&quot;createdAt&quot;: &quot;2018-02-08T20:30:00.798Z&quot;,</code><br>的字符串格式的时间格式时，解析方式如下：</p><pre><code>package com.solory.gankionews.Util;/* * * Created by William on 2018/3/9. */import java.text.ParseException;import java.text.SimpleDateFormat;import java.util.Date;import java.util.Locale;public class TimeParse {    private TimeParse() {    }    public static TimeParse getInstance() {        return InstanceHolder.instance;    }    private final SimpleDateFormat utcFormat = new SimpleDateFormat(&quot;yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS Z&quot;, Locale.CHINA);    private final SimpleDateFormat defaultFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;, Locale.CHINA);    private static class InstanceHolder {        private static final TimeParse instance = new TimeParse();    }    public String getTime(String UTCString) {        try {            UTCString = UTCString.replace(&quot;Z&quot;, &quot; UTC&quot;);            Date date = utcFormat.parse(UTCString);            return defaultFormat.format(date);        } catch (ParseException pe) {            pe.printStackTrace();            return null;        }    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AndroidStudio获取SHAI码</title>
    <link href="/2018/02/28/Android/AndroidStudio%E8%8E%B7%E5%8F%96SHAI%E7%A0%81/"/>
    <url>/2018/02/28/Android/AndroidStudio%E8%8E%B7%E5%8F%96SHAI%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>打开Terminal<br><img src="http://upload-images.jianshu.io/upload_images/7177220-f01db1cb6fa75869.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>输入如下：<br><code>keytool -list -v -keystore D:\签名\AI.jks</code><br>后面的这个部分：<code>D:\签名\AI.jks</code>，是密钥文件所存放的路径。</p><p>按下回车<br><img src="http://upload-images.jianshu.io/upload_images/7177220-388cf6f2f2888115.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"></p><p>输入密钥，回车,出结果：</p><pre><code>D:\AndroidProject\MyTest&gt;keytool -list -v -keystore D:\签名\AI.jks输入密钥库口令:密钥库类型: JKS密钥库提供方: SUN您的密钥库包含 1 个条目别名: key0创建日期: 2017-8-4条目类型: PrivateKeyEntry证书链长度: 1证书[1]:所有者: CN=William发布者: CN=William序列号: 2917aca9有效期开始日期: Fri Aug 04 12:58:20 CST 2017, 截止日期: Tue Jul 29 12:58:20 CST 2042证书指纹:         MD5: 4D:A3:********8C:AC         SHA1: 81:8A:******71:42         SHA256: D5:*****9C         签名算法名称: S**SA         版本: 3扩展:#1: ObjectId: 2.5.29.14 Criticality=falseSubjectKeyIdentifier [KeyIdentifier [0000: 70 04 1B 37 0D B2 44 C2   47 21 0C E9 3F B6 FA E5  p..7..D.G!..?...0010: 08 EE DC E7                                        ....]]**************************************************************************************</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GreenDao-2-0初始化方法</title>
    <link href="/2018/02/28/Android/GreenDao-2-0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/"/>
    <url>/2018/02/28/Android/GreenDao-2-0%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>因为我以前都是用3.0的注解来生成Entity实体类的， 没有用过2.0用代码操作的方式，所以记录一下。</p><hr><p><img src="http://upload-images.jianshu.io/upload_images/7177220-402cec2247d30686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>官网图如上：<br>第一点：在你的generator类里面添加依赖。<br>那么打开AS,新建一个Module，类型为Java Library.</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-87cb18ddf4205d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>在Module的gradle中复制粘贴依赖</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-cf7df3b5c6916244.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>看官网的第三点：在app中添加依赖：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-0588745c81d04beb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>写一个类用来生成GreenDao。</p><pre><code class="java">public class ExampleDaoGenerator {    private static final String packageName=&quot;GreenDao&quot;;    private static final String generatePath=&quot;D:\\AndroidProject\\MyTest\\app\\src\\main\\java\\com\\solory\\mytest&quot;;    public static void main(String args[]) {        Schema schema=new Schema(1,packageName);        addRideRecord(schema);        try {            new DaoGenerator().generateAll(schema,generatePath);        }catch (Exception e){            e.printStackTrace();        }    }    private static void addRideRecord(Schema schema) {        Entity rideRecord=schema.addEntity(&quot;RideRecord&quot;);        rideRecord.addIdProperty();        rideRecord.addIntProperty(&quot;bike_id&quot;);        rideRecord.addDateProperty(&quot;start_at&quot;);        rideRecord.addDateProperty(&quot;end_at&quot;);        rideRecord.addBooleanProperty(&quot;isPay&quot;);        rideRecord.addIntProperty(&quot;money&quot;);    }}</code></pre><p>之后点击run，立马报错</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-6a698b0572011174.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>这个错误起码折腾了我两个小时，最终在google后在GreenDao的github的issue那里找到了答案。（我百度了好久好久都没有找到，去你妈的百度）。<br><a href="https://github.com/greenrobot/greenDAO/issues/619" target="_blank" rel="noopener">https://github.com/greenrobot/greenDAO/issues/619</a></p><p>官方解决方案：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-855e52ba563e2322.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>具体操作为：<br>添加这么两句在java类中的gradle:</p><pre><code class="java">apply plugin: &#39;application&#39;mainClassName = &quot;com.solory.daoexamplegenerator.ExampleDaoGenerator&quot;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7177220-e0779975c51ec8e1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>点击右边框的<br><img src="http://upload-images.jianshu.io/upload_images/7177220-b4b58940bbf97190.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>双击如下的run文件，GreenDao<br><img src="http://upload-images.jianshu.io/upload_images/7177220-560d2770e0eae996.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>注意：如果没有在gradle里面添加apply plugin:’application’那两句的话，是没有application这个包的。<br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>token,cookie,session</title>
    <link href="/2018/02/25/%E7%BD%91%E7%BB%9C/token,cookie,session/"/>
    <url>/2018/02/25/%E7%BD%91%E7%BB%9C/token,cookie,session/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.51cto.com/wyong/1553352" target="_blank" rel="noopener">Android客户端和服务端如何使用Token和Session</a></p><hr><p><a href="http://blog.csdn.net/tobetheender/article/details/52485948" target="_blank" rel="noopener">Token ，Cookie和Session的区别–学习笔记</a></p><hr><p><a href="http://www.cnblogs.com/nannan0226/p/6257546.html" target="_blank" rel="noopener">cookie、session与token</a><br></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Annotation总结</title>
    <link href="/2018/02/24/Java/Annotation%E6%80%BB%E7%BB%93/"/>
    <url>/2018/02/24/Java/Annotation%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>这篇总结的内容是我自己昨天我晚上写的一部分，因为我第二天在简书上面看到了一篇和我内容相似的，估计出处也是《疯狂java讲义》，所以剩下的内容在这里面看就可以了：</p><p><a href="https://www.jianshu.com/p/28edf5352b63" target="_blank" rel="noopener">zlcook的文章 : Java:Annotation(注解)–原理到案例</a></p><h2 id="java基本的5种Annotation"><a href="#java基本的5种Annotation" class="headerlink" title="java基本的5种Annotation"></a>java基本的5种Annotation</h2><ul><li>@Overrided：只作用于方法，标识该方法是覆盖父类的方法</li><li>@Deprecated: 作用于方法，类，接口。表示某个程序元素已过时</li><li>@SpressWarnings：被该Annotation修饰的程序元素以及其中的所有子元素将取消显示指定的编译器警告。比如：@SuppressWarnings(value=”unchecked”)表示抑制集合没有使用泛型的警告。</li><li>@SafeVarags：用于抑制“堆污染”（heap pollution）</li><li>@FunctionalInterface： 只用于修饰接口。作用：指定被修饰的接口必须是函数式接口（接口中只有一个抽象方法，可以包含多个默认方法或者多个static方法）。<ul><li>比如：<pre><code class="java">@FunctionalInterfacepublic interface FunInterface{   static void foo(){   System.out.println(&quot;foo类方法&quot;);   }   default void bar(){       System.out.println(&quot;bar默认方法&quot;)   }   void test();//只定义一个抽象方法}</code></pre>如果该接口中有多个抽象方法，就会编译出错</li></ul></li></ul><h2 id="java的6个元注解，Meta-Annotation。（用于修饰注解的注解）"><a href="#java的6个元注解，Meta-Annotation。（用于修饰注解的注解）" class="headerlink" title="java的6个元注解，Meta Annotation。（用于修饰注解的注解）"></a>java的6个元注解，Meta Annotation。（用于修饰注解的注解）</h2><hr><ul><li>@Retention : 用于指定被修饰的Annotation可以保留多长时间，@Retention包含一个<code>RetentionPolicy</code>类型的<code>成员变量</code>：<code>value</code>,所以使用@Retention时必须为该value指定值。有如下三个值：<ul><li><strong>RetentionPolicy.CLASS</strong>:编译器将把Annotation记录在class文件中。当运行java程序时，JVM不可获取Annotation信息。这是默认值。</li><li><strong>RetentionPolicy.RUNTIME</strong>：编译器把Annotation记录在class文件中。当运行java程序时，JVM可以获取Annotation信息，程序可以通过反射获取到该Annotation的信息。</li><li><strong>RetentionPolicy.SOURCE</strong>：Annotation只保留在源代码中，编译器直接丢弃这种Annotation。<br>如果要用反射获取注解信息，就要将value属性设置为Retention.RUNTIME。<pre><code class="java">//定义下面的Testable注解保留到运行时，因此能够被反射@Retention(value=RetentionPolicy.RUNTIME)public @interface Testable{}</code></pre>因为当注解的成员变量名为value时，程序可以直接在注解的括号里指定该成员变量的值，无须使用name=value形式，因此也可以：<pre><code class="java">//定义下面的Testable注解将被编译器直接丢弃，不会被加载到运行时，无法反射@Retention(RetentionPolicy.SOURCE)public @interface Testable{}</code></pre></li></ul></li></ul><hr><ul><li>@Target : 用于指定被修饰的Annotation能用于修饰哪些程序单元，@Target也包含一个名为value的成员变量，其值只能是如下几个： <ul><li>ElementType.ANNOTATION_TYPE:指定该策略的Annotation只能修饰Annotation</li><li>ElementType.CONSTRUCTOR:指定该策略的Annotation只能修饰构造器</li><li>ElementType.FIELD:只能修饰局部变量</li><li>ElementType.METHOD:只能修饰方法</li><li>ElementType.PACKAGE:只能修饰包</li><li>ElementType.PARAMETER:只能修饰参数</li><li>ElementType.TYPE可以修饰类、接口（包括注解类型）或枚举<br></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>2018春节的末尾</title>
    <link href="/2018/02/22/%E6%97%A5%E8%AE%B0%E6%9C%AC/2018%E6%98%A5%E8%8A%82%E7%9A%84%E6%9C%AB%E5%B0%BE/"/>
    <url>/2018/02/22/%E6%97%A5%E8%AE%B0%E6%9C%AC/2018%E6%98%A5%E8%8A%82%E7%9A%84%E6%9C%AB%E5%B0%BE/</url>
    
    <content type="html"><![CDATA[<p>为了拿科目二的驾照，明日返校。<br>其实我更想在远方的清儿，我与她又隔了快两个月没见面了。<br></p>]]></content>
    
    
    <categories>
      
      <category>日记本</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>http和tcp-ip的区别</title>
    <link href="/2018/02/21/%E7%BD%91%E7%BB%9C/http%E5%92%8Ctcp-ip%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2018/02/21/%E7%BD%91%E7%BB%9C/http%E5%92%8Ctcp-ip%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>一个简单通俗易懂的解释：<a href="http://www.cnblogs.com/roverliang/p/5176456.html" target="_blank" rel="noopener">HTTP协议—— 简单认识TCP/IP协议</a></p><hr><p>解释：</p><ul><li>http协议负责的是记录应用层的请求消息和响应消息。</li><li>TCP负责的是传输层，将http中的大段的消息切割成小的以报文段（segment）为单位的数据包，为了更容易传输数据。</li><li>Ip负责记录己方和对方的ip地址，自己的mac地址和下一个路由器或计算机的mac地址（为了转发数据）。</li></ul><hr><h2 id="通俗易懂的图解："><a href="#通俗易懂的图解：" class="headerlink" title="通俗易懂的图解："></a>通俗易懂的图解：</h2><p><img src="http://upload-images.jianshu.io/upload_images/7177220-2fea9bf15abee01d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><hr><p>访问一个网页时各种协议的作用：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-f852dd016a6168e8.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><hr><p>网络数据包结构：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-989c10c688d3f17c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><hr><p><img src="http://upload-images.jianshu.io/upload_images/7177220-7b115ca117e378ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p></p>]]></content>
    
    
    <categories>
      
      <category>网络</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>策略模式</title>
    <link href="/2018/02/14/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2018/02/14/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p><strong>定义</strong>：策略模式定义了算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。</p><p><strong>我自己的理解：</strong>一个对象的功能应该由<strong>组合</strong>得来，而非<strong>继承</strong>得来。在此，组合和继承的意思分别是：</p><ul><li>组合：指的是接口的组合，不同的功能应该对应不同的接口，在父类中声名，由多态来控制灵活性。</li><li>继承：指的就是由父类固定死的方法继承下来，不具有灵活性。</li></ul><p>例子：<br>比方说我现在创建一个类叫Duck,那么鸭子对象肯定有固定的功能比如：游泳，吃。</p><pre><code>//固定不变的部分写在父类中继承下去，实现代码复用protected void swim(){}protected abstract void display();</code></pre><p>那么其他功能可能在以后有新的需求或者需求有变的时候，为了更容易维护，让结构更具有弹性，我们把鸭子对象中其他容易变动的代码用接口来组合。比如：</p><ul><li>鸭子飞：<pre><code>public interface IFlyBehavior {  void fly();}</code></pre></li><li>鸭子叫<pre><code>public interface IQuackBehavior {  void quack();}</code></pre></li></ul><p>组合到一起：</p><pre><code>public abstract class Duck {    //抽象父类鸭子的功能由接口组合而来    private IFlyBehavior iFlyBehavior;    private IQuackBehavior iQuackBehavior;    public void setiFlyBehavior(IFlyBehavior iFlyBehavior) {        this.iFlyBehavior = iFlyBehavior;    }    public void setiQuackBehavior(IQuackBehavior iQuackBehavior) {        this.iQuackBehavior = iQuackBehavior;    }    public void performFly(){        if (iFlyBehavior!=null){            iFlyBehavior.fly();        }    }    public void performQuackk(){        if (iQuackBehavior!=null){            iQuackBehavior.quack();        }    }    //固定不变的部分写在父类中继承下去，实现代码复用    protected void swim(){}    protected abstract void display();}</code></pre><p>此时我们把功能用接口抽象，那么抽象的功能的实现类：</p><pre><code>public class FlyWithRocket implements IFlyBehavior {    @Override    public void fly() {        System.out.println(&quot;用火箭飞！&quot;);    }}</code></pre><pre><code>public class FlyWithWings implements IFlyBehavior{    @Override    public void fly() {        System.out.println(&quot;用翅膀飞&quot;);    }}</code></pre><p>继承父类Duck，写一个子类：</p><pre><code>public class ModelDuck extends Duck {//子类中的功能不是写死的，而是灵活可变的，可以动态地修改的    @Override    protected void display() {        System.out.println(&quot;我是一只模型鸭&quot;);    }}</code></pre><p>用的时候就这样：</p><pre><code>public class Main {    public static void main(String[] args){        /**         * 固定的代码部分不变，用继承来做到代码复用。         * 容易变化的部分的代码用接口和多态来实现。         * 将容易变化的代码隔离到另一个类去实现。         *         * 如果要添加功能，就在父类里面添加接口的引用和对应的set方法。         * 那么子类就都有了接口并且可以动态地设置实现类。         * 灵活，具有弹性.         */        Duck modelDuck=new ModelDuck();        modelDuck.setiFlyBehavior(new FlyWithRocket());;        modelDuck.performFly();    }}</code></pre><p>此为策略模式<br>一句话总结：为对象或类添加功能时，用接口来组合这些功能，具体的实现类与这个对象或者类分离。</p><p></p>]]></content>
    
    
    <categories>
      
      <category>java设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android，Mvp模式学习</title>
    <link href="/2018/02/09/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Android%EF%BC%8CMvp%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2018/02/09/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Android%EF%BC%8CMvp%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-Mvp项目学习"><a href="#title-Mvp项目学习" class="headerlink" title="title: Mvp项目学习"></a>title: Mvp项目学习</h2><p>：<img src="http://upload-images.jianshu.io/upload_images/7177220-093073e0a91663a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" srcset="/img/loading.gif" alt=""></p><p>今天用我们用MVP模式来完成一个简单的登录界面的实现。<br>业务需求：</p><ul><li>用户输入用户名和密码之后，按下登录按钮，跳转到另一个Activity。<ul><li>这里面隐含的一些含义有：检查用户名和密码（网络访问）</li><li>点击登录按钮，对网络返回结果判断并处理（设置监听器）</li></ul></li></ul><p>由于我们这里是简化版本的，所以不写网络访问的代码，用一个延时的handler来模拟就行了。<br><img src="http://upload-images.jianshu.io/upload_images/7177220-d7a80cf13b6f5fe9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" srcset="/img/loading.gif" alt="image.png"></p><p>MVP模式的思路是：</p><ul><li>创建Model接口，View接口，Presenter接口。</li><li><strong>View接口</strong>：根据业务或者UI设计师给的图片来定制我们的View接口中应该有哪些方法，比如显示进度条，跳转界面，只要用户能操作的或者用户看得到的可交互的东西，都需要考虑是否要写进View接口中。</li><li><strong>Model接口</strong>：根据View接口中的方法，设计Model接口中的方法，Model接口就是用来对数据进行处理的，UI层的交互数据将会流到这里，比如EditText输入了用户名，那么用户名就经由Presenter的逻辑处理最终来到Model接口，Model接口比如实现了网络访问操作，此时将数据处理了拿到返回结果，再传回给Presenter，经由Presenter传递给View。</li><li><strong>Presenter接口</strong>：根据View接口中的方法来设计对应的方法，并且方法一般都和Model层进行交互。</li></ul><hr><h3 id="View层接口的设计："><a href="#View层接口的设计：" class="headerlink" title="View层接口的设计："></a>View层接口的设计：</h3><p>那么首先看到界面的图片，我们按照用户和UI交互的几个地方设计方法就行了：</p><ul><li>点击登录，显示登录进度，用一个progressBar。</li><li>点击登录可能出现：<ul><li>用户名错误提示：设置用户名错误提示动画</li><li>密码错误提示：设置密码错误提示动画</li><li>用户名密码正确，跳转至主界面Activity<br>那么对应的LoginView接口为：<pre><code class="java">public interface ILoginView {void showProgressBar();void hideProgressBar();void setUserNameError();void setPasswordError();void JumpToActivity();}</code></pre>那么对应的登录界面的Activity只要实现该接口并正确地实现每个接口所描述的方法就行了。回头在Presenter里面用ILoginView的引用调用对应的方法，即可从Presenter层去改变UI界面。</li></ul></li></ul><h3 id="Model层接口的设计"><a href="#Model层接口的设计" class="headerlink" title="Model层接口的设计"></a>Model层接口的设计</h3><p>Model层是用来接收数据（从View层发送过来的数据），处理数据，并返回数据（返回给View层来展示给用户）的，所以Model接口的方法设计要依照我们要处理的数据。<br>这里要处理的数据是：———用户名和密码<br>此外还要设计监听器，为了便于管理，监听器就放在对应的Model层接口里面<br>代码：</p><pre><code class="java">public interface ILoginModel {    interface OnLoginListener{        void onSuccess();        void onUsernameWrong();        void onPasswordWrong();    }    void login(String username,String password,ILoginModel.OnLoginListener listener);}</code></pre><p>实现类</p><pre><code class="java">public class LoginModelImp implements ILoginModel {    @Override    public void login(final String username, final String password, final OnLoginListener listener) {        //此处应该是有网络请求的，比如调用OkHttp或者RxJava什么的。        new Handler().postDelayed(new Runnable() {            @Override            public void run() {                if (TextUtils.isEmpty(username)){                    listener.onUsernameWrong();                    return;                }                if (TextUtils.isEmpty(password)){                    listener.onPasswordWrong();                    return;                }                listener.onSuccess();            }        },1500);    }}</code></pre><p>在这里的OnLoginListener调用的每一个方法最终的结果都是去View层去改变UI视图来和用户交互，而Model层不能直接和View层通信，那么只能借助Presenter来实现监听器接口，因为Presenter里面有双方（M和V）的引用，所以可以轻易地调用View层的方法去改变UI。</p><h3 id="Presenter层接口的设计"><a href="#Presenter层接口的设计" class="headerlink" title="Presenter层接口的设计"></a>Presenter层接口的设计</h3><p>Presenter层是用来桥接Model层和View层的，所以方法应该用于让M和V之间通信</p><pre><code class="java">public interface ILoginPresenter {    void onLogin(String username,String password);    void onViewDestroy();}</code></pre><p>实现类</p><pre><code class="java">public class LoginPresenterImp  implements ILoginPresenter,ILoginModel.OnLoginListener{    private ILoginModel loginModel;    private ILoginView loginView;    public LoginPresenterImp(ILoginView loginView){        this.loginView=loginView;        this.loginModel=new LoginModelImp();    }    @Override    public void onLogin(String username,String password) {        if (loginView!=null){            loginView.showProgressBar();        }        loginModel.login(username,password,this);    }    @Override    public void onViewDestroy() {        //解除View和Presenter的绑定        loginView=null;    }    //----------------------------------------------下面是OnLoginListener    @Override    public void onSuccess() {        loginView.hideProgressBar();        loginView.JumpToActivity();    }    @Override    public void onUsernameWrong() {        loginView.setUserNameError();        loginView.hideProgressBar();    }    @Override    public void onPasswordWrong() {        loginView.setPasswordError();        loginView.hideProgressBar();    }}</code></pre><hr><p>最后是View层的实现类，即LoginActivity</p><pre><code class="java">public class LoginActivity extends AppCompatActivity implements ILoginView{    ILoginPresenter loginPresenter;    ProgressBar progressBar;    EditText usernameE,passwordE;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        initiateView();        loginPresenter=new LoginPresenterImp(this);        findViewById(R.id.loginBtn).setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                loginPresenter.onLogin(usernameE.getText().toString(),passwordE.getText().toString());            }        });    }    private void initiateView() {        usernameE=findViewById(R.id.username);        passwordE=findViewById(R.id.password);        progressBar=findViewById(R.id.loginProgressBar);    }    @Override    public void showProgressBar() {        progressBar.setVisibility(View.VISIBLE);    }    @Override    public void hideProgressBar() {        progressBar.setVisibility(View.INVISIBLE);    }    @Override    public void setUserNameError() {        usernameE.setError(&quot;用户名错误&quot;);    }    @Override    public void setPasswordError() {        passwordE.setError(&quot;密码错误&quot;);    }    @Override    public void JumpToActivity() {        startActivity(new Intent(this, Main2Activity.class));        this.finish();    }    @Override    protected void onDestroy() {        loginPresenter.onViewDestroy();        super.onDestroy();    }}</code></pre><p>持有Presenter的引用，调用Presenter中的方法，而Presenter中又有Model的引用，间接地将数据传输给Model层去处理</p><hr><p>接下来模拟一次正常的用户操作，输入用户名和密码并点击登录，那么事件发生的流程图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-6046df2a6e861014.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>结束</p><hr><p>github项目地址：<a href="https://github.com/William619499149/MvpFirst/tree/master" target="_blank" rel="noopener">MvpFirst</a><br></p>]]></content>
    
    
    <categories>
      
      <category>java设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>再次理解回调的含义</title>
    <link href="/2018/02/09/Android/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3%E5%9B%9E%E8%B0%83%E7%9A%84%E5%90%AB%E4%B9%89/"/>
    <url>/2018/02/09/Android/%E5%86%8D%E6%AC%A1%E7%90%86%E8%A7%A3%E5%9B%9E%E8%B0%83%E7%9A%84%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<p>哪个类实现了<code>回调监听接口</code>中的方法，就回去调用哪个类中的对应的方法。<br><img src="http://upload-images.jianshu.io/upload_images/7177220-7b5932ef0be14fca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>主函数中调用<code>HttpUtils</code>的<code>get</code>方法，第二个参数传入<code>View</code>的实例，那么当<code>get</code>方法内部执行到<code>listener</code>调用方法的地方的时候，就会去回调<code>View</code>中的方法。<br>这就是<code>回调方法</code><br>例子：</p><pre><code class="java">//回调接口public interface Listener {    void onSucceed(String info);    void onFailed(String info);}</code></pre><pre><code>//模仿网络访问类public class HttpUtils {    //参数是url和对应的监听器    public void get(String url, Listener listener){        //开启延时的一个线程模拟网络访问        new Thread(new Runnable() {            @Override            public void run() {                try {                    Thread.sleep(1500);                } catch (InterruptedException e) {                    e.printStackTrace();                }                //对网络访问结果进行判断并接着调用相应的监听器的方法                if (url==null){                    listener.onFailed(&quot;error&quot;);                }else {                    listener.onSucceed(&quot;anyInfo&quot;);                }            }        }).start();    }}</code></pre><pre><code class="java">//实现了监听器的类，那么如果调用HttpUtils中的get()方//法，并且将View的实例作为监听器传入时，当网络访问得//到结果时，就会回头调用View类中的如下两个方法。public class View implements Listener{    @Override    public void onSucceed(String info) {        System.out.print(info);    }    @Override    public void onFailed(String info) {        System.out.print(info);    }}</code></pre><p>入口main函数</p><pre><code class="java">public class Main {    public static void main(String[] args) throws Exception {        View view = new View();        new HttpUtils().get(&quot;anyUrl&quot;, view);    }}</code></pre><p>点击run : 延时一秒后打印：<code>anyInfo</code><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手动撸一个基于数组的Stack</title>
    <link href="/2018/02/05/%E7%AE%97%E6%B3%95/%E6%89%8B%E5%8A%A8%E6%92%B8%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84Stack/"/>
    <url>/2018/02/05/%E7%AE%97%E6%B3%95/%E6%89%8B%E5%8A%A8%E6%92%B8%E4%B8%80%E4%B8%AA%E5%9F%BA%E4%BA%8E%E6%95%B0%E7%BB%84%E7%9A%84Stack/</url>
    
    <content type="html"><![CDATA[<pre><code>public class MyStack&lt;T&gt; {    private T t;    private int size;    private T[] items;    private int current;    private static final int DEFAUL_CAPACITY = 10;    //构造函数清除并确认stack初始容量为10    public MyStack() {        clear();        ensureCapacity(DEFAUL_CAPACITY);    }    //将stack的容量剪裁到size大小    public void trimToSize() {        ensureCapacity(size());    }    public int size() {        return size;    }    //清空栈，并让指针指到-1的地方。    public void clear() {        this.size = 0;        current = -1;    }    /**     * 重新确认stack的容量，并将stack中数据拷贝。     * @param newCapacity 新的容量     */    public void ensureCapacity(int newCapacity) {        if (newCapacity &lt; size) {            System.out.println(&quot;新的容量小于已存在的数组的容量&quot;);            return;        }        T[] oldItems = items;        items = (T[]) new Object[newCapacity];        for (int i = 0; i &lt; size; i++) {            items[i] = oldItems[i];        }    }    public boolean isEmpty() throws Exception {        if (current == 0) {            return true;        } else if (current &gt; 0) {            return false;        } else {            throw new Exception(&quot;the pointer of the stack is below 0&quot;);        }    }    public boolean isFull() throws Exception {        if (current &gt; 0) {            return current == size() - 1;        } else {            return false;        }    }    public T pop() throws Exception {        if (isEmpty()) {            throw new Exception(&quot;the stack is empty now&quot;);        }        size--;        return items[current--];    }    public T top() throws Exception {        if(isEmpty()){            throw new Exception(&quot;the stack is empty now&quot;);        }        return items[current];    }    public void push(T x) throws Exception {        if (isFull()) {            ensureCapacity(size() * 2);        }        items[++current] = x;        size++;    }}</code></pre><hr><p>入口函数测试：</p><pre><code>public class Main {    public static void main(String []args) throws Exception {        MyStack&lt;Integer&gt; stack=new MyStack&lt;&gt;();        stack.push(10);        stack.push(9);        stack.push(8);        stack.push(7);        stack.push(6);        stack.push(5);        stack.push(4);        stack.push(3);        stack.push(2);        stack.push(1);        stack.push(0);        stack.push(-1);        stack.push(-2);        System.out.println(&quot;The size of the stack is &quot;+stack.size());        int a=stack.pop();        System.out.println(&quot;The size of the stack is &quot;+stack.size());        int b=stack.top();        System.out.println(&quot;a =&quot;+a);        System.out.println(&quot;The top of the stack is &quot;+b);    }}</code></pre><p>打印：</p><pre><code>The size of the stack is 13The size of the stack is 12a =-2The top of the stack is -1</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现LinkedList</title>
    <link href="/2018/02/03/%E7%AE%97%E6%B3%95/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0LinkedList/"/>
    <url>/2018/02/03/%E7%AE%97%E6%B3%95/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0LinkedList/</url>
    
    <content type="html"><![CDATA[<pre><code>public class MyLinkedList&lt;T&gt; implements Iterable&lt;T&gt;{    //链表大小    private int size;    //修改次数    private int modCount=0;    //链表头结点    private Node&lt;T&gt; beginMarker;    //链表尾结点    private Node&lt;T&gt; endMarker;    //构造方法中清除链表    public MyLinkedList(){        clear();    }    @Override    public Iterator&lt;T&gt; iterator() {        return new LinkedListIterator();    }    /**     * Node就是结点     * @param &lt;T&gt;传入的泛型参数     */    private static class Node&lt;T&gt;{        public T data;        public Node&lt;T&gt; previous;        public Node&lt;T&gt; next;        public Node(T data,Node&lt;T&gt; previous,Node&lt;T&gt; next){            this.data=data;            this.previous=previous;            this.next=next;        }    }    /**     * clear(),清除链表，重新申请头尾结点，并让头尾结点相连。     */    public void clear(){        beginMarker=new Node&lt;&gt;(null,null,null);        endMarker=new Node&lt;&gt;(null,beginMarker,null);        beginMarker.next=endMarker;        size=0;        modCount++;    }    //直接返回链表大小    public int size(){        return size;    }    //判断链表是否是空，注意！只要链表长度为0就是空链表，链表的头结点和尾结点不算。    public boolean isEmpty(){        return size==0;    }    public boolean add(T x){        add(size(),x);        return true;    }    public void add(int index,T x){        addBefore(getNode(index),x);    }    public T get(int index){        return getNode(index).data;    }    /**     * 在index处找到对应的Node,将新值赋值给Node的data。     * @param index 要重新赋值的位置     * @param newVal 传入的新的数据     * @return 返回旧的数据     */    public T set(int index,T newVal){        Node&lt;T&gt; p=getNode(index);        T oldVal=p.data;        p.data=newVal;        return oldVal;    }    public T remove(int index){        return remove(getNode(index));    }    /**     * 添加一个数据x到结点p的前面，即在结点p前面生成一个新的结点newNode     * newNode的头指针指向p结点原先头指针指向的结点的尾指针：p.previous.next     * newNode的尾指针指向p结点的头指针：p.previous     * @param p 将数据装入结点Node中，并放到结点p的前面     * @param x 数据     */    private void addBefore(Node&lt;T&gt; p,T x){        Node&lt;T&gt; newNode=new Node&lt;&gt;(x,p.previous,p);        newNode.previous.next=newNode;        p.previous=newNode;        size++;        modCount++;    }    /**     *将p结点的头指针指向的结点赋值给p结点的尾指针指向的结点的头指针，     *将p结点的尾指针指向的结点赋值给p结点的头指针指向的结点的尾指针     *     *即：将p结点的前结点的尾和p结点的后结点的头相连。     * @param p 要删除的结点     */    private T remove(Node&lt;T&gt; p){        p.next.previous=p.previous;        p.previous.next=p.next;        size--;        modCount++;        return p.data;    }    /**     * 判断index的位置是在链表前半部分还是后半部分。     * 若在前半部分，就从头结点开始往后遍历，直到遍历到index的位置的时候，返回该处的Node；     * 若在后半部分，就从尾结点开始往前遍历，直到遍历到index的位置的时候，返回该处的Node。     * @param index 要取得结点的位置     * @return     */    private Node&lt;T&gt; getNode(int index){        Node&lt;T&gt; p;        if (index&lt;0||index&gt;size()){            throw new IndexOutOfBoundsException();        }        if (index&lt;size()/2){            p=beginMarker.next;            for (int i=0;i&lt;index;i++){                p=p.next;            }        }else {            p=endMarker;            for (int i=size();i&gt;index;i--){                p=p.previous;            }        }        return p;    }    private class LinkedListIterator implements Iterator&lt;T&gt;{        private Node&lt;T&gt; current=beginMarker.next;        private int expectedModCount=modCount;        private boolean okToRemove=false;        @Override        public boolean hasNext() {            return current!=endMarker;        }        @Override        public T next() {            if (modCount!=expectedModCount){                throw new ConcurrentModificationException();            }            if (!hasNext()){                throw new NoSuchElementException();            }            T nextItem=current.data;            current=current.next;            okToRemove=true;            return nextItem;        }        @Override        public void remove() {            if(modCount!=expectedModCount){                throw new ConcurrentModificationException();            }            if (!okToRemove){                throw new IllegalStateException();            }            MyLinkedList.this.remove(current.previous);            okToRemove=false;            expectedModCount++;        }    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>手动实现ArrayList</title>
    <link href="/2018/02/03/%E7%AE%97%E6%B3%95/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0ArrayList/"/>
    <url>/2018/02/03/%E7%AE%97%E6%B3%95/%E6%89%8B%E5%8A%A8%E5%AE%9E%E7%8E%B0ArrayList/</url>
    
    <content type="html"><![CDATA[<pre><code>import java.util.Iterator;/** * 手动实现的一个ArrayList，封装了数组的一些常用操作**/public class MyArrayList&lt;T&gt; implements Iterable&lt;T&gt; {    //数组默认的长度为10    private static final int DEFAULT_CAPACITY=10;    //数组的大小    private int size;    //泛型T类型所代表的数组    private T[] theItems;    //构造方法用clear()来初始化数组    public MyArrayList(){        clear();    }    //初始化数组，让数组默认长度为10    public void clear() {        size=0;        ensureCapacity(DEFAULT_CAPACITY);    }    //返回数组的大小    public int size(){        return size;    }    public boolean isEmpty(){        return size()==0;    }    public void trimToSize(){        ensureCapacity(size());    }    public T get(int index){        if (index&lt;0||index&gt;size()){            throw new ArrayIndexOutOfBoundsException();        }        return theItems[index];    }    public T set(int index,T newVal){        if (index&lt;0||index&gt;=size){            throw new ArrayIndexOutOfBoundsException();        }        T old=theItems[index];        theItems[index]=newVal;        return old;    }    //重新给数组分配长度，for循环是用来拷贝数据的    private void ensureCapacity(int newCapacity) {        if (newCapacity&lt;size){            return;        }        T[] old=theItems;        theItems= (T[]) new Object[newCapacity];        for (int i=0;i&lt;size();i++){            theItems[i]=old[i];        }    }    public boolean add(T x){        add(size(),x);        return true;    }    //添加元素，for循环用于将index下标以及之后的元素    //都往后移一步。    public void add(int index,T x){        if (theItems.length==size()){            ensureCapacity(size()*2+1);        }        for(int i=size;i&gt;index;i--){            theItems[i]=theItems[i-1];        }        theItems[index]=x;        size++;    }    //删除元素，for循环用于将要删除的元素的后一个下标的位置    //一个一个往前移动，并用index+1下标的元素直接覆盖index下标的元素    public T remove(int index){        T removedItem=theItems[index];        for (int i=index;i&lt;size()-1;i++){            theItems[i]=theItems[i+1];        }        size--;        return removedItem;    }    @Override    public Iterator&lt;T&gt; iterator() {        return new ArrayListIterator();    }    private class ArrayListIterator implements Iterator&lt;T&gt;{        private int current=0;        @Override        public boolean hasNext() {            return current&lt;size();        }        @Override        public T next() {            if (!hasNext()){                throw new java.util.NoSuchElementException();            }            return theItems[current++];        }        @Override        public void remove() {            MyArrayList.this.remove(--current);        }    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>单例模式</title>
    <link href="/2018/01/30/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2018/01/30/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<pre><code>public class Singleton {    /**     * 饿汉模式     * 在类加载时就完成了静态对象的初始化，所以类加载较慢，但获取对象的速度较快     * 这种方式基于类加载机制，避免了多线程同步问题。     * 但是由于在类加载的时候就完成了单例对象的实例化，那么如果至始至终从未使用该实例，就造成了内存的浪费     **/    private static Singleton instance = new Singleton();    private Singleton() {    }    public static Singleton getInstance() {        return instance;    }}class Singleton2 {    /**     * 懒汉模式     * 在第一次调用getInstance（）方法时对静态对象进行初始化，虽然节约了资源，但是第一次初始化会慢一点     * 此外，如果多个线程调用此方法，就可能会new 出多个对象，无法工作     **/    private static Singleton2 instance;    private Singleton2() {    }    public static Singleton2 getInstance() {        if (null == instance) {            instance = new Singleton2();        }        return instance;    }}class Singleton3 {    /**     * 懒汉模式     * 可在多线程中正常工作，但是每一个getInstance方法都需要同步，造成了不必要的开销，而且大多时候我们不需要同步     * 所以不推荐使用该方法**/    private static Singleton3 instance;    private Singleton3(){    }    public static  synchronized Singleton3 getInstance(){        if (null==instance){            instance=new Singleton3();        }        return instance;    }}class Singleton4{/**double check双重检查模式（DCL） *  * 1：是为了不必要的同步（如果instance已经被初始化过，那么就没必要再同步初始化对象） * 2:锁保证了可见性，下面对instance的赋值，在退出同步后，instance的新值对别的线程是立刻可见的。 * 3:再一次非空判断是非常重要的，如果少了代码行3，其他线程由于依次通过了2，所以会各自创建各自的instance对象，单例模式失效 * 4：对象初始化，单线程中初始化对象没问题，但是多线程对正在初始化的对象的读写，由于初始化指令的重排序，会造成未完全 * 初始化就访问对象，造成不可控的问题。 *  * volatile是防止对象初始化过程中的指令重排序，防止对象分配内存后，还没完全初始化， * 而这时引用已经指向对象，同步块结束，另一个线程返回了instance，instance却还没初始化完成。 * * double check过程描述： * 比如说有100个线程同时调用getInstance方法，此时全部线程都进入getInstance的1，判断instance都为空之后 * ，全部线程都进入2，这时只有一个线程能够进入3，假设线程50进入了3，其他线程都暂时阻塞，线程50顺利经过3的判 * 断之后进入4，那么此时线程50拿到了Singleton4的初次初始化的对象instance，由于instance用了volatile，那么此 * 时instance的初始化指令不会被重排序，等instance对象完全初始化完之后，退出同步代码块，由于加锁 * 保证了instance的可见性，其他99条线程均看到了instance的新值，要么不会进入同步代码块，要么进入后立刻跳出 * 并返回正确的对象。 **/    private volatile static Singleton4 instance;    private Singleton4(){    }    public static Singleton4 getInstance(){        if (instance==null){//1            synchronized (Singleton4.class){//2                if (instance==null){//3                    instance=new Singleton4();//4                }            }        }        return instance;    }}class Singleton5{    /**     * 静态内部类单例模式     * 第一次加载Singleton5类的时候不会初始化instance，只有调用getInstance方法时，虚拟机加载     * SingletonHolder，并直接初始化instance.     * 优点：不仅能保证线程安全（SingletonHolder类只会加载一次，     * 那么private static final Singleton5 instance=new Singleton5();就只调用一次），而且还能     * 保证Singleton5类的唯一性**/    private Singleton5(){    }    public static Singleton5 getInstance(){        return SingletonHolder.instance;    }    private static class SingletonHolder{        private static final Singleton5 instance=new Singleton5();    }}</code></pre><p>关于内部类和静态内部类何时被加载：<a href="http://blog.csdn.net/davidluo001/article/details/50173823" target="_blank" rel="noopener">加载一个类时，其内部类是否同时被加载?静态内部类单例模式</a></p><p>关于double check为什么要用volatile关键字：<a href="https://stackoverflow.com/questions/7855700/why-is-volatile-used-in-double-checked-locking" target="_blank" rel="noopener">https://stackoverflow.com/questions/7855700/why-is-volatile-used-in-double-checked-locking</a></p><h2 id="结论：最好的单例模式是静态内部类单例模式"><a href="#结论：最好的单例模式是静态内部类单例模式" class="headerlink" title="结论：最好的单例模式是静态内部类单例模式"></a>结论：最好的单例模式是<code>静态内部类单例模式</code></h2><p></p>]]></content>
    
    
    <categories>
      
      <category>java设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ObjectAnimator与AnimatorSet</title>
    <link href="/2018/01/25/Android/ObjectAnimator%E4%B8%8EAnimatorSet/"/>
    <url>/2018/01/25/Android/ObjectAnimator%E4%B8%8EAnimatorSet/</url>
    
    <content type="html"><![CDATA[<hr><h2 id="title-ObjectAnimator实现动画的使用"><a href="#title-ObjectAnimator实现动画的使用" class="headerlink" title="title: ObjectAnimator实现动画的使用"></a>title: ObjectAnimator实现动画的使用</h2><hr><p>相对于ValueAnimator，ObjectAnimator显得更加智能，自动，和简便，有时为了实现简单的动画效果，用ObjectAnimator在代码上会更简约。<br>先看一下ValueAnimator最简单的实现：</p><pre><code class="java">button=findViewById(R.id.btn);//通过ofInt()静态方法来返回一个ValueAnimator实例。ValueAnimator valueAnimator=ValueAnimator.ofInt(button.getLayoutParams().width,500);//用ValueAnimator对象设置各种参数valueAnimator.setStartDelay(1000);valueAnimator.setDuration(2000);valueAnimator.setRepeatCount(ValueAnimator.INFINITE);valueAnimator.setRepeatMode(ValueAnimator.REVERSE);//添加动画更新监听器valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {    @Override    public void onAnimationUpdate(ValueAnimator animation) {        int currentValue= (int) animation.getAnimatedValue();        Log.d(TAG, String.valueOf(currentValue));        //在监听器的动画更新回调方法中，将传入的新的数值设置给对应的View的属性，实现View的属性的动态变换。        button.getLayoutParams().width=currentValue;        //View请求重新布局        button.requestLayout();    }});valueAnimator.start();</code></pre><p>四步：</p><ul><li>ofInt()获取ValueAnimator实例</li><li>设置valueAnimator参数</li><li>添加数据更新监听器，在监听器中手动对view的属性进行更改</li><li>start();</li></ul><hr><p>那么如果是ObjectAnimator呢？<br>简单多了：</p><pre><code class="java">ObjectAnimator objectAnimator=ObjectAnimator.ofFloat(button,            &quot;translationX&quot;,button.getTranslationX(),button.getTranslationX()+500);objectAnimator.setDuration(2000);objectAnimator.setRepeatCount(ValueAnimator.INFINITE);;objectAnimator.setRepeatMode(ValueAnimator.REVERSE);objectAnimator.start();</code></pre><p>三步：</p><ul><li>用ofFloat()返回一个ObjectAnimator对象，方法的参数：<ul><li>第一个是要改变的对象</li><li>第二个是该对象要改变的具体的属性，传入的是字符串，直接传入属性名，Button继承的View，所以有translationX。</li><li>startValue</li><li>endValue</li></ul></li><li>设置各个参数</li><li>start();<br>这里少了一步：设置数据更新监听器。<br>因为ObjectAnimator在内部帮我们实现了传入对象的property的改变，所以说他更智能，更简单。<br>效果：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-24f63a366c36e731.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ul><hr><h2 id="组合动画："><a href="#组合动画：" class="headerlink" title="组合动画："></a>组合动画：</h2><p>AnimationSet</p><pre><code class="java">//创建组合动画对象AnimatorSet animatorSet = new AnimatorSet();//创建平移动画对象ObjectAnimator objectAnimator = ObjectAnimator.ofFloat(button,        &quot;translationX&quot;, button.getTranslationX(), button.getTranslationX() + 500);objectAnimator.setDuration(2000);objectAnimator.setRepeatCount(ValueAnimator.INFINITE);objectAnimator.setRepeatMode(ValueAnimator.REVERSE);//创建X轴缩放对象ObjectAnimator scaleX = ObjectAnimator.ofFloat(button, &quot;scaleX&quot;, 1f, 1.2f);scaleX.setDuration(500);scaleX.setRepeatMode(ValueAnimator.REVERSE);scaleX.setRepeatCount(ValueAnimator.INFINITE);//创建Y轴缩放对象ObjectAnimator scaleY= ObjectAnimator.ofFloat(button,&quot;scaleY&quot;,1f,3f);scaleY.setRepeatCount(ValueAnimator.INFINITE);scaleY.setRepeatMode(ValueAnimator.REVERSE);scaleY.setDuration(500);//用一个playTogether（传入objectAnimator数组）把他们都联系起来、animatorSet.playTogether(objectAnimator,scaleX,scaleY);//start()；animatorSet.start();</code></pre><p>效果：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-068646b6e54fcd1e.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>ValueAnimator使用思路</title>
    <link href="/2018/01/25/Android/ValueAnimator%E4%BD%BF%E7%94%A8%E6%80%9D%E8%B7%AF/"/>
    <url>/2018/01/25/Android/ValueAnimator%E4%BD%BF%E7%94%A8%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<hr><p>ValueAnimator有三个方法来创建动画，分别是：</p><ul><li>ofInt();</li><li>ofFloat();</li><li>ofObject();</li></ul><h2 id="先看ofInt"><a href="#先看ofInt" class="headerlink" title="先看ofInt():"></a>先看ofInt():</h2><p>效果：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-c2826d981ff630b1.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>思路：</p><ul><li>通过ValueAnimaotr.ofInt(startValue,endValue)方法返回一个ValueAnimator对象，再给对象设置各种比如duration,repeatCount,repeatMode,StartDelay的参数。</li><li>最关键的是，要设置对象的.addUpdateListener(),该方法只要ValueAnimator传入的那个值在变化，回调方法就会不断地被回调，我们在这里就可以不断地调用更新View或者Layout某个属性或多个属性的方法，然后invalidate()来重新调用onDraw()，不断地更新视图。</li><li>最后调用ValueAnimator对象的.start()方法启动变化，这个方法一调用，他里面的value就马上变化，就会不停地回调UpdateListener的方法。<pre><code class="java">button=findViewById(R.id.btn);//通过ofInt()静态方法来返回一个ValueAnimator实例。ValueAnimator valueAnimator=ValueAnimator.ofInt(button.getLayoutParams().width,500);//用ValueAnimator对象设置各种参数valueAnimator.setStartDelay(1000);valueAnimator.setDuration(2000);valueAnimator.setRepeatCount(ValueAnimator.INFINITE);valueAnimator.setRepeatMode(ValueAnimator.REVERSE);//添加动画更新监听器valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {  @Override  public void onAnimationUpdate(ValueAnimator animation) {      int currentValue= (int) animation.getAnimatedValue();      Log.d(TAG, String.valueOf(currentValue));      //在监听器的动画更新回调方法中，将传入的新的数值设置给对应的View的属性，实现View的属性的动态变换。      button.getLayoutParams().width=currentValue;      //View请求重新布局      button.requestLayout();  }});valueAnimator.start();</code></pre></li></ul><h2 id="ofFloat"><a href="#ofFloat" class="headerlink" title="ofFloat()"></a>ofFloat()</h2><p>ofFloat()和ofInt()方法的思路是完全一样的，不同的是里面的估值不同，一个是<br><code>FloatEvaluator</code>一个是<code>IntEvaluator</code>，两者就是FloatEvaluator中从startValue到endValue的过渡会更加精确更加平滑，因为是精确到float了。</p><h2 id="ofObject"><a href="#ofObject" class="headerlink" title="ofObject()"></a>ofObject()</h2><p>效果：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-08630373da9aad75.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>思路：</p><ul><li>上述的两个方法都有系统默认实现的<code>FloatEvaluator</code>和<code>IntEvaluator</code>，而ofObject则是可以我们自己实现估值器。</li><li>创建需要进行动画的自定义View</li><li>创建数据实体类</li><li>继承TypeEvaluator，重写evaluate方法<br><img src="http://upload-images.jianshu.io/upload_images/7177220-d875c73959c022f4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ul><p>具体的是，通过View中的onDraw()方法，不断地在里面用valueAnimator的UpdateListener回调来更新小球的坐标数值并<code>invalidate（）</code>,小球的坐标包括了横坐标和纵坐标，如果用ofInt或者ofFloat的话，只能单一地渐变横坐标或者单一地渐变纵坐标，因此我们将坐标封装到Point实体类中：</p><pre><code class="java">public class Point {    private float x;    private float y;    public float getX() {        return x;    }    public float getY() {        return y;    }    public Point(float x, float y){        this.x=x;        this.y=y;    }}</code></pre><p>紧接着马上继承TypeEvaluator并重写evaluate方法，在该方法中对传入的Point的两个横纵坐标进行改变:</p><pre><code class="java">public class PointEvaluator implements TypeEvaluator&lt;Point&gt; {    @Override    public Point evaluate(float fraction, Point startValue, Point endValue) {        float x=startValue.getX()+fraction*(endValue.getX()-startValue.getX());        float y=startValue.getY()+fraction*(endValue.getY()-startValue.getY());        Point point=new Point(x,y);        return point;    }}</code></pre><p>接着是自定义View中的代码，在onDraw里面做文章：</p><pre><code class="java">public class RoundView extends View {    public RoundView(Context context) {        this(context, null);    }    public RoundView(Context context, @Nullable AttributeSet attrs) {        this(context, attrs, 0);    }    public RoundView(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {        this(context, attrs, defStyleAttr, 0);    }    public RoundView(Context context, @Nullable AttributeSet attrs, int defStyleAttr, int defStyleRes) {        super(context, attrs, defStyleAttr, defStyleRes);        paint = new Paint(Paint.ANTI_ALIAS_FLAG);        paint.setColor(Color.BLUE);    }    private static final float RADIUS = 70f;    private Point currnetPoint;    private Paint paint;    @Override    protected void onDraw(Canvas canvas) {        //我们这里完全通过Point类的数据来画圆，因此如果他是Null的话        //就是第一次画圆，我们做第一次画圆的初始化        if (currnetPoint == null) {            currnetPoint = new Point(RADIUS, RADIUS);            float x = currnetPoint.getX();            float y = currnetPoint.getY();            canvas.drawCircle(x, y, RADIUS, paint);            //拿到将要进行变化的Point的始态和末态            Point startPoint = new Point(RADIUS, RADIUS);            Point endPoint = new Point(700, 1000);            //用ofObject来创建ValueAnimator对象            ValueAnimator animator = ValueAnimator.ofObject(new PointEvaluator(), startPoint, endPoint);            //用animator对象设置各种参数            animator.setDuration(2000);            animator.setRepeatMode(ValueAnimator.REVERSE);            animator.setRepeatCount(ValueAnimator.INFINITE);            //用animator对象设置更新监听器,在onAnimationUpdate回调中对数据实体类进行更新，            //然后调用invalidate()。最后开启动画调用start()。            animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {                @Override                public void onAnimationUpdate(ValueAnimator animation) {                    currnetPoint = (Point) animation.getAnimatedValue();                    invalidate();                }            });            animator.start();        } else {            float x = currnetPoint.getX();            float y = currnetPoint.getY();            canvas.drawCircle(x, y, RADIUS, paint);        }    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TabLayout简单使用</title>
    <link href="/2018/01/22/Android/TabLayout%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/01/22/Android/TabLayout%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="简单的介绍TabLayout的常规用法"><a href="#简单的介绍TabLayout的常规用法" class="headerlink" title="简单的介绍TabLayout的常规用法"></a>简单的介绍TabLayout的常规用法</h2><p><strong>效果图：</strong><img src="http://upload-images.jianshu.io/upload_images/7177220-ff5e0d2a16fafebb.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" srcset="/img/loading.gif" alt=""></p><h3 id="布局："><a href="#布局：" class="headerlink" title="布局："></a><em>布局：</em></h3><p>布局上面就是很简单的采用上面TabLayout下面ViewPager的形式</p><h3 id="代码："><a href="#代码：" class="headerlink" title="代码："></a><em>代码：</em></h3><p>在xml中声名的viewPager需要调用<code>viewPager.setAdapter(adapter)</code>，那么TabLayout需要调用<code>tablayout.setUpwithViewPager(viewPager)</code><br>思路是：</p><ul><li>写findViewById（）找到这两个控件。</li><li>写一个类MyViewPagerAdapter继承FragmentPagerAdapter，ViewPager里面展示的内容当然的是用的Fragment.</li><li>那么就要写我们自己的Fragment类，用来放数据，放RecyclerView来装数据，创建一个BaseFragment。</li><li>创建一个MyFragment继承BaseFragment</li><li>创建RecyclerView的RvAdapter。</li></ul><hr><p>代码依次给出：</p><pre><code class="xml">&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;com.lovely_solory.super_william.cact.Activity_ViewPager&quot;&gt;    &lt;android.support.design.widget.AppBarLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;android.support.v7.widget.Toolbar            android:id=&quot;@+id/toolbar_activityViewPager&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;?attr/actionBarSize&quot;            android:minHeight=&quot;?attr/actionBarSize&quot;            app:layout_scrollFlags=&quot;scroll|enterAlways&quot;            app:navigationIcon=&quot;@drawable/ic_arrow_back_white_24dp&quot; /&gt;        &lt;android.support.design.widget.TabLayout            android:id=&quot;@+id/tabLayout&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot; /&gt;    &lt;/android.support.design.widget.AppBarLayout&gt;    &lt;android.support.v4.view.ViewPager        android:id=&quot;@+id/viewPager_activityViewPager&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt;</code></pre><hr><p>Activity:</p><pre><code class="java">public class Activity_ViewPager extends AppCompatActivity {    TabLayout tabLayout;    ViewPager viewPager;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity__view_pager);        initView();    }    private void initView() {        viewPager=findViewById(R.id.viewPager_activityViewPager);        tabLayout=findViewById(R.id.tabLayout);        viewPager.setAdapter(new MyViewPagerAdapter(this,this.getSupportFragmentManager()));        tabLayout.setupWithViewPager(viewPager);    }}</code></pre><p>FragmentPagerAdapter:</p><pre><code class="java">public class MyViewPagerAdapter extends FragmentPagerAdapter {    private static final int pageCount = 3;    private Context context;    public MyViewPagerAdapter(Context context, FragmentManager fm) {        super(fm);        this.context = context;    }    @Override    public Fragment getItem(int position) {        int type;        switch (position) {            case 0:                type = 0;                break;            case 1:                type = 1;                break;            case 2:                type = 2;                break;            default:                type = 0;                break;        }        return MyFragment.newInstance(type);    }    @Override    public int getCount() {        return pageCount;    }    @Nullable    @Override    public CharSequence getPageTitle(int position) {        switch (position) {            case 0:                return &quot;广场&quot;;            case 1:                return &quot;好友&quot;;            case 2:                return &quot;我&quot;;            default:                return &quot;广场&quot;;        }    }}</code></pre><p>BaseFragment:</p><pre><code class="java">public abstract class BaseFragment extends android.support.v4.app.Fragment{    @Nullable    @Override    public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) {        View view=inflater.inflate(R.layout.fragement_view_pager,container,false);        initView(view,savedInstanceState);        return view;    }    protected abstract int getLayoutResId();    protected void initView(View view,Bundle savedInstanceState){    }}</code></pre><p>MyFragment:</p><pre><code class="java">public class MyFragment extends BaseFragment {    private static final String a=&quot;william.cact&quot;;    private int type;    private RecyclerView rv;    private RvAdapter rvAdapter;    private List&lt;String&gt; rvContentList;    public static Fragment newInstance(int type){        Bundle args=new Bundle();        args.putInt(a,type);        MyFragment fragment=new MyFragment();        fragment.setArguments(args);        return fragment;    }    @Override    public void onCreate(@Nullable Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        type=getArguments().getInt(a);    }    @Override    protected int getLayoutResId() {        return R.layout.fragement_view_pager;    }    @Override    protected void initView(View view, Bundle savedInstanceState) {        //展示各种逻辑        rvContentList=new ArrayList&lt;&gt;();        for (int i=0;i&lt;20;i++){            rvContentList.add(&quot;我是第&quot;+i+&quot;组数据&quot;);        }        rvAdapter=new RvAdapter(this.getContext(),rvContentList);        rv=view.findViewById(R.id.rv);        rv.setLayoutManager(new LinearLayoutManager(view.getContext()));        rv.setAdapter(rvAdapter);    }}</code></pre><p>RecyclerView的适配器就不放代码了，比较简单。</p><hr><p>此外，TabLayout的标题部分不止可以显示文字，也可以显示自定义布局。主要用的方法是：<br><code>tabLayout.getTabAt(position).setCustomView(imageView/int layoutResId);</code></p><p>试一下在Activity下面加这些代码：</p><pre><code class="java">ImageView imageView = new ImageView(this);imageView.setImageResource(R.drawable.beauty);tabLayout.getTabAt(0).setCustomView(imageView);ImageView imageView1 = new ImageView(this);imageView1.setImageResource(R.drawable.ic_arrow_back_white_24dp);tabLayout.getTabAt(1).setCustomView(imageView1);</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7177220-08d1db697eaa1c7c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CoordinatorLayout配合AppBarLayout、CollapsingToolbarLayout、Toolbar使用</title>
    <link href="/2018/01/21/Android/CoordinatorLayout%E9%85%8D%E5%90%88AppBarLayout%E3%80%81CollapsingToolbarLayout%E3%80%81Toolbar%E4%BD%BF%E7%94%A8/"/>
    <url>/2018/01/21/Android/CoordinatorLayout%E9%85%8D%E5%90%88AppBarLayout%E3%80%81CollapsingToolbarLayout%E3%80%81Toolbar%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="这篇文章主要介绍的是CoordinatorLayout，AppBarLayout-CollapsingToolbarLayout和Toolbar的结合表现出的动态效果。"><a href="#这篇文章主要介绍的是CoordinatorLayout，AppBarLayout-CollapsingToolbarLayout和Toolbar的结合表现出的动态效果。" class="headerlink" title="这篇文章主要介绍的是CoordinatorLayout，AppBarLayout,CollapsingToolbarLayout和Toolbar的结合表现出的动态效果。"></a>这篇文章主要介绍的是CoordinatorLayout，AppBarLayout,CollapsingToolbarLayout和Toolbar的结合表现出的动态效果。</h2><p>效果如图：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-496a26d291106cde.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="20180121_142710.gif"></p><p><strong>首先介绍上述几个控件在使用的时候的注意点：</strong></p><ul><li>CoordinatorLayout：<ul><li>是一个FrameLayout</li></ul></li><li>AppBarLayout：<ul><li>是一个vertical的LinearLayout，其子View应通过<code>setScrollFlags(int)</code>或者xmL中的<code>app:layout_scrollFlags</code>来提供他们的Behavior。<ul><li>具体的<code>app:layout_scrollFlags</code>有这么几个： scroll, exitUntilCollapsed, enterAlways, enterAlwaysCollapsed, snap</li></ul></li><li>他必须严格地是CoordinatorLayout的子View，不然他一点作用都发挥不出来。</li><li>AppBarLayout下方的滑动控件，比如RecyclerView，NestedScrollView（与AppBarLayout同属于CoordinatorLayout的子View,并列的关系，）,必须严格地通过在xml中指出其滑动Behavior来与AppBarLayout进行绑定。通常这样：<code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;</code></li></ul></li><li>CollapsingToolbarLayout:<ul><li>是一个专门用来包裹Toolbar的控件，里面可以放置一个imageView和一个toolbar然后轻松地实现：随着滑动，图片和toolbar的标题也有动画。</li><li>内部的子View一般都要加上属性：app:layout_collapseMode=””，常用的是parallax，pin。parallax是视差滚动，用在imageView, pin是固定，用在toolbar。</li><li>用<code>setContentScrimColor(int)或者setContentScrim(drawable)</code>来设置内容纱布，就是当折叠到只剩下Toolbar的时候，用一个另外的图片或者颜色来设置toolbar的背景。</li></ul></li><li>Toolbar:<ul><li>他的title如果需要带有CollapsingToolbarLayout的动画的话，就要用collapsingToolbarLayout.setTitle(); 否则是没有动画的，其他的和toolbar平时一样。</li></ul></li></ul><p><strong>xml文件</strong>：</p><pre><code class="xml">&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt;    &lt;android.support.design.widget.AppBarLayout        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;android.support.design.widget.CollapsingToolbarLayout            android:layout_width=&quot;match_parent&quot;            android:id=&quot;@+id/collapsingToolbar&quot;            app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;            android:layout_height=&quot;wrap_content&quot;&gt;            &lt;ImageView                android:scaleType=&quot;centerCrop&quot;                android:src=&quot;@drawable/beauty&quot;                android:layout_width=&quot;match_parent&quot;                app:layout_collapseMode=&quot;parallax&quot;                android:layout_height=&quot;300dp&quot; /&gt;            &lt;android.support.v7.widget.Toolbar                android:id=&quot;@+id/toolbar&quot;                app:layout_collapseMode=&quot;pin&quot;                android:layout_width=&quot;match_parent&quot;                android:minHeight=&quot;?attr/actionBarSize&quot;                android:layout_height=&quot;?attr/actionBarSize&quot;&gt;            &lt;/android.support.v7.widget.Toolbar&gt;        &lt;/android.support.design.widget.CollapsingToolbarLayout&gt;    &lt;/android.support.design.widget.AppBarLayout&gt;    &lt;android.support.v4.widget.NestedScrollView        android:layout_width=&quot;match_parent&quot;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;        android:layout_height=&quot;wrap_content&quot;&gt;        &lt;TextView            android:text=&quot;@string/textContent&quot;            android:textSize=&quot;20sp&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot; /&gt;    &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7177220-e977b2e8b433d90f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br><strong>MainActivity:</strong></p><pre><code class="java">public class MainActivity extends AppCompatActivity {    Toolbar toolbar;    CollapsingToolbarLayout collapsingToolbarLayout;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.coordinatory_layout);        //toolbar        toolbar = findViewById(R.id.toolbar);        toolbar.setNavigationIcon(R.drawable.ic_arrow_back_white_24dp);        //Palette用来更漂亮地展示配色        Palette.from(BitmapFactory.decodeResource(getResources(),R.drawable.beauty))                .generate(new Palette.PaletteAsyncListener() {                    @Override                    public void onGenerated(@NonNull Palette palette) {                        int color=palette.getVibrantColor(getResources().getColor(R.color.colorAccent));                        collapsingToolbarLayout.setContentScrimColor(color);                        //因为我暂时没有找到比较好的透明状态栏来适配这一套效果布局。                        //因此就直接替换掉StatusBar的颜色，这样其实也蛮好看的。                        getWindow().setStatusBarColor(color);                    }                });        //CollapsingToolbarLayout        collapsingToolbarLayout = findViewById(R.id.collapsingToolbar);        collapsingToolbarLayout.setTitle(&quot;我是一个标题啊哈哈哈&quot;);    }}</code></pre><p>结束。</p><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CoordinatorLayout全面解析</title>
    <link href="/2018/01/21/Android/CoordinatorLayout%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/"/>
    <url>/2018/01/21/Android/CoordinatorLayout%E5%85%A8%E9%9D%A2%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzIzMjE1Njg4Mw==&mid=2650117781&idx=1&sn=187bcdbbbfa0610e131c03a0e8a0fbf5&chksm=f0980d29c7ef843f8e5614cb2907277913022f0376363310fe206b1bf413ffec025f593866af#rd" target="_blank" rel="noopener">Absfree的文章：彻底搞懂CoordinatorLayout</a></p><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CoodinatorLayout里放布局问题</title>
    <link href="/2018/01/17/Android/CoodinatorLayout%E9%87%8C%E6%94%BE%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98/"/>
    <url>/2018/01/17/Android/CoodinatorLayout%E9%87%8C%E6%94%BE%E5%B8%83%E5%B1%80%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>CoordinatorLayout是一个FrameLayout，也就是说如果不做特殊处理，里面的子布局是无法控制的，超过一个，就会糊在一起，但是CoordiatorLayout又很特殊，只有在作为layout.xml的顶层布局才能发挥他协调子view的作用。因此要控制他的多个子View，比如除了AppBarLayout之外，要在下面加一个TabLayout或者RecyclerView,就要在他们里面加上<code>app:layout_behavior=&quot;&quot;</code>属性</p><pre><code>&lt;android.support.v7.widget.RecyclerView    android:id=&quot;@+id/rv&quot;    android:layout_width=&quot;match_parent&quot;    app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;    android:layout_height=&quot;wrap_content&quot; /&gt;</code></pre><p>界面：<img src="http://upload-images.jianshu.io/upload_images/7177220-cc1660b2a345f2cb.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" srcset="/img/loading.gif" alt=""></p><p>那么他的布局文件可以这样：</p><pre><code>&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;com.lovely_solory.super_william.drawer.MainActivity&quot;&gt;        &lt;android.support.design.widget.AppBarLayout            android:id=&quot;@+id/appbar&quot;            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt;            &lt;android.support.v7.widget.Toolbar                android:id=&quot;@+id/toolbar&quot;                android:layout_width=&quot;match_parent&quot;                android:layout_height=&quot;200dp&quot;                android:background=&quot;#000&quot;                android:fitsSystemWindows=&quot;true&quot;                android:gravity=&quot;bottom&quot;                android:minHeight=&quot;?attr/actionBarSize&quot;                app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;                app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot;                app:titleTextColor=&quot;#ffff&quot; /&gt;        &lt;/android.support.design.widget.AppBarLayout&gt;    &lt;android.support.v7.widget.RecyclerView        android:id=&quot;@+id/rv&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt;</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>兼容问题</title>
    <link href="/2018/01/16/Android/%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/"/>
    <url>/2018/01/16/Android/%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>谷歌安卓官方文档中文教程：<a href="https://developer.android.com/training/material/compatibility.html?hl=zh-cn#Theme" target="_blank" rel="noopener">维护兼容性</a></p><p>比如：</p><ul><li>如果要保留与早期版本 Android 的兼容性，请您在运行时检查系统,然后再为下列的任何一个功能调用 API：</li></ul><pre><code>// Check if we&#39;re running on Android 5.0 or higherif (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {    // Call some material design APIs here} else {    // Implement this feature without material design}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>(转载)setFocusable、setEnabled、setClickable区别</title>
    <link href="/2018/01/15/Android/%5B%E8%BD%AC%E8%BD%BD%5DsetFocusable%E3%80%81setEnabled%E3%80%81setClickable%E5%8C%BA%E5%88%AB/"/>
    <url>/2018/01/15/Android/%5B%E8%BD%AC%E8%BD%BD%5DsetFocusable%E3%80%81setEnabled%E3%80%81setClickable%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<ol><li><strong>setClickable</strong>:  设置为true时，表明控件可以点击，如果为false，就不能点击；“点击”适用于鼠标、键盘按键、遥控器等；<br>注意，setOnClickListener方法会默认把控件的setClickable设置为true。</li></ol><ol start="2"><li><strong>setEnabled</strong>:  使能控件，如果设置为false，该控件永远不会活动，不管设置为什么属性，都无效；<br>设置为true，表明激活该控件，控件处于活动状态，处于活动状态，就能响应事件了，比如触摸、点击、按键事件等；</li></ol><p><em>setEnabled就相当于总开关一样，只有总开关打开了，才能使用其他事件。</em></p><ol start="3"><li><strong>setFocusable</strong> 使能控件获得焦点，设置为true时，并不是说立刻获得焦点，要想立刻获得焦点，得用requestFocus；<br>使能获得焦点，就是说具备获得焦点的机会、能力，当有焦点在控件之间移动时，控件就有这个机会、能力得到焦点。</li></ol><p>转载自：<a href="http://www.bubuko.com/infodetail-650092.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-650092.html</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JitPack极速发布Library使用手册</title>
    <link href="/2018/01/15/Android/JitPack%E6%9E%81%E9%80%9F%E5%8F%91%E5%B8%83Library%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2018/01/15/Android/JitPack%E6%9E%81%E9%80%9F%E5%8F%91%E5%B8%83Library%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<ol><li>新建一个library<br><img src="http://upload-images.jianshu.io/upload_images/7177220-f684af9859081854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li><li>添加项目android-maven插件</li></ol><ul><li><p>在project的gradle文件中</p><pre><code>buildscript { dependencies {  classpath &#39;com.github.dcendents:android-maven-gradle-plugin:2.0&#39; // Add this line</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7177220-f65d942ca4882d7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图示project的gradle"></p></li><li><p>在Library的gradle文件中</p><pre><code>apply plugin: &#39;com.github.dcendents.android-maven&#39;  group=&#39;com.github.YourUsername&#39;</code></pre><p>这里的YourUsername就是github的用户名。<br><img src="http://upload-images.jianshu.io/upload_images/7177220-c83e3fc84d7aea8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="图示library的gradle"></p></li></ul><ol start="3"><li>接下来是上传到github:<br><img src="http://upload-images.jianshu.io/upload_images/7177220-438ff0d5ff9e1fc2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li><li>push哪些文件上去呢？<br>官方实例：</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/7177220-f67fdb63bb2e6d92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="jitpack官方示例"><br>说明：第一个是project的整个gradle文件，第二个是library的整个包，后面的都是project的东西，不要放application的包进来，那是多余的。<br>5. 生成release，就是发布版<br><img src="http://upload-images.jianshu.io/upload_images/7177220-6b78a583086fb38f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>点release，进去发布。<br>6. 进入jitPack官网进行最后的操作<br><a href="https://jitpack.io/" target="_blank" rel="noopener">https://jitpack.io/</a><br><img src="http://upload-images.jianshu.io/upload_images/7177220-24d9b2bf089e347f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>把刚才的项目的github连接直接复制粘贴，他会自动搜索最近一次的release版，然后进行处理<br><img src="http://upload-images.jianshu.io/upload_images/7177220-589489d43189ad1b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>Get it变成绿色的时候就是完成了，点击。<br><img src="http://upload-images.jianshu.io/upload_images/7177220-ad0de8cad7ec2c72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>完成！</p><p>附上几个教程：<br><code>简书里的中文教程</code>：<br><a href="https://www.jianshu.com/p/e443456bb506" target="_blank" rel="noopener">Android 写自己的开源库，发布到 JitPack.io</a><br><a href="https://www.jianshu.com/p/b04ef4029b90" target="_blank" rel="noopener">AS快速上传Library到GitHub并通过JitPack打包集成</a><br><code>官方英文教程</code>：<br><a href="https://www.jitpack.io/docs/ANDROID/" target="_blank" rel="noopener">Publish an Android library</a><br><a href="https://github.com/jitpack/android-example" target="_blank" rel="noopener">Android-Example</a></p><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态方法给非静态变量赋值</title>
    <link href="/2018/01/14/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%BB%99%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/"/>
    <url>/2018/01/14/java%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E7%BB%99%E9%9D%9E%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E8%B5%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<pre><code>public class EasyToolbar {    //非静态变量    private Toolbar toolbar;    //私有构造方法    private EasyToolbar(Toolbar toolbar){        this.toolbar=toolbar;    }    //静态方法    //带返回值的静态方法，返回一个当前类的实例，并给非静态变量赋值    @NonNull    public static EasyToolbar findToolbarById(AppCompatActivity activity, int toolbarId){        Toolbar tb= activity.findViewById(toolbarId);        return new EasyToolbar(tb);    }}</code></pre><p>简直一波骚操作啊有没有！！<br>参考文章：<br><a href="http://blog.csdn.net/u012341052/article/details/47733969" target="_blank" rel="noopener">用小鸭子演示的静态方法给非静态变量赋值操作</a><br></p>]]></content>
    
    
    <categories>
      
      <category>java设计模式</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Toolbar使用手册</title>
    <link href="/2018/01/14/Android/Toolbar%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
    <url>/2018/01/14/Android/Toolbar%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<p>明确一点：toolbar不要设置setSupportActionBar();</p><pre><code>说三遍！：toolbar不要设置setSupportActionBar();         toolbar不要设置setSupportActionBar();         toolbar不要设置setSupportActionBar();</code></pre><blockquote><p>toolbar就是toolbar，不是actionBar~，而且用了setSupportActionBar之后api调用超级杂乱，因此我们就把Toolbar当做一个新的独立的控件就行了</p></blockquote><p>#文章目录：</p><ol><li>入门级配置</li><li>进阶设置</li><li>设置popup的背景颜色和字体颜色<br>##1. 入门级配置：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-ed2ed551eeba8669.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ol><pre><code>//toolbar//单独设置theme为黑色主题是为了让字体是白色的//minHeight标识最小高度，解决适配问题//fitsSystemWindows是为了不让Toolbar中的内容顶到状态栏的位置&lt;android.support.v7.widget.Toolbar    android:id=&quot;@+id/toolbar&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;wrap_content&quot;    android:background=&quot;@color/colorAccent&quot;    android:fitsSystemWindows=&quot;true&quot;    android:minHeight=&quot;?actionBarSize&quot;    android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; &gt;    &lt;ImageView        android:src=&quot;@drawable/ic_android_black_24dp&quot;        android:layout_width=&quot;wrap_content&quot;        android:layout_height=&quot;wrap_content&quot; /&gt;&lt;/android.support.v7.widget.Toolbar&gt;</code></pre><pre><code>//style//用的是Theme.AppCompat.DayNight.NoActionBar，黑色主题，无ActionBar&lt;resources&gt;    &lt;!-- Base application theme. --&gt;    &lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.DayNight.NoActionBar&quot;&gt;        &lt;!-- Customize your theme here. --&gt;        &lt;item name=&quot;colorPrimary&quot;&gt;@color/colorPrimary&lt;/item&gt;        &lt;item name=&quot;colorPrimaryDark&quot;&gt;@color/colorPrimaryDark&lt;/item&gt;        &lt;item name=&quot;colorAccent&quot;&gt;@color/colorAccent&lt;/item&gt;    &lt;/style&gt;&lt;/resources&gt;</code></pre><pre><code>public class MainActivity extends AppCompatActivity {    //这个是快速打Toast做的工具类    Toast_ toast_=new Toast_(this);    private static final String TAG = &quot;MainActivity&quot;;    Toolbar toolbar;    @Override    protected void onCreate(final Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        //设置透明statusBar        if (Build.VERSION.SDK_INT&gt;Build.VERSION_CODES.KITKAT){            WindowManager.LayoutParams layoutParams=getWindow().getAttributes();            layoutParams.flags=WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;        }        toolbar=findViewById(R.id.toolbar);//注意了,logo、navigationIcon、title、subtitle在xml中设置的话，//必须要用res-auto那个命名空间，默认的是app:开头的那个，否则设置无效//，这里为了方便就用代码来设置        toolbar.setTitle(&quot;标题&quot;);        toolbar.setSubtitle(&quot;副标题&quot;);        toolbar.setLogo(R.drawable.ic_android_black_24dp);        toolbar.inflateMenu(R.menu.menu_toolbar);        toolbar.setNavigationIcon(R.drawable.ic_arrow_back_black_24dp);        toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() {            @Override            public boolean onMenuItemClick(MenuItem item) {                switch (item.getItemId()){                    case R.id.delete:                        toast_.makeText(&quot;delete&quot;);                        break;                    case R.id.share:                        toast_.makeText(&quot;share&quot;);                        break;                    case R.id.search:                        toast_.makeText(&quot;search&quot;);                        break;                }                return false;            }        });        toolbar.setNavigationOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View v) {                toast_.makeText(&quot;navigationIcon&quot;);            }        });    }}</code></pre><ul><li>这里需要注意一个就是toolbar的xml属性中的<code>android:fitsSystemWindows=&quot;true&quot;</code>，官方描述：<code>adjusts the padding of this view to leave space for the system windows</code><br>他就是防止toolbar内容挤压到statusBar的属性，也可以用paddingTop=”25dp”来设置，不过这样会有低版本不兼容的问题，所以用fitSystemWindows是最佳方案。</li></ul><p>不用android:fitsSystemWindows=”true”的结果：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-3f09bb37a21d4551.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>toolbar的一半都和状态栏重合了…</p><p>到此基本的功能都能使用了，以下<code>进阶设置</code>是一些可能出现的需求：</p><hr><p>##2. 进阶设置：</p><ol><li>像微信的menu那样弹出的菜单不会遮挡住拓展按钮，而且还带小图标：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-864ad3313447f6a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>默认效果：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-ae18a463b5ae840e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>定义一个popup的style，然后再toolbar的属性的xml中指定<code>app:popupTheme=&quot;@style/popupTheme&quot;</code><br><code>style</code>如下<pre><code>//让菜单不会挡住拓展按钮&lt;style name=&quot;popupTheme&quot; parent=&quot;ThemeOverlay.AppCompat.Dark.ActionBar&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt;&lt;/style&gt;</code></pre>效果：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-b6dbb58ec4af80a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>接下来加图标：<pre><code>//模仿微信的扩展菜单带图标功能//通过反射来做的一个效果，可能再别的机型或者版本就不适配了//具体的反射内部什么情况我也不懂Menu menu=toolbar.getMenu();if (toolbar.getMenu().getClass().getSimpleName().equalsIgnoreCase(&quot;MenuBuilder&quot;)){ try{     Method method = menu.getClass().getDeclaredMethod(&quot;setOptionalIconsVisible&quot;, Boolean.TYPE);     method.setAccessible(true);     method.invoke(menu, true); }catch (Exception e){     e.printStackTrace(); }}//下面这个方案其实也可以，有机会再深究//if (menu.getClass().getSimpleName().equals(&quot;MenuBuilder&quot;)) {//    try {//        MenuBuilder menuBuilder = (MenuBuilder) menu;//        menuBuilder.setOptionalIconsVisible(true);//    } catch (Exception e) {//        e.printStackTrace();//    }//}</code></pre>因为我的图标都是白色的，所以我就把popup的style改成了Dark风格的，背景就是黑色的了，我的图标就看得清了：<pre><code>&lt;style name=&quot;popupTheme&quot; parent=&quot;ThemeOverlay.AppCompat.Dark&quot;&gt;     &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt;&lt;/style&gt;</code></pre>效果：<img src="http://upload-images.jianshu.io/upload_images/7177220-195f3a0410a70452.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ol><hr><p>##3.设置popup的背景颜色和字体颜色</p><pre><code>&lt;style name=&quot;popupTheme&quot; parent=&quot;ThemeOverlay.AppCompat.Dark&quot;&gt;    &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt;    //很简单，这两个设置就行，不过注意，是android:开头的    &lt;item name=&quot;android:background&quot;&gt;@color/colorPrimary&lt;/item&gt;    &lt;item name=&quot;android:textColor&quot;&gt;@color/colorAccent&lt;/item&gt;&lt;/style&gt;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7177220-b03ab4ab16f1b7e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><hr><blockquote><p>一切的方法都介绍完了，这么复杂的配置，一定要封装，我自己封装了toolbar，反手就是一个连接：<br><a href="https://github.com/William619499149/EasyToolbar2" target="_blank" rel="noopener">EasyToolbar</a></p></blockquote><p>还有一个Toolbar教程也说的不错：<a href="https://www.jianshu.com/p/e2ae6aaff696" target="_blank" rel="noopener">https://www.jianshu.com/p/e2ae6aaff696</a></p><hr><p>完<br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>防止迷路</title>
    <link href="/2018/01/13/View/%E9%98%B2%E6%AD%A2%E8%BF%B7%E8%B7%AF/"/>
    <url>/2018/01/13/View/%E9%98%B2%E6%AD%A2%E8%BF%B7%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="http://www.gcssloop.com/customview/CustomViewIndex/" target="_blank" rel="noopener">GcsSloop的安卓自定义View教程目录</a></p><p><a href="http://hencoder.com/ui-1-1/" target="_blank" rel="noopener">HenCoder Android 开发进阶: 自定义 View </a></p><blockquote><p><code>Carson_Ho</code>创作的android动画的超赞的学习博客：<br><a href="https://www.jianshu.com/p/2412d00a0ce4" target="_blank" rel="noopener">Android 属性动画：这是一篇很详细的 属性动画 总结&amp;攻略</a><br>真的非常的详细和通俗易懂，我的全部的动画知识在这里看的<br>包括：<br>  属性动画<br>    补间动画<br>      帧动画<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>View</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>TextInputLayout</title>
    <link href="/2018/01/12/Android/TextInputLayout/"/>
    <url>/2018/01/12/Android/TextInputLayout/</url>
    
    <content type="html"><![CDATA[<p>这个控件的两个优点：</p><ol><li>更加友好地显示提示</li><li>更友好地显示错误信息</li></ol><p>更加友好地显示提示：</p><pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;    xmlns:tools=&quot;http://schemas.android.com/tools&quot;    android:id=&quot;@+id/rl&quot;    android:layout_width=&quot;match_parent&quot;    android:layout_height=&quot;match_parent&quot;    tools:context=&quot;com.lovely_solory.super_william.mynotebook.MainActivity&quot;&gt;    &lt;android.support.design.widget.TextInputLayout        android:id=&quot;@+id/username&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_marginTop=&quot;30dp&quot;&gt;        &lt;EditText            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:hint=&quot;username&quot;            android:maxLength=&quot;25&quot;            android:maxLines=&quot;1&quot; /&gt;    &lt;/android.support.design.widget.TextInputLayout&gt;    &lt;android.support.design.widget.TextInputLayout        android:id=&quot;@+id/password&quot;        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_below=&quot;@id/username&quot;&gt;        &lt;EditText            android:layout_width=&quot;match_parent&quot;            android:layout_height=&quot;wrap_content&quot;            android:layout_marginTop=&quot;20dp&quot;            android:hint=&quot;password&quot;            android:maxLength=&quot;25&quot;            android:maxLines=&quot;1&quot; /&gt;    &lt;/android.support.design.widget.TextInputLayout&gt;    &lt;Button        android:layout_width=&quot;match_parent&quot;        android:layout_height=&quot;wrap_content&quot;        android:layout_below=&quot;@id/password&quot;        android:layout_marginTop=&quot;20dp&quot;        android:text=&quot;login&quot; /&gt;&lt;/RelativeLayout&gt;</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7177220-f4e76472a58ee3b5.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>更加友好地显示错误信息：<br>这部分需要代码来控制：</p><pre><code>public class MainActivity extends AppCompatActivity {    TextInputLayout edit_username, edit_password;    Button btn;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        edit_username = findViewById(R.id.username);        edit_password = findViewById(R.id.password);        btn = findViewById(R.id.btn);        btn.setOnClickListener(new View.OnClickListener() {            @Override            public void onClick(View view) {                String username = edit_username.getEditText().getText().toString();                String password = edit_password.getEditText().getText().toString();                if (username.isEmpty()) {                    edit_username.setErrorEnabled(true);                    edit_username.setError(&quot;请输入正确的用户名格式&quot;);                }                if (password.isEmpty()) {                    edit_password.setErrorEnabled(true);                    edit_password.setError(&quot;请输入正确的密码格式&quot;);                }                if (!username.isEmpty()&amp;&amp;!password.isEmpty())                {                    Toast.makeText(MainActivity.this,&quot;登录成功&quot;,Toast.LENGTH_SHORT).show();                }            }        });    }}</code></pre><p>效果：</p><ul><li><img src="http://upload-images.jianshu.io/upload_images/7177220-701d18496d75bd66.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>编译器和解释器是什么？</title>
    <link href="/2018/01/08/JVM/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2018/01/08/JVM/%E7%BC%96%E8%AF%91%E5%99%A8%E5%92%8C%E8%A7%A3%E9%87%8A%E5%99%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>编译器：将源程序代码翻译成机器语言（只翻译，执不执行再说）。<br>比如C语言中编写好的程序是<code>.c</code>文件，用记事本打开里面就是C语言的代码，用<code>编译器</code>编译之后就生成了<code>.exe</code>文件，<code>.exe</code>文件里面就是二进制的机器代码了。</p><p>解释器：直接处理并运行源程序，不把源程序翻译成机器语言。<br></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>指针记录的是什么？</title>
    <link href="/2018/01/07/C/%E6%8C%87%E9%92%88%E8%AE%B0%E5%BD%95%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <url>/2018/01/07/C/%E6%8C%87%E9%92%88%E8%AE%B0%E5%BD%95%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<p>程序中每个变量在内存中占有一个或多个字节，比如int占有4Bytes，那么把第一个字节的地址称为变量的地址，而指针记录的值就是第一个字节的地址。</p><ul><li><img src="http://upload-images.jianshu.io/upload_images/7177220-0e8c130638abdfa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></li></ul>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>方法（函数）中传入的参数有新的内存地址</title>
    <link href="/2018/01/07/C/%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%E4%B8%AD%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E6%96%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/"/>
    <url>/2018/01/07/C/%E6%96%B9%E6%B3%95%EF%BC%88%E5%87%BD%E6%95%B0%EF%BC%89%E4%B8%AD%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E6%9C%89%E6%96%B0%E7%9A%84%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>局部变量（在方法或函数中声名的变量）：</p><ol><li>自动存储期限：当方法返回后，将自动回收局部变量的内存地址。</li><li>程序块作用域：局部变量的作用域是从方法的开始到方法的结束。</li></ol><p>现实是：对传入的参数进行修改，如果不return的话是拿不到修改后的参数的，也就是对参数的修改是没有意义的。</p><p>代码证明：</p><pre><code>#include&lt;stdio.h&gt;void method(int i,int j){    i=999;    j=999;}int main() {    //声名两个变量并赋值。    int i=100;    int j=1;    //调用method方法并为i和j赋上新的值    method(i,j);    //打印i和j的值    printf(&quot;%d\n%d&quot;,i,j);    return 0;}</code></pre><p>打印：</p><pre><code>1001</code></pre><p>上述代码声名了两个int并赋值，随后在方法中给他们传递新的值，打印结果显示，跳出了方法之后，赋上的新的值丢失了。</p><hr><p><strong>为什么会这样</strong><br>###进入正题<br>下列代码列出了变量进入方法后内存地址的改变情况：</p><pre><code>#include&lt;stdio.h&gt;void method(int i,int j){    //打印传入的参数i和j的内存地址。    printf(&quot;传入方法后i和j的内存地址：%p  %p&quot;,&amp;i,&amp;j);}int main() {    //声名两个变量并赋值。    int i=100;    int j=1;    //打印i和j的指针（即内存地址），&amp;就是取址。    printf(&quot;i和j的内存地址：          %p  %p\n&quot;,&amp;i,&amp;j);    //调用method方法。    method(i,j);    return 0;}</code></pre><p>打印（前方高能）：</p><pre><code>i和j的内存地址：          0061FF2C  0061FF28传入方法后i和j的内存地址：0061FF10  0061FF14</code></pre><p><strong>惊呆了有木有！</strong><br>进入方法之后的参数，直接在方法中新申请了一个内存地址来保存传入的参数。</p><pre><code>//也就是void method(int a,int b){}//实际上在方法内部进行了void method(int a,int b){  int a=a;  int b=b;}//即重新申请了新的变量，因此才有了不同的内存地址！</code></pre><h2 id="结论：结论即标题，方法中传入的参数有新的内存地址，这就是为什么对参数的修改在跳出方法之后不会影响原本的变量。"><a href="#结论：结论即标题，方法中传入的参数有新的内存地址，这就是为什么对参数的修改在跳出方法之后不会影响原本的变量。" class="headerlink" title="##结论：结论即标题，方法中传入的参数有新的内存地址，这就是为什么对参数的修改在跳出方法之后不会影响原本的变量。"></a>##结论：结论即标题，方法中传入的参数有新的内存地址，这就是为什么对参数的修改在跳出方法之后不会影响原本的变量。</h2><p></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>检查数中重复出现的数字</title>
    <link href="/2018/01/07/%E7%AE%97%E6%B3%95/%E6%A3%80%E6%9F%A5%E6%95%B0%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <url>/2018/01/07/%E7%AE%97%E6%B3%95/%E6%A3%80%E6%9F%A5%E6%95%B0%E4%B8%AD%E9%87%8D%E5%A4%8D%E5%87%BA%E7%8E%B0%E7%9A%84%E6%95%B0%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>java语言实现：<br>定义一个长度为10的int数组并全部赋值为0，对x用while循环求模，并将所得的模作为元素的下标，并将1赋值给该元素，那么下一次循环遇到有元素的下标不为0的时候，说明正好遇到了重复元素，那么出现了重复的数字</p><pre><code>public class MainTest {    public static void main(String args[]) throws Exception {        checkRepeated(4564);    }    private static void checkRepeated(int x){        //初始化一个长度为10的数组并遍历赋值为0；        int[] a=new int[10];        for (int i:a){            i=0;        }        while (x&gt;0){            int tmp=x%10;            //如果该元素的值是0，说明正常。            if (a[tmp]==0){                a[tmp]=1;            }else {             //如果该元素的值不是0，说明之前在同样的数组下标的地            //方改变了元素的值，也就是出现了同样的模，就是出现了相同的数字。                    System.out.println(&quot;有相同的数字出现&quot;);                break;            }            //除以十，从个位开始一位一位往前排查            x=x/10;        }        if (x&lt;=0){            System.out.println(&quot;没有相同的数字出现&quot;);        }    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>常量</title>
    <link href="/2018/01/06/C/%E5%B8%B8%E9%87%8F/"/>
    <url>/2018/01/06/C/%E5%B8%B8%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p>注意一个坑：<br>定义常量的时候绝对不能在末尾加上;</p><pre><code>//直接这样定义就可以了#define FREEZING_PT 32.0#define SCALE_FACTOR (5.0/9.0)</code></pre><p>如果加上了分号；，会有意想不到的傻逼错误。<br></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>格式控制符</title>
    <link href="/2018/01/06/C/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6%E7%AC%A6/"/>
    <url>/2018/01/06/C/%E6%A0%BC%E5%BC%8F%E6%8E%A7%E5%88%B6%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p>格式控制符：<br>%d：用来输出int，d表示decimal，整数<br>%hd：用来输出short，short integer。<br>%ld：用来输出long<br>%s：用来输出String字符串<br>%c：用来输出char字符<br>%f：用来输出float浮点型</p><table><thead><tr><th></th><th>short</th><th>int</th><th>long</th><th>unsigned short</th><th>unsigned int</th><th>unsigned long</th></tr></thead><tbody><tr><td>八进制</td><td>–</td><td>–</td><td>–</td><td>%ho</td><td>%o</td><td>%lo</td></tr><tr><td>十进制</td><td>%hd</td><td>%d</td><td>%ld</td><td>%hu</td><td>%u</td><td>%lu</td></tr><tr><td>十六进制</td><td>–</td><td>–</td><td>–</td><td>%hx 或者 %hX</td><td>%x 或者 %X</td><td>%lx 或者 %lX</td></tr><tr><td>—</td><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><p>二进制，八进制，十六进制：</p><pre><code>//二进制：前面加上0b或者0Bint a=0b101011;int b=0B1001;</code></pre><pre><code>//十六进制：十六进制由数字 0~9、字母 A~F 或 a~f（不区分大小写）组成，//使用时必须以0x或0X（不区分大小写）开头int a=0X2Aint b=-0XA0int c=0xffff</code></pre><pre><code>//八进制：八进制由 0~7 八个数字组成，//使用时必须以0开头（注意是数字 0，不是字母 o）int a = 015;  //换算成十进制为 13int b = -0101;  //换算成十进制为 -65int c = 0177777;  //换算成十进制为 65535</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>查看基本数据类型所占的字节</title>
    <link href="/2018/01/06/Java/%E6%9F%A5%E7%9C%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%80%E5%8D%A0%E7%9A%84%E5%AD%97%E8%8A%82/"/>
    <url>/2018/01/06/Java/%E6%9F%A5%E7%9C%8B%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%89%80%E5%8D%A0%E7%9A%84%E5%AD%97%E8%8A%82/</url>
    
    <content type="html"><![CDATA[<pre><code>public class MainTest {    public static void main(String args[]) throws Exception {        System.out.println(&quot;int占的字节：&quot;+Integer.BYTES);        System.out.println(&quot;long占的字节：&quot;+Long.BYTES);        System.out.println(&quot;short占的字节：&quot;+Short.BYTES);        System.out.println(&quot;char占的字节：&quot;+Character.SIZE/8);        System.out.println(&quot;float占的字节：&quot;+Float.SIZE/8);        System.out.println(&quot;double占的字节：&quot;+Double.SIZE/8);    }}</code></pre><p>输出：</p><pre><code>int占的字节：4long占的字节：8short占的字节：2char占的字节：2float占的字节：4double占的字节：8</code></pre><p>注意.BYTES返回的是字节数byte，而.SIZE返回的是比特数bit，所以要除以8<br></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MediaMetadataRetriever获取mp3文件信息</title>
    <link href="/2018/01/05/Android/MediaMetadataRetriever%E8%8E%B7%E5%8F%96mp3%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF/"/>
    <url>/2018/01/05/Android/MediaMetadataRetriever%E8%8E%B7%E5%8F%96mp3%E6%96%87%E4%BB%B6%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>转发：<a href="http://blog.csdn.net/xiao5678yun/article/details/53838362" target="_blank" rel="noopener">http://blog.csdn.net/xiao5678yun/article/details/53838362</a></p><pre><code>MediaMetadataRetriever mmr = new MediaMetadataRetriever();  String str = getExternalStorageDirectory() + &quot;1.mp3&quot;;  Log.d(TAG, &quot;str:&quot; + str);  try {      mmr.setDataSource(str);      String title = mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_TITLE);     Log.d(TAG, &quot;title:&quot; + title);      String album = mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ALBUM);      Log.d(TAG, &quot;album:&quot; + album);      String artist = mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_ARTIST);      Log.d(TAG, &quot;artist:&quot; + artist);      String duration = mmr.extractMetadata(MediaMetadataRetriever.METADATA_KEY_DURATION); // 播放时长单位为毫秒      Log.d(TAG, &quot;duration:&quot; + duration);       byte[] pic = mmr.getEmbeddedPicture();  // 图片，可以通过BitmapFactory.decodeByteArray转换为bitmap图片} catch (Exception e) {      e.printStackTrace();  }</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>通过Annotation为按钮设置监听（ButterKnife的原理）</title>
    <link href="/2017/12/28/Java/%E9%80%9A%E8%BF%87Annotation%E4%B8%BA%E6%8C%89%E9%92%AE%E8%AE%BE%E7%BD%AE%E7%9B%91%E5%90%AC%EF%BC%88ButterKnife%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%89/"/>
    <url>/2017/12/28/Java/%E9%80%9A%E8%BF%87Annotation%E4%B8%BA%E6%8C%89%E9%92%AE%E8%AE%BE%E7%BD%AE%E7%9B%91%E5%90%AC%EF%BC%88ButterKnife%E7%9A%84%E5%8E%9F%E7%90%86%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>通过注解来为按钮设置监听，类似于黄油匕首（butterknife）。</p><p>###步骤：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-b7b8b87ead228acd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>①</p><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.FIELD)//注意这里两个元注解，RUNTIME保证运行时，保证可以被反射，FIELD表示目标是成员变量public @interface ListenerFor {    Class&lt;?extends ActionListener&gt; listener();}</code></pre><p>②</p><pre><code>public class ActionListenerInstaller {    public static void proccessAnnotations(Object object){        try {            Class cl=object.getClass();            for (Field f:cl.getDeclaredFields()){                f.setAccessible(true);                ListenerFor listenerFor=f.getAnnotation(ListenerFor.class);                //获取成员变量f的值                Object fieldObject=f.get(object);                if (listenerFor!=null&amp;&amp;fieldObject!=null&amp;&amp;                        fieldObject instanceof AbstractButton){                    //获取listenerFor里的元数据（是Class&lt;?extends ActionListener&gt;）                    Class&lt;?extends ActionListener&gt; listenerClass=listenerFor.listener();                    ActionListener actionListener=listenerClass.newInstance();                    AbstractButton button= (AbstractButton) fieldObject;                    button.addActionListener(actionListener);                }            }        }catch (Exception e){            e.printStackTrace();        }    }}</code></pre><p>③</p><pre><code>class OKListener implements ActionListener{    @Override    public void actionPerformed(ActionEvent e) {        JOptionPane.showMessageDialog(null,&quot;点击了确认按钮&quot;);    }}class CancelListener implements ActionListener{    @Override    public void actionPerformed(ActionEvent e) {        JOptionPane.showMessageDialog(null,&quot;点击了取消按钮&quot;);    }}public class MainTest {    private JFrame mainWin=new JFrame(&quot;使用注解绑定事件监听器&quot;);    //使用Annotation为按钮绑定事件监听器：    @ListenerFor(listener =OKListener.class )    private JButton okBtn=new JButton(&quot;确定&quot;);    @ListenerFor(listener = CancelListener.class)    private JButton cBtn=new JButton(&quot;取消&quot;);    public void init(){        JPanel jp=new JPanel();        jp.add(okBtn);        jp.add(cBtn);        mainWin.add(jp);        ActionListenerInstaller.proccessAnnotations(this);        mainWin.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);        mainWin.pack();        mainWin.setVisible(true);    }    public static void main(String args[]) throws Exception {        new MainTest().init();    }}</code></pre><p>运行：<br> <img src="http://upload-images.jianshu.io/upload_images/7177220-5ea8a243fefb5749.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-fd4cf955131b1c96.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/7177220-b75f7d75ec9cba4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>参考：《疯狂java讲义》</p><p></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>通过反射查看泛型信息</title>
    <link href="/2017/12/27/Java/%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9F%A5%E7%9C%8B%E6%B3%9B%E5%9E%8B%E4%BF%A1%E6%81%AF/"/>
    <url>/2017/12/27/Java/%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E6%9F%A5%E7%9C%8B%E6%B3%9B%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>#####通过泛型和反射避免强制类型转换：<br>下面这个代码是没问题的。</p><pre><code>Class clazz=Class.forName(&quot;java.util.Date&quot;);Date date= (Date) clazz.newInstance();</code></pre><p>但是这样也没问题，编译器不会报错，但是run肯定会报错。</p><pre><code>String string= (String) clazz.newInstance();</code></pre><p>结合泛型反射可以避免强制类型转换，让编译器帮我们检查：</p><pre><code>@SuppressWarnings(value = &quot;unchecked&quot;)public class MainTest {    public static void main(String args[]) throws Exception {        Class&lt;Date&gt; clazz= (Class&lt;Date&gt;) Class.forName(&quot;java.util.Date&quot;);        Date date=AFactory.getInstance(clazz);        String string=AFactory.getInstance(clazz);    }}class AFactory{    public static&lt;T&gt; T getInstance(Class&lt;T&gt; clazz){        try {            return clazz.newInstance();        }catch (Exception e){            e.printStackTrace();            System.out.println(&quot;wrong&quot;);            return null;        }    }}</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7177220-8470a3ad4ada80a2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>编译器不允许编译通过。<br>#####通过反射查看泛型信息。<br>获取普通的成员变量的信息：</p><pre><code>public class MainTest {    public static void main(String args[]) throws Exception {        Class&lt;Person&gt; clazz=Person.class;        Field field=clazz.getDeclaredField(&quot;name&quot;);        Class&lt;?&gt; a=field.getType();        System.out.println(a);    }}class Person{    private String name;}</code></pre><p>打印：<code>class java.lang.String</code><br>按上述方法获取泛型信息：</p><pre><code>public class MainTest {    public static void main(String args[]) throws Exception {        Class&lt;Person&gt; clazz=Person.class;        Field field=clazz.getDeclaredField(&quot;map&quot;);        Class&lt;?&gt; a=field.getType();        System.out.println(a);    }}class Person{    private Map&lt;String,Integer&gt; map;}</code></pre><p>打印：<code>java.util.Map</code>，获取不到泛型String和Interger的信息。</p><p>可以如下：</p><pre><code>public class MainTest {    public static void main(String args[]) throws Exception {        Class&lt;Person&gt; clazz=Person.class;        Field field=clazz.getDeclaredField(&quot;map&quot;);        Type type=field.getGenericType();        System.out.println(type.getTypeName());        if (type instanceof ParameterizedType){            ParameterizedType parameterizedType= (ParameterizedType) type;            Type rType=parameterizedType.getRawType();            System.out.println(&quot;原始类型：&quot;+rType);            Type[] tArgs=parameterizedType.getActualTypeArguments();            for (int i =0;i&lt;tArgs.length;i++){                System.out.println(&quot;第&quot;+i+&quot;个泛型类型是&quot;+tArgs[i]);            }        }else {            System.out.println(&quot;获取泛型类型出错&quot;);        }    }}class Person{    private Map&lt;Integer,String&gt; map;}</code></pre><p>打印：</p><pre><code>java.util.Map&lt;java.lang.Integer, java.lang.String&gt;原始类型：interface java.util.Map第0个泛型类型是class java.lang.Integer第1个泛型类型是class java.lang.String</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Proxy和Invocation动态代理和AOP代理</title>
    <link href="/2017/12/27/Java/Proxy%E5%92%8CInvocation%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CAOP%E4%BB%A3%E7%90%86/"/>
    <url>/2017/12/27/Java/Proxy%E5%92%8CInvocation%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%92%8CAOP%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>Proxy创建动态代理的两个方法：</p><pre><code>//方法一static Class&lt;?&gt; getProxyClass(ClassLoader loader, Class&lt;?&gt;...interfaces);//方法二static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt; interfaces, InvocationHander hander);</code></pre><p>方法一：创建一个动态代理类所对应的Class对象，该代理类将实现interfaces数组所指定的多个接口。第一个ClassLoader参数指定生成动态代理类的类加载器。<br>方法二：直接创建一个动态代理对象，该对象的实现类实现了interfaces数组指定的系列接口，执行代理对象的每一个方法时都会被替换成InvocationHandler接口(自己创建一个类实现该接口)的实例的invoke方法。（实际上方法一需要创建对象的话，也是要一个InvocationHandler对象的）。</p><hr><p>InvoactionHandler的使用方法：</p><pre><code>//接口public interface Person {    void walk();    void sayHello(String name);}</code></pre><pre><code>public class MyInvocationHandler implements InvocationHandler{    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {        System.out.println(&quot;---正在执行的方法：&quot;+method);        if (args!=null){            System.out.println(&quot;下面是执行该方法时传入的实参为：&quot;);            for (Object val:args){                System.out.println(val);            }        }else System.out.println(&quot;该方法没有实参&quot;);        return null;    }}</code></pre><pre><code>public class MainTest {    public static void main(String args[]) throws Exception {        InvocationHandler handler=new MyInvocationHandler();        //注意这里的Person是一个接口interface。        Person p= (Person) Proxy.newProxyInstance(Person.class.getClassLoader(),new Class[]{Person.class},handler);        p.walk();        p.sayHello(&quot;孙悟空&quot;);    }}</code></pre><p>AOP代理：<br>AOP代理可替代目标对象，AOP代理对象包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异：AOP代理里的方法可以在执行目标方法之前、之后插入一些通用处理。<br><img src="http://upload-images.jianshu.io/upload_images/7177220-7c740e313cc32be6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/512" srcset="/img/loading.gif" alt=""></p><p>例子：</p><ul><li><p>思路：创建Dog对象和他的GunDog实现类，创建InvocationHandler的实现类MyInvocationHandler, 在invoke方法中调用目标对象的方法，并且在方法前后加入自定义的Utils类的方法, 创建代理对象工厂类MyProxyFactory，用于生产代理对象。</p><pre><code>public interface Dog {  void info();  void run();}</code></pre><pre><code>public class GunDog implements Dog {  @Override  public void info() {      System.out.println(&quot;我是一只猎狗&quot;);  }  @Override  public void run() {      System.out.println(&quot;我奔跑迅捷&quot;);  }}</code></pre><pre><code>public class Util {  public void method1(){      System.out.println(&quot;----模拟第一个通用方法----&quot;);  }  public void method2(){      System.out.println(&quot;----模拟第二个通用方法----&quot;);  }}</code></pre><pre><code>public class MyInvocationHandler implements InvocationHandler {  //被代理的对象;  private Object target;  public void setTarget(Object object) {      this.target = object;  }  @Override  public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {      Util u = new Util();      u.method1();      //注意这里第一个参数不要放proxy进去,因为我们要为指定的target生成动态代理对象      //放proxy是新生成的动态代理对象。      Object result = method.invoke(target, args);      u.method2();      return result;  }}</code></pre><pre><code>public class MyProxyFactory {  public static Object getProxy(Object target){      //创建一个MyInvocationHandler对象      MyInvocationHandler handler=new MyInvocationHandler();      //设置指定的要生成动态代理的target对象      handler.setTarget(target);      //创建并返回一个动态代理对象。      return Proxy.newProxyInstance(target.getClass().getClassLoader(),target.getClass().getInterfaces(),handler);  }}</code></pre><pre><code>public class MainTest {  public static void main(String args[]) throws Exception {      GunDog dog=new GunDog();      Dog proxyDog= (Dog) MyProxyFactory.getProxy(dog);      proxyDog.info();      proxyDog.run();  }}</code></pre><p>打印：<br>```</p></li></ul><p>—-模拟第一个通用方法—-<br>我是一只猎狗<br>—-模拟第二个通用方法—-<br>—-模拟第一个通用方法—-<br>我奔跑迅捷<br>—-模拟第二个通用方法—-</p><p>```</p><p>###结论：动态代理模式让代码结构更加灵活，解耦。<br></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>泛型类型转换的问题</title>
    <link href="/2017/12/23/Java/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2017/12/23/Java/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<pre><code>String[] strings = new String[5];Object[] objects=strings;String a=new String();Object obj=a;</code></pre><p>这两段代码说明的是：如果A是B的子类，那么A可以直接转换成B类型，A类数组也可以直接转换成B类数组。</p><pre><code>List&lt;String&gt; list=new ArrayList&lt;&gt;();List&lt;Object&gt; objectList=list;</code></pre><p>但是这段代码是错误的，不同的泛型对象，就算A是B的子类，A泛型的类也不能转换成B泛型的相同的类。编译器在编译阶段就可以报错：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-b76ff663489cec3c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>总结：<br>如果Student是Person的子类，那么Student[ ]数组是Person[ ]数组的子类，但是G<Student>不是G<Person>的子类。<br>另：java不支持创建泛型数组比如List<String>[ ] lists=new ArrayList<String>[ ]{};是不存在的<br></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>volatile关键字</title>
    <link href="/2017/12/13/java%E5%B9%B6%E5%8F%91/volatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2017/12/13/java%E5%B9%B6%E5%8F%91/volatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>弄懂volatile之前首先确保弄懂了java内存模型，可参考我的整理<br><a href="http://www.jianshu.com/p/bc777f741a2f" target="_blank" rel="noopener">Java内存模型</a></p><p>volatile的作用如下：</p><ol><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li><li>禁止进行指令重排序。(涉及volatile变量的代码的前面和后面的代码不会进行重排序)。</li></ol><p>注意：</p><ol><li>volatile不保证被修饰的变量的操作的原子性（要保证操作的原子性建议使用同步:synchronized和Lock）。</li></ol><p>使用场景：</p><ul><li>标记状态量：<pre><code>volatile boolean flag = false;</code></pre></li></ul><p>while(!flag){<br>    doSomething();<br>}</p><p>public void setFlag() {<br>    flag = true;<br>}</p><pre><code></code></pre><p>//保证了线程1的语句一一定在语句二之前执行（因为volatile禁止重排序），<br>// 否则可能会线程1的语句二先执行，这时线程2的while循环跳出，<br>// 立刻执行doSomethingWithConfig(context);<br>// 此时context还没赋值，出现空指针异常。<br>volatile boolean inited = false;<br>//线程1:<br>context = loadContext();  //语句一<br>inited = true;            //语句二</p><p>//线程2:<br>while(!inited ){<br>sleep()<br>}<br>doSomethingWithConfig(context);</p><pre><code>* double check:</code></pre><p>class Singleton{<br>    private volatile static Singleton instance = null;</p><pre><code>private Singleton() {}public static Singleton getInstance() {    if(instance==null) {        synchronized (Singleton.class) {            if(instance==null)                instance = new Singleton();        }    }    return instance;}</code></pre><p>}</p><p>```<br>参考：<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a><br></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Java内存模型</title>
    <link href="/2017/12/13/java%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <url>/2017/12/13/java%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：海子的博客<a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></p></blockquote><p>三个重点：</p><ol><li>原子性</li><li>可见性</li><li>有序性</li></ol><p>讨论这三点之前先说一下计算机的内存模型：</p><ul><li>CPU对程序的指令的执行速度远远大于从内存中读写数据的速度<br>所以如果让CPU直接访问内存来读数据再写结果去内存，就会效率非常低下。因此就有了高速缓存——Cache这个东西。<br><img src="http://upload-images.jianshu.io/upload_images/7177220-48f02af6c3ff8f57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="CPU和内存之间存在高速缓存，他们之间的工作关系"></li><li>举个例子看看他们怎么工作的:<br><code>i=0;</code><br>单线程运行代码：<code>i=i+1;</code><br>步骤是：Cache从主存读取<code>i=0</code>， CPU从Cache读取i，CPU运算i=i+1， 将结果<code>i=1</code>写入Cache，Cache再将结果<code>i=1</code>写入主存。</li><li><em>单线程没问题，但是多线程中*</em>，比如开启两个线程分别执行<code>i=i+1;</code>，我们希望结果是<code>i=2</code></li><li><em>但是结果可能会是这样：*</em><br>线程1的cache从内存读i=0,这时，没有马上计算，CPU马上换到线程2读取，这是i仍然是0，然后线程1和线程2的cache再分别把i=0给cpu进行计算都得到i=1，然后分别刷新到主存中，最后的结果是<code>i=1</code></li></ul><p><strong>因此</strong><br>出现了缓存一致性协议，意思是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。</p><p>#现在进入正题：<br>java内存模型:<br>Java内存模型规定所有的变量都是存在主存当中，每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。<br>图示：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-e254498e647951dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><ol><li>原子性：</li></ol><ul><li>在Java中，对基本数据类型变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。</li><li>只有简单的读取、赋值（而且必须是将数字赋值给某个变量，变量之间的相互赋值不是原子操作）才是原子操作。<pre><code>x = 10;         //语句1y = x;         //语句2x++;           //语句3x = x + 1;     //语句4</code></pre>哪几个是原子操作？只有语句一是原子性操作；其他操作除了读取之外都有赋值，因此不是原子性。<br>如果要实现大范围的原子性操作，就要用同步。</li></ul><ol start="2"><li>可见性：<br>在CPU读写数据的时候，不同线程之间对变量的更行可能没有及时刷新到内存中去，因此其他线程不能立刻看到修改后的变量，这是不可见的。java中提供了两种实现可见性的方法：<br>1、volatile关键字：当一个变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。<br>2、同步：synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，<strong>并且在释放锁之前会将对变量的修改刷新到主存当中</strong>。因此可以保证可见性。</li><li>有序性：<br>为了提高程序的运行效率，没有数据依赖性的代码段可能会被处理器重新排序，也叫指令重排序。（但是有数据依赖性的代码就不会重排序）</li></ol><p></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>transient关键字</title>
    <link href="/2017/12/13/Java/transient%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <url>/2017/12/13/Java/transient%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    
    <content type="html"><![CDATA[<p>###作用：<br>transient关键字可以让实现了Serializable接口的类中的属性不被序列化。<br>就是哪个属性加了transient，他就不能被序列化。<br>代码证明：<br>bean:</p><pre><code>public class User implements Serializable{    private  String name;    private transient int age;    public  String getName() {        return name;    }    public void setName(String tname) {        name = tname;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }}</code></pre><p>主函数：</p><pre><code>import java.io.*;public class MainTest {    public static void main(String args[]) {        //初始化用户        User user=new User();        user.setAge(18);        user.setName(&quot;ABC&quot;);        System.out.println(&quot;read before Serializable&quot;);        System.out.println(&quot;name: &quot;+user.getName());        System.out.println(&quot;age: &quot;+user.getAge());        File file=new File(&quot;D:/user.txt&quot;);        if (file.exists()){            System.out.println(&quot;\nfile delete? : &quot;+file.delete());        }        //序列化        try {            ObjectOutputStream objo=new ObjectOutputStream(new FileOutputStream(&quot;D:/user.txt&quot;));            objo.writeObject(user);;            objo.flush();            objo.close();        }catch (Exception e){            e.printStackTrace();        }        //反序列化        try {            ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(&quot;D:/user.txt&quot;));            User abc= (User) inputStream.readObject();            System.out.println(&quot;\nread after Serializable&quot;);            System.out.println(&quot;name: &quot;+abc.getName());            System.out.println(&quot;age: &quot;+abc.getAge());        }catch (Exception e){            e.printStackTrace();        }    }}</code></pre><p>打印：</p><pre><code>read before Serializablename: ABCage: 18file delete? : trueread after Serializablename: ABCage: 0</code></pre><p>在这里的private transient int age;就没有序列化成功。</p><p>此外，static变量修饰的静态变量，也不能被Serializable序列化。我修改了name属性为static变量，重新测试：</p><pre><code>public class MainTest {    public static void main(String args[]) {        //初始化用户        User user=new User();        user.setAge(18);        User.setName(&quot;ABC&quot;);        System.out.println(&quot;read before Serializable&quot;);        System.out.println(&quot;name: &quot;+user.getName());        System.out.println(&quot;age: &quot;+user.getAge());        File file=new File(&quot;D:/user.txt&quot;);        if (file.exists()){            System.out.println(&quot;\nfile delete? : &quot;+file.delete());        }        //序列化        try {            ObjectOutputStream objo=new ObjectOutputStream(new FileOutputStream(&quot;D:/user.txt&quot;));            objo.writeObject(user);;            objo.flush();            objo.close();        }catch (Exception e){            e.printStackTrace();        }        //反序列化        try {            //在这里改变User的类变量Name属性            User.setName(&quot;DEF&quot;);            ObjectInputStream inputStream=new ObjectInputStream(new FileInputStream(&quot;D:/user.txt&quot;));            User abc= (User) inputStream.readObject();            System.out.println(&quot;\nread after Serializable&quot;);            System.out.println(&quot;name: &quot;+abc.getName());            System.out.println(&quot;age: &quot;+abc.getAge());        }catch (Exception e){            e.printStackTrace();        }    }}</code></pre><p>打印：</p><pre><code>read before Serializablename: ABCage: 18file delete? : trueread after Serializablename: DEFage: 0</code></pre><p>本应该name还是ABC的，但是却出来了DEF，说明这里的name根本不能被序列化，我们读取的是存在内存中的静态变量。</p><p></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对象与垃圾回收</title>
    <link href="/2017/12/12/JVM/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <url>/2017/12/12/JVM/%E5%AF%B9%E8%B1%A1%E4%B8%8E%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    
    <content type="html"><![CDATA[<ul><li>gc只负责回收堆内存中的对象，不会回收任何物力资源（如数据库连接，网络IO等）。</li><li>程序无法精确控制gc的运行，gc会在合适的时候进行。当对象永久失去引用后（=null），系统就会在合适的时候回收它所占的内存。</li><li>在gc回收任何对象之前，总会调用它的finalize方法，该方法可能使对象重新获得引用，导致gc取消回收。</li></ul><p>##对象在内存中的状态：</p><ol><li>可达状态：对象被创建后，有一个以上的变量引用它，程序可通过引用变量来调用该对象的实例变量和方法。</li><li>可恢复状态：程序中某个对象不再有任何变量引用它，它进入可恢复状态，gc准备回收该对象所占的内存，在回收该对象之前，系统会调用所有可恢复状态对象的finalize方法进行资源清理。 如果在finalize方法中对象重新获得引用，这个对象变成可达状态，否则进入不可达状态。</li><li>不可达状态：这个对象与所有的引用变量的关联被切断，且系统调用了所有对象的finalize方法后该对象依然没有变成可达状态，该对象就永远地失去引用，变成不可达状态。只有一个对象处于不可达状态是，系统才会真正回收该对象所占有的资源。</li></ol><p>##强制垃圾回收：<br>当对象失去引用后，系统何时调用finalize方法，何时变成不可达状态，何时被gc回收，程序都无法控制，程序只能控制一个对象何时不再被变量引用。<br>但是可以通过：</p><ul><li>System.gc();</li><li>Runtim.getRuntime().gc();<br>来通知系统进行垃圾回收，系统是否进行垃圾回收不确定。</li></ul><p>##finalize()方法<br>特点：</p><ul><li>不要主动调用某个对象的finalize方法，这个方法是gc调用的。</li><li>finalize方法的调用具有不确定性，不要把它当作一定会被执行的方法。</li><li>当JVM执行可恢复对象的finalize()方法时，可能时该对象或系统中其他对象重新变成可达状态。</li><li>当JVM执行fianlize方法出现异常时，gc不会报告异常，程序继续执行。</li></ul><p>参考《疯狂java讲义》<br></p>]]></content>
    
    
    <categories>
      
      <category>JVM</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>BroadcastReceiver</title>
    <link href="/2017/12/11/Android/BroadcastReceiver/"/>
    <url>/2017/12/11/Android/BroadcastReceiver/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/liuhe688/article/details/6955668" target="_blank" rel="noopener">基础总结篇之五：BroadcastReceiver应用详解</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java线程池总结</title>
    <link href="/2017/12/09/java%E5%B9%B6%E5%8F%91/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E7%BB%93/"/>
    <url>/2017/12/09/java%E5%B9%B6%E5%8F%91/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我学习线程池的第一篇讲的最好、最明白的文章：<br><a href="http://blog.csdn.net/javazejian/article/details/50890554" target="_blank" rel="noopener">java&amp;android线程池-Executor框架之ThreadPoolExcutor&amp;ScheduledThreadPoolExecutor浅析（多线程编程之三）</a></p></blockquote><blockquote><p>另外一个是能快速帮你回忆的总结性文章，说的也不错：<br><a href="https://juejin.im/post/5a28b37c6fb9a044fc44a103" target="_blank" rel="noopener">通俗易懂，各常用线程池执行的-流程图</a></p></blockquote><p>ThreadPoolExecutor的构造方法的参数：</p><pre><code>    public ThreadPoolExecutor(int corePoolSize,                              int maximumPoolSize,                              long keepAliveTime,                              TimeUnit unit,                              BlockingQueue&lt;Runnable&gt; workQueue,                              ThreadFactory threadFactory,                              RejectedExecutionHandler handler) {        ......    }</code></pre><p>从中总结了一个非常非常重要的流程图：（没有理解这个，谈线程池怎么都谈不明白）<br><img src="http://upload-images.jianshu.io/upload_images/7177220-d8241458820e32d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程的同步</title>
    <link href="/2017/12/08/Java/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/"/>
    <url>/2017/12/08/Java/%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<p>这个博客讲的非常好<br><a href="http://blog.csdn.net/yangwenxue_admin/article/details/44904457" target="_blank" rel="noopener">java中同步(synchronized)详解</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Handler,Looper,-Message,-MessageQueue的文章收藏</title>
    <link href="/2017/12/08/Android/%E5%85%B3%E4%BA%8EHandler,Looper,-Message,-MessageQueue%E7%9A%84%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/"/>
    <url>/2017/12/08/Android/%E5%85%B3%E4%BA%8EHandler,Looper,-Message,-MessageQueue%E7%9A%84%E6%96%87%E7%AB%A0%E6%94%B6%E8%97%8F/</url>
    
    <content type="html"><![CDATA[<p>Hongyang:<br><a href="http://blog.csdn.net/lmj623565791/article/details/38377229" target="_blank" rel="noopener">Android 异步消息处理机制 让你深入理解 Looper、Handler、Message三者关系</a></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p>拭心：<br><a href="http://blog.csdn.net/u011240877/article/details/72892321" target="_blank" rel="noopener">Android 进阶14：源码解读 Android 消息机制（ Message MessageQueue Handler Looper）</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Handler可能引起的内存泄漏</title>
    <link href="/2017/12/04/Android/Handler%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <url>/2017/12/04/Android/Handler%E5%8F%AF%E8%83%BD%E5%BC%95%E8%B5%B7%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考文章<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1106/1922.html" target="_blank" rel="noopener">http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2014/1106/1922.html</a></p></blockquote><ol><li><p>在用handler的时候如果这么用就一定会发生内存泄漏：</p><pre><code>public class MainActivity extends AppCompatActivity { private Handler myHandler=new Handler(){     @Override     public void handleMessage(Message msg) {         super.handleMessage(msg);     } }; @Override protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main); }}</code></pre></li></ol><ul><li><p>原因：这个myHandler对象是由匿名内部类创建而来的，然后内部类默认持有外部类的引用，假设我们用这个handler发送一个10分钟延迟的消息出去，然后马上关闭当前的activity，那么这个message就会在messageQueue停留10分钟，而messageQueue有这个handler的引用，handler又有了外部类MainActivity的引用，因此MainActivity就算退出了，还是无法被gc回收，造成内存泄漏。</p></li><li><p>解决方法：内部类不行，那么就用静态内部类，静态内部类的好处是静态内部类完全不依赖外部类，也就是没有外部类的引用，也就不会造成内存泄漏！</p></li></ul><p>配合弱引用，代码如下：</p><pre><code>public class MainActivity extends AppCompatActivity {    static class MyHandler extends Handler{        //Activity的弱引用        private WeakReference&lt;AppCompatActivity&gt; weakReference;        public MyHandler(AppCompatActivity activity){            weakReference=new WeakReference&lt;AppCompatActivity&gt;(activity);        }        @Override        public void handleMessage(Message msg) {            AppCompatActivity activity=weakReference.get();            //做一个判断，如果Activity已经被gc回收，就不再执行该方法。            if (activity!=null){                //handle your message            }        }    }    private MyHandler handler;    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        handler=new MyHandler(this);        //handler.sendMessage(yourMsg);    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>静态变量何时被gc回收？</title>
    <link href="/2017/12/04/Android/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BD%95%E6%97%B6%E8%A2%ABgc%E5%9B%9E%E6%94%B6%EF%BC%9F/"/>
    <url>/2017/12/04/Android/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%BD%95%E6%97%B6%E8%A2%ABgc%E5%9B%9E%E6%94%B6%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="http://blog.csdn.net/yogkin/article/details/53404855" target="_blank" rel="noopener">http://blog.csdn.net/yogkin/article/details/53404855</a><br>结论：只要静态变量没有被销毁也没有=null，其对象就一直被保持引用，也即引用计数不可能是0，不会被垃圾回收。</p></blockquote><p>文中还有4个关于静态变量的点：</p><ol><li><p>静态变量在类被加载的时候分配内存。<br>类在什么时候被加载？<br>当我们启动一个app的时候，系统会创建一个进程，此进程会加载一个Dalvik VM的实例，然后代码就运行在DVM之上，类的加载和卸载，垃圾回收等事情都由DVM负责。也就是说在进程启动的时候，类被加载，静态变量被分配内存。</p></li><li><p>静态变量在类被卸载的时候销毁。<br>类在什么时候被卸载？<br>在进程结束的时候。<br>说明：一般情况下，所有的类都是默认的ClassLoader加载的，只要ClassLoader存在，类就不会被卸载，而默认的ClassLoader生命周期是与进程一致的，本文讨论一般情况。</p></li><li><p>Android中的进程什么时候结束<br>这个是Android对进程和内存管理不同于PC的核心——如果资源足够，Android不会杀掉任何进程，另一个意思就是进程随时可能会被杀掉。而Android会在资源够的时候，重启被杀掉的进程。也就是说静态变量的值，如果不做处理，是不可靠的，可以说内存中的一切都不可靠。如果要可靠，还是得保存到Nand或SD卡中去，在重启的时候恢复回来。<br>另一种情况就是不能把退出所有Activity等同于进程的退出，所以在用户点击图标启动应用的时候，以前存放于静态变量中的值，有可能还存在，因此要视具体情况给予清空操作。</p></li><li><p>Application也是一样不可靠<br>Application其实是一个单例对象，也是放在内存中的，当进程被杀掉，就全清空了，只不过Android系统会帮重建Application，而我们存放在Application的数据自然就没有了，还是得自己处理。<br></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>AIDL</title>
    <link href="/2017/12/03/Android/AIDL/"/>
    <url>/2017/12/03/Android/AIDL/</url>
    
    <content type="html"><![CDATA[<p>参考hongyang的博客：</p><blockquote><p><a href="http://blog.csdn.net/lmj623565791/article/details/38461079" target="_blank" rel="noopener">Android aidl Binder框架浅析</a></p></blockquote><p>#跨应用的进程间通信：<br>首先要有两个应用:<br>1、现在Android Studio里创建两个应用，两个module。<br>2、一个应用做client，一个应用做server。<br>3、实现client应用调用server应用中的服务。</p><p>开始动手：<br>###创建一个server应用：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-001f2e1b18d5e81b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"><br>Manifest文件：</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.lovely_solory.super_william.serviceaidl&quot;&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;service            android:name=&quot;.CalcService&quot;            android:enabled=&quot;true&quot;            android:exported=&quot;true&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;com.william.solory.service&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/service&gt;        &lt;activity android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;</code></pre><p>这个service就是我们待会从cilent通过Intent隐式调用的组件，因此我们直接自己指定一个action，记得exported属性要为true，否则外部不可访问。</p><p>2、创建.aidl文件:<br>右键-new-AIDL-AIDL FILE</p><pre><code>// ICalcAIDL.aidlpackage com.lovely_solory.super_william.serviceaidl;// Declare any non-default types here with import statementsinterface ICalcAIDL {    /**     * Demonstrates some basic types that you can use as parameters     * and return values in AIDL.     */    int add(int x,int y);    int min(int x,int y);}</code></pre><p>定义了两个方法，一个加法一个减法。</p><p>Service类:</p><pre><code>package com.lovely_solory.super_william.serviceaidl;import android.app.Service;import android.content.Intent;import android.os.IBinder;import android.os.RemoteException;import android.util.Log;public class CalcService extends Service {    private final  ICalcAIDL.Stub myBinder=new ICalcAIDL.Stub() {        @Override        public int add(int x, int y) throws RemoteException {            return x+y;        }        @Override        public int min(int x, int y) throws RemoteException {            return x-y;        }    };    public CalcService() {    }    private void printLog(String msg){        Log.d(&quot;******&quot;,msg);    }    @Override    public void onCreate() {        super.onCreate();        printLog(&quot;onCreate&quot;);    }    @Override    public void onRebind(Intent intent) {        super.onRebind(intent);        printLog(&quot;onRebind&quot;);    }    @Override    public boolean onUnbind(Intent intent) {        printLog(&quot;onUnbind&quot;);        return super.onUnbind(intent);    }    @Override    public void onDestroy() {        super.onDestroy();        printLog(&quot;onDestroy&quot;);    }    @Override    public IBinder onBind(Intent intent) {        // TODO: Return the communication channel to the service.        printLog(&quot;onBind&quot;);        return myBinder;    }}</code></pre><p>完成！关于服务端的app的工作做完了。<br>做了两件事：1、创建AIDL接口   2、规定Service中用这个接口做什么。</p><p>###客户端client的app：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-e4e6a468399862ca.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"><br>Manifest:</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    package=&quot;com.lovely_solory.super_william.mainapp&quot;&gt;    &lt;application        android:allowBackup=&quot;true&quot;        android:icon=&quot;@mipmap/ic_launcher&quot;        android:label=&quot;@string/app_name&quot;        android:roundIcon=&quot;@mipmap/ic_launcher_round&quot;        android:supportsRtl=&quot;true&quot;        android:theme=&quot;@style/AppTheme&quot;&gt;        &lt;activity android:name=&quot;.MainActivity&quot;&gt;            &lt;intent-filter&gt;                &lt;action android:name=&quot;android.intent.action.MAIN&quot; /&gt;                &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot; /&gt;            &lt;/intent-filter&gt;        &lt;/activity&gt;    &lt;/application&gt;&lt;/manifest&gt;//没有什么特别的</code></pre><p>创建客户端的.aidl文件，注意，这里的AIDL的包名要和服务端的一模一样，但是默认的我们鼠标右键创建出来的报名是这个client的包名，我在这里卡了很久，一直出错，运行的时候读取接口内容失败啥的，后面摸索了之后的解决方法：<br>1、随便建一个AIDL接口。<br>2、将那个接口和所在的包都删掉。<br>3、new-package，然后将这个package的名字命名为何服务端里面的一模一样，然后copy,paste服务端里的.aidl文件到路径下，build project。</p><p>界面是四个按钮，四个操作：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-2979ba3c34c70b0f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image"></p><p>Activity:</p><pre><code>public class MainActivity extends AppCompatActivity implements View.OnClickListener{    private Button bind,unbind,add,min;    private ICalcAIDL iCalcAIDL;    private ServiceConnection connection=new ServiceConnection() {        @Override        public void onServiceConnected(ComponentName name, IBinder service) {            log(&quot;onServiceConnected&quot;);            iCalcAIDL=ICalcAIDL.Stub.asInterface(service);        }        @Override        public void onServiceDisconnected(ComponentName name) {            log(&quot;onServiceDisconnected&quot;);            iCalcAIDL=null;        }    };    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        initView();    }    private void initView() {        bind=findViewById(R.id.btn_bindService);        unbind=findViewById(R.id.btn_unbindService);        add=findViewById(R.id.btn_add);        min=findViewById(R.id.btn_min);        bind.setOnClickListener(this);        unbind.setOnClickListener(this);        add.setOnClickListener(this);        min.setOnClickListener(this);    }    private void log(String msg){        Log.d(&quot;******&quot;,msg);    }    @Override    public void onClick(View v){        switch (v.getId()){            case R.id.btn_bindService:                Intent intent=new Intent();                intent.setAction(&quot;com.william.solory.service&quot;);                bindService(intent,connection,BIND_AUTO_CREATE);                break;            case R.id.btn_unbindService:                unbindService(connection);                break;            case R.id.btn_add:                if (iCalcAIDL!=null){                    try {                        int result=iCalcAIDL.add(12,12);                        Toast.makeText(this,&quot;result=&quot;+result,Toast.LENGTH_SHORT).show();                    } catch (RemoteException e) {                        e.printStackTrace();                    }                }else {                    Toast.makeText(this,&quot;服务被异常终结，请重新绑定服务端&quot;,Toast.LENGTH_SHORT).show();                }                break;            case R.id.btn_min:                if (iCalcAIDL!=null){                    try {                        int result=iCalcAIDL.min(50,12);                        Toast.makeText(this,&quot;result=&quot;+result,Toast.LENGTH_SHORT).show();                    } catch (RemoteException e) {                        e.printStackTrace();                    }                }else {                    Toast.makeText(this,&quot;服务被异常终结，请重新绑定服务端&quot;,Toast.LENGTH_SHORT).show();                }                break;        }    }}</code></pre><p>run起，然后点按钮bindService:<br>在client中打印：</p><pre><code>12-03 13:45:04.513 2380-2380/com.lovely_solory.super_william.mainapp D/******: onServiceConnected</code></pre><p>在server中打印：</p><pre><code>12-03 13:45:04.513 2393-2393/? D/******: onCreate12-03 13:45:04.513 2393-2393/? D/******: onBind</code></pre><p>点一个加法：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-f4f890a625afca53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>#同一个应用的进程间通信：<br>比上面更简单，在一个应用的service的manifest中将process属性指定一个”:remote”或者”任意的字符”。<br>AIDL接口直接用就行<br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>对象序列化</title>
    <link href="/2017/12/01/Android/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2017/12/01/Android/%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>1.Serializable接口<br>2.Parcelable接口</p><p>##Serializable接口<br><strong><em>java中的接口，使用简单，开销大（IO操作多），主要用于将对象序列化到存储设备中或者通过网络传输对象。</em></strong><br>标识接口，没有方法，直接实现这个接口就可以序列化用ObjectOutputStream和ObjectInputStream操作。</p><p>##Parcelable接口<br>主要要用于在内存中序列化，效率高，android平台专属，一般用于Intent中传递对象</p><pre><code>public class Person implements Parcelable {    private String name;    private int age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Person(String name, int age) {        this.name = name;        this.age = age;    }    //提供给Creator内部调用的私有构造方法    //这里读的顺序要注意和下面写的顺序一样    private Person(Parcel in) {        this.name=in.readString();        this.age=in.readInt();    }    public static final Creator&lt;Person&gt; CREATOR = new Creator&lt;Person&gt;() {        @Override        public Person createFromParcel(Parcel in) {            //反序列化，调用内部的私有构造方法传入Parcel。            return new Person(in);        }        @Override        public Person[] newArray(int size) {            return new Person[size];        }    };    @Override    public int describeContents() {        //几乎所有情况下传入0（极少数情况传入1）        return 0;    }    @Override    public void writeToParcel(Parcel dest, int flags) {        //序列化操作，注意和上面读的顺序要一样。        dest.writeString(name);        dest.writeInt(age);    }}</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Bitmap手册</title>
    <link href="/2017/11/18/Android/Bitmap%E6%89%8B%E5%86%8C/"/>
    <url>/2017/11/18/Android/Bitmap%E6%89%8B%E5%86%8C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本篇参考大量文章学习总结：</p></blockquote><p><a href="http://blog.csdn.net/xxxzhi/article/details/51607765" target="_blank" rel="noopener">深入理解bitmap</a><br><a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="noopener">郭霖： Android高效加载大图、多图解决方案，有效避免程序OOM</a><br><a href="http://www.jianshu.com/p/3950665e93e6" target="_blank" rel="noopener">玩转Android Bitmap</a></p><blockquote><p>内容：<br>1.bitmap实现内存优化<br>2.bitmap和BitmapFactory各参数讲解</p></blockquote><p>实现效果：一张原图从占内存6M多削减到占内存0.2M左右</p><p>##1. 优化内存<br>上代码先：</p><ul><li>首先是decodeBitmapFraomResource(),参数顾名思义。<br><img src="http://upload-images.jianshu.io/upload_images/7177220-85d3e76e589057ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li><li>最关键部分的算法，通过比较原图宽高和我们要求的宽高来取得缩放比例。<br><img src="http://upload-images.jianshu.io/upload_images/7177220-1cef4e72b64a4cd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>用的时候：</li></ul><pre><code>Bitmap bitmap=decodeBitmapFromResource(getResources(),R.drawable.picture                ,100,100);imageView.setImageBitmap(bitmap);</code></pre><p>非常强势，自动缩放成我们定义的100*100的尺寸要求。</p><p>接下来进行对比：</p><ul><li>不进行优化：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-91f6c1d699cbbc87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>打印：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-0f7411cd00258478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ul><p>也就是这张图片占用了6895876 Bytes=6.8MB内存</p><ul><li>进行优化：<br>用上面刚写的算法来搞：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-07c733ff4f552a04.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ul><p>打印：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-eab2280586970813.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>276676 Bytes=0.27MB<br>缩小了25倍。</p><p><strong>强势的一匹</strong></p><p>##2. Bitmap和BitmapFactory各参数讲解:<br>1.创建bitmap：</p><ul><li>Bitmap的静态方法`createBitmap()<br><img src="http://upload-images.jianshu.io/upload_images/7177220-2b8ba2ababe4e34d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" srcset="/img/loading.gif" alt=""></li><li>BitmapFactory的<code>decode</code>系列静态方法<br><img src="http://upload-images.jianshu.io/upload_images/7177220-2f2027629a8f5afa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500" srcset="/img/loading.gif" alt=""></li></ul><p>2 .Config:<br><img src="http://upload-images.jianshu.io/upload_images/7177220-ec4592240530460d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>有四个参数：</p><ul><li>Bitmap.Config.ALPHA_8：颜色信息只由透明度组成，占8位。</li><li>Bitmap.Config.ARGB_4444：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占4位，总共占16位。</li><li>Bitmap.Config.ARGB_8888：颜色信息由透明度与R（Red），G（Green），B（Blue）四部分组成，每个部分都占8位，总共占32位。是Bitmap默认的颜色配置信息，也是最占空间的一种配置。</li><li>Bitmap.Config.RGB_565：颜色信息由R（Red），G（Green），B（Blue）三部分组成，R占5位，G占6位，B占5位，总共占16位。</li></ul><p><strong><em>通常我们优化Bitmap时，当需要做性能优化或者防止OOM（Out Of Memory），我们通常会使用Bitmap.Config.RGB_565这个配置，因为Bitmap.Config.ALPHA_8只有透明度，显示一般图片没有意义，Bitmap.Config.ARGB_4444显示图片不清楚，Bitmap.Config.ARGB_8888占用内存最多。</em></strong></p><blockquote><p>他们的工作原理：</p></blockquote><pre><code>int b = 1;switch (bitmap.getConfig()) {    case ALPHA_8:        b = 1;        break;    case ARGB_4444:        b = 2;        break;    case ARGB_8888:        b = 4;        break;}int bytes1 = bitmap.getWidth() * bitmap.getHeight() * b;int bytes2 = bitmap.getByteCount();　//从api12才有的接口//bytes=bytes2;</code></pre><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Volley使用手册（1）</title>
    <link href="/2017/11/18/Android/Volley%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%EF%BC%881%EF%BC%89/"/>
    <url>/2017/11/18/Android/Volley%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p>#1.最简单的StringRequest和JasonRequest：</p><blockquote><p>1.创建一个RequestQueue对象<br>2.创建一个Request对象<br>3.将Request对象添加到RequestQueue里面。</p></blockquote><hr><ul><li>StringRequest:<br>GET方法：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-b96883d71b580da1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ul><p>StringRequest的构造方法第一个参数是url,第二个参数是onResponse接口实例，第三个参数是onErrorResponse接口实例。</p><ul><li>POST方法:<br><img src="http://upload-images.jianshu.io/upload_images/7177220-2bbe18889f2f141c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ul><p>这里的StringRequest是选择四个参数的构造方法，<br><img src="http://upload-images.jianshu.io/upload_images/7177220-6cb90a0d4fb609ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/512" srcset="/img/loading.gif" alt=""><br>第一个参数传入的是method，然后重写getParams方法，返回要Post上去的Map。</p><ul><li>JsonRequest:<br>JsonObjectRequest request=new JsonObjectRequest(4个参数或5个参数);<br><img src="http://upload-images.jianshu.io/upload_images/7177220-7c0cc1f944645f6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1024" srcset="/img/loading.gif" alt=""></li><li>请求JsonObject:<br><img src="http://upload-images.jianshu.io/upload_images/7177220-311a53cdcb12a47b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li><li>请求JsonArray同理</li></ul><p>#2. 用Volley加载网络图片</p><blockquote><ol><li>ImageRequest</li></ol></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/7177220-81fa719f14451d62.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>ImageRequest的构造函数的第一个参数是图片url<br>第二个参数是接收到图片之后的listener，第三个第四个是图片的目标尺寸，如果图片大于目标尺寸，则进行缩放，第四个是缩放类型，第五个是Config参数，第六个是出错listener。</p><pre><code>queue= Volley.newRequestQueue(this);//maxWidth和maxHeight如果传入都是0，就是不缩放。String url=&quot;http://b.hiphotos.baidu.com/image/h%3D220/sign=6e0a13c50055b31983f9857773ab8286/279759ee3d6d55fb733229e267224f4a21a4dd7a.jpg&quot;;final ImageRequest imageRequest=new ImageRequest(url, new Response.Listener&lt;Bitmap&gt;() {    @Override    public void onResponse(Bitmap response) {        imageView.setImageBitmap(response);    }}, 0, 0, ImageView.ScaleType.CENTER_CROP, Bitmap.Config.RGB_565, new Response.ErrorListener() {    @Override    public void onErrorResponse(VolleyError error) {    }});queue.add(imageRequest);</code></pre><p>只要你在maxWidth和maxHeight传的不是0，构造方法内部就会去处理优化bitmap的事情，和我另一篇介绍bitmap内存优化用的方法是一样的。</p><p>运行程序：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-df36920b2ac95d46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/300" srcset="/img/loading.gif" alt="image.png"></p><blockquote><ol start="2"><li>ImageLoader</li></ol></blockquote><p>用法：</p><pre><code>queue = Volley.newRequestQueue(this);ImageLoader imageLoader = new ImageLoader(queue, new MyImageCache());ImageLoader.ImageListener imageListener = ImageLoader.getImageListener(imageView, R.mipmap.ic_launcher, R.mipmap.ic_launcher_round);imageLoader.get(url, imageListener);</code></pre><p>运行：<img src="http://upload-images.jianshu.io/upload_images/7177220-130cd0dafb691ca2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>解释一下上面代码的几个东西：</p><ul><li>ImageLoader的构造方法的参数：RequestQueue和ImageCache<br>而ImageCache是一个接口，我自己实现了这个接口：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-3bb99477899e58a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li><li>上面两个重写的方法getBitmap和putBitmap都是ImageLoader的源码内部调用的，作用分别是从缓存中取Bitmap和将Bitmap放入缓存，每次调用imageloader.get(url,imageListener);的时候，先调用我们传入的这个接口的getBitmap方法，如果返回的是null就去网络请求然后putBitmap，如果返回不是null那就直接可以用缓存里面的bitmap（具体情况看源码）*</li></ul><p>至于LruCache是什么东西？看一下郭霖的这篇文章吧：<br><a href="http://blog.csdn.net/guolin_blog/article/details/9316683" target="_blank" rel="noopener">Android高效加载大图、多图解决方案，有效避免程序OOM</a></p><p>ImageListener是ImageLoader.getImageListener()来的，参数是<img src="http://upload-images.jianshu.io/upload_images/7177220-b04da80cd876525c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><blockquote><p>3.NetWorkImageView</p></blockquote><pre><code>queue = Volley.newRequestQueue(this);ImageLoader imageLoader = new ImageLoader(queue, new MyImageCache());NetworkImageView networkImageView=findViewById(R.id.netWorkImageView);networkImageView.setDefaultImageResId(R.mipmap.ic_launcher);networkImageView.setErrorImageResId(R.mipmap.ic_launcher);networkImageView.setImageUrl(url,imageLoader);</code></pre><p>xml:</p><pre><code>&lt;com.android.volley.toolbox.NetworkImageView    android:id=&quot;@+id/netWorkImageView&quot;    android:layout_width=&quot;200dp&quot;    android:layout_gravity=&quot;center&quot;    android:layout_height=&quot;200dp&quot; /&gt;</code></pre><p>他的好处是：代码简单，不需要代码上去进行缩放操作，他会根据xml中定义的宽和高进行自动缩放，不会多占用一点内存。</p><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android防止内存泄漏的工具</title>
    <link href="/2017/11/17/Android/android%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%B7%A5%E5%85%B7/"/>
    <url>/2017/11/17/Android/android%E9%98%B2%E6%AD%A2%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E7%9A%84%E5%B7%A5%E5%85%B7/</url>
    
    <content type="html"><![CDATA[<p>leakcanary:</p><p><a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">leackcanary</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>不够努力的自己</title>
    <link href="/2017/11/17/%E6%97%A5%E8%AE%B0%E6%9C%AC/%E4%B8%8D%E5%A4%9F%E5%8A%AA%E5%8A%9B%E7%9A%84%E8%87%AA%E5%B7%B1/"/>
    <url>/2017/11/17/%E6%97%A5%E8%AE%B0%E6%9C%AC/%E4%B8%8D%E5%A4%9F%E5%8A%AA%E5%8A%9B%E7%9A%84%E8%87%AA%E5%B7%B1/</url>
    
    <content type="html"><![CDATA[<p>今天是2017年11月17日，我正式开始自学编程的日子是2017年5月20日，6个月，也就是半年过去了，到目前为止我的水平还算不上一个合格的开发者，昨天晚上看了一下一个大神的腾讯实习面试经历，觉得自己估计连一面都过不了吧，自己的实力还是没到那个层次。</p><p>需要读的书还有很多，需要了解的知识也有很多，说不定还要学C++，因为android的NDK开发涉及到C++的内容，NDK能很大的加强效率。</p><p>6个月来，有一段时间是非常努力的，但是也有很大一部分时间是浪费掉了，浪费在虚度光阴上面了，觉得自己就是目光短浅，没有看到牛逼的人有多么牛逼，所以才敢那么散漫地浪费时间不去敲代码，从今天开始，做一个努力的程序员，或者说，努力为做一个合格的android程序员做准备。</p><p>严格要求自己，晚上11点半之后不碰手机，早上铁打的7点钟起来，7点半吃早餐，8点钟之前进入学习状态，开始一天的学习。</p><p>中午午休一个小时，2点之前进入学习状态。</p><p>一天怎么过，一生就怎么过，现在的状态是我过去努力的结果，未来的状态，取决我当下努力的结果，约束自己，向着目标前进，我距离一个高级android开发者还差的很远。</p><p>我的目标是在大四去实习的时候，就已经有一个高级android工程师的样子，而不是一个懵懵懂懂的android实习生。</p><p>这是一个考验，更是一种激励，努力从来都不简单，体现一个人差异化的就是坚持不懈，加油，向着更好的自己前进!<br></p>]]></content>
    
    
    <categories>
      
      <category>日记本</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>java中的堆和栈</title>
    <link href="/2017/11/16/Android/java%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88/"/>
    <url>/2017/11/16/Android/java%E4%B8%AD%E7%9A%84%E5%A0%86%E5%92%8C%E6%A0%88/</url>
    
    <content type="html"><![CDATA[<p>找了很久发现了一个人写的博客，配合图解，讲的非常好，懂了：<br><a href="https://www.cnblogs.com/ibelieve618/p/6380328.html" target="_blank" rel="noopener">自学开发的老司机：java中的堆和栈</a><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>android-内存优化（1）</title>
    <link href="/2017/11/15/Android/android-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%881%EF%BC%89/"/>
    <url>/2017/11/15/Android/android-%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%EF%BC%881%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来自慕课网的课程，自己做的笔记：<a href="http://www.imooc.com/video/13672" target="_blank" rel="noopener">http://www.imooc.com/video/13672</a></p></blockquote><p>#1. 每一个app在手机上是有最大内存分配限制的，随着设备的不同而不同：</p><pre><code>        textView=findViewById(R.id.tv);        ActivityManager activityManager= (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);        int memoryClass=activityManager.getMemoryClass();        int largeMC=activityManager.getLargeMemoryClass();        textView.setText(&quot;memoryClass: &quot;+ memoryClass+&quot;\n&quot;+&quot;largeMC: &quot;+largeMC);</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7177220-60a9ad7af9992be2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>而我在另一台虚拟机上面测试的一个memoryClass是180多M，largeMemoryClass是512M。</p><p>#2. 吃手机内存的大户：图片<br>#3. app切换时后台清理机制<br> app切换时的LRU cache:<br>LRU算法：最近使用的app排在最前面，最少的可能被清理掉</p><p>#4. 查看内存情况的工具：<br>Tools-Android-Android Device Monitor<br><img src="http://upload-images.jianshu.io/upload_images/7177220-05189c2d72d6932c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>左边选住你的进程，然后点update heap<br><img src="http://upload-images.jianshu.io/upload_images/7177220-211fd800db9c7347.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>点一下Cause GC,出现数据<br><img src="http://upload-images.jianshu.io/upload_images/7177220-bd643aac527f4d09.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="image.png"><br>heap size是系统分配的内存，allocated是已占用的内存,free是还没占用的内存。<br>data object是对象，class object是类,一般开发就看这两个，如果数值一直在增加，说明可能有内存泄漏，一般都是稳定在一个数值。</p><p>#5. 内存优化小技巧：</p><ul><li>用StringBuilder替换+来拼接字符串，速度提升上千倍，（因为+号的内部处理也是用StringBuider来append，但是用很多加号就会new很多StringBuilder，就会凭空生成很多对象，降低效率）</li><li>用ArrayMap、SparseArray替换HashMap</li><li>内存抖动：在Anroid Profiler的memory那里看到内存一会高一会低，是因为方法中突然new出大量的对象（比如for循环里面new对象），然后方法结束GC把对象回收，一下载内存减少。<br>这样频繁调用GC对app流畅性影响非常大（好像是GC调用的时候所有线程暂停）<br>#6.<br>再小的class都会耗费0.5KB<br>HashMap一个entry需要额外占用32B</li></ul><p>#7. 对象复用</p><ul><li>复用系统自带的资源</li><li>ListView,GridView的ConvertView的复用</li><li>避免在自定义View的onDraw里面创建对象，因为只要一个View的状态改变，就会执行onDraw，在那里创建对象会影响整体UI绘制，造成界面卡顿。</li></ul><p>#8. 内存泄漏</p><ul><li>内存泄漏会导致可用的Heap越来越少，然后频繁调用GC，最后还可能会OOM（out of memory）</li><li>注意Activty里面的内存泄漏，比如在activity里面的开一个内部类Mythread,内部类默认对外部类有一个引用，因此不要再内部类里面去处理耗时操作，网络请求之类的。</li></ul><p>—–解决方法：耗时操作放去Service</p><ul><li>用Application的context而不是activty的context;</li><li>Cursor对象是否及时关闭，一般涉及到数据库操作，用完了记得关闭。<br></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>view-findViewById和activity-findViewById</title>
    <link href="/2017/11/06/Android/view-findViewById%E5%92%8Cactivity-findViewById/"/>
    <url>/2017/11/06/Android/view-findViewById%E5%92%8Cactivity-findViewById/</url>
    
    <content type="html"><![CDATA[<p>直接内容见我的stackoverflow上的提问：<br><a href="https://stackoverflow.com/questions/47131227/android-view-findviewbyid-and-activity-findviewbyid-one-cannot-show-the-data" target="_blank" rel="noopener">android view.findViewById and activity.findViewById, one cannot show the data</a></p><p>以下内容大多为上面连接的直接截图：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-0b95652a00ebfb2a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-c56d56682be44c9a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p><em>以上是我问的问题</em></p><p>下面是两个优质回答<br>1、<br><img src="http://upload-images.jianshu.io/upload_images/7177220-c2dc52c4135ad30f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>2、</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-c3d3c1df416a95b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p><strong>总结</strong></p><blockquote><p>View.findViewById行不通是因为当前的view没有和activity绑定，少了一个activity.setContentView，而在onCreate里可以直接用也是因为调用了setContentView进行了绑定，所以要用的话就直接activity.findViewById.<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>DialogFragment自己爬过的坑</title>
    <link href="/2017/10/21/Android/DialogFragment%E8%87%AA%E5%B7%B1%E7%88%AC%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <url>/2017/10/21/Android/DialogFragment%E8%87%AA%E5%B7%B1%E7%88%AC%E8%BF%87%E7%9A%84%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<p>DialogFragment在显示之后如何从屏幕消除？</p><ol><li>直接按手机的返回键</li><li>自己的代码里处理 ，调用DialogFragment的对象的dismiss()；</li><li>从外部处理<pre><code>MyDialogFragment dialog=(MyDialogFragment)getFragmentManager.findFragmentByTag();dialog.dismiss();//摸索了我好久好久，各种查资料，最后自己试出来了，妈的</code></pre></li></ol>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fragment涉及的add、remove和replace方法和回退栈的关系详解</title>
    <link href="/2017/10/21/Android/Fragment%E6%B6%89%E5%8F%8A%E7%9A%84add%E3%80%81remove%E5%92%8Creplace%E6%96%B9%E6%B3%95%E5%92%8C%E5%9B%9E%E9%80%80%E6%A0%88%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3/"/>
    <url>/2017/10/21/Android/Fragment%E6%B6%89%E5%8F%8A%E7%9A%84add%E3%80%81remove%E5%92%8Creplace%E6%96%B9%E6%B3%95%E5%92%8C%E5%9B%9E%E9%80%80%E6%A0%88%E7%9A%84%E5%85%B3%E7%B3%BB%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>前部分参考：<br><a href="http://blog.csdn.net/haozipi/article/details/46994801" target="_blank" rel="noopener">Fragment涉及的add、remove和replace方法和回退栈的关系详解</a></p><p>划重点：</p><ol><li><p>add方法不会加入回退栈，只会在container的view里面一层一层不断往上面涂layout。</p><pre><code>this.layout = (FrameLayout) this.findViewById(R.id.contentFrame);     button.setOnClickListener(new View.OnClickListener() {         @Override         public void onClick(View v) {             FragmentManager fragmentManager=getFragmentManager();             FragmentTransaction transaction=fragmentManager.beginTransaction();             transaction.add(R.id.contentFrame,new Frag_1(),&quot;frag_1&quot;);             transaction.commit();             Log.d(&quot;tag&quot;, String.valueOf(layout.getChildCount()));         }     });     btn_2.setOnClickListener(new View.OnClickListener() {         @Override         public void onClick(View v) {             FragmentManager fragmentManager=getFragmentManager();             FragmentTransaction transaction=fragmentManager.beginTransaction();             transaction.add(R.id.contentFrame,new Frag_2(),&quot;frag_2&quot;);             transaction.commit();             Log.d(&quot;tag&quot;, String.valueOf(layout.getChildCount()));         }     });</code></pre><p>然后两个Button交换按就是：</p></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/7177220-f733482a38a04df0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><ol start="2"><li></li></ol><p><strong>add、remove和replace方法和回退栈,没有任何关系</strong><br>没有任何关系<br>没有任何关系<br>没有任何关系<br>（这一点困惑了我贼久，终于在那篇连接的博客里找到了答案，fuck~）</p><p>复制粘贴博客原话：</p><blockquote><p>这里有一个点非常容易混淆，就是因为add也是一层一层的往FrameLayout里添加Fragment，那么在按回退按钮的时候是不是一层一层的再拿出来呢？笔者这里告诉大家，根本不会，除非加入了回退栈。因为add、remove和replace只是相当于在这个界面层次上做操作，和回退栈没有关系，即使在某些地方看起来很像（回退栈是一个一个的添加进去，按回退的时候会一个一个弹出来）。<br>那么通过add添加Fragment之后加入回退栈，和通过replace替换Fragment之后加入回退栈有什么不一样呢？<br>这点就要参照在界面的关系了，add是一层一层往上叠，如果你在其中一层上做了修改，等回退到这一层时，所做的操作会被保留，并且回退的时候会一层一层把Fragment往外拿。replace实际上是替换掉了，那么虽然加入了回退栈，但是会执行销毁视图的方法onDestroyView，回退时会重新执行onCreateView方法重建视图。</p></blockquote><hr><h1 id="2018年2月25日新增内容：关于Fragment回退栈（原创）"><a href="#2018年2月25日新增内容：关于Fragment回退栈（原创）" class="headerlink" title="2018年2月25日新增内容：关于Fragment回退栈（原创）"></a>2018年2月25日新增内容：关于Fragment回退栈（原创）</h1><p>结论：回退栈回退的是一整个commit之前的操作<code>（事务）</code>，而不是回退某一个Fragment。</p><p><em>截图官方文档</em><br><img src="http://upload-images.jianshu.io/upload_images/7177220-33c800abf70f0602.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><blockquote><p>在调用应用所有的更改都将作为单一事务添加到返回栈。</p></blockquote><p>例子：</p><pre><code class="java">public class BlankFragment extends Fragment {    public BlankFragment() {        // Required empty public constructor    }    @Override    public View onCreateView(LayoutInflater inflater, ViewGroup container,                             Bundle savedInstanceState) {        // Inflate the layout for this fragment        View view = inflater.inflate(R.layout.fragment_blank, container, false);        TextView textView= view.findViewById(R.id.bf_tv);        Log.d(&quot;TAG&quot;,getArguments().getString(&quot;number&quot;,&quot;null&quot;));        textView.setText(getArguments().getString(&quot;number&quot;));        return view;    }}</code></pre><pre><code class="java">public class MainActivity extends AppCompatActivity {    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        findViewById(R.id.btn).setOnClickListener(new View.OnClickListener() {            private int pressCount=0;            @Override            public void onClick(View v) {                FragmentManager manager=getSupportFragmentManager();                FragmentTransaction transaction=manager.beginTransaction();                BlankFragment fragment=new BlankFragment();                Bundle bundle=new Bundle();                bundle.putString(&quot;number&quot;, String.valueOf(pressCount++));                fragment.setArguments(bundle);                transaction.add(R.id.frameLayout,fragment);//                transaction.addToBackStack(null);                transaction.commit();            }        });    }</code></pre><p>先用add()，并且不添加回退栈。看看效果：<br>[图片上传中…(image.png-c06906-1519563125564-0)]</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-4f9c74d5a1f5a972.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" srcset="/img/loading.gif" alt="add.gif"><br>一层一层叠上去的<br>看看replace，并且不添加回退栈：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-9b21f265a54337f4.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" srcset="/img/loading.gif" alt=""></p><p> 将注释解除，两个各自添加回退栈的效果：<br>add:</p><ul><li><img src="http://upload-images.jianshu.io/upload_images/7177220-059fdb645b5710dc.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" srcset="/img/loading.gif" alt=""><br>replace</li><li><img src="http://upload-images.jianshu.io/upload_images/7177220-6a673acf8c165f26.gif?imageMogr2/auto-orient/strip%7CimageView2/2/w/200" srcset="/img/loading.gif" alt=""></li></ul><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>透明状态栏</title>
    <link href="/2017/10/14/Android/%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F/"/>
    <url>/2017/10/14/Android/%E9%80%8F%E6%98%8E%E7%8A%B6%E6%80%81%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<pre><code>if (Build.VERSION.SDK_INT&gt;Build.VERSION_CODES.KITKAT){            WindowManager.LayoutParams layoutParams=getWindow().getAttributes();            layoutParams.flags=WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;        }</code></pre><p>在Acticity的onCreate里面来这么一句就可以了。</p><blockquote><p>关于toolbar,参照<br><strong><a href="http://stormzhang.com/android/2015/08/16/boohee-toolbar/" target="_blank" rel="noopener">薄荷toolbar的适配方案</a></strong><br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>收藏，待深入学习的android文章</title>
    <link href="/2017/10/14/Android/%E6%94%B6%E8%97%8F%EF%BC%8C%E5%BE%85%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%9A%84android%E6%96%87%E7%AB%A0/"/>
    <url>/2017/10/14/Android/%E6%94%B6%E8%97%8F%EF%BC%8C%E5%BE%85%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0%E7%9A%84android%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="http://www.jianshu.com/p/bf159a9c391a" target="_blank" rel="noopener">Android内存泄露——全解析和处理办法</a><br>讲解内存泄漏的原理和原因</p></blockquote><blockquote><p><a href="http://blog.csdn.net/q178266871/article/details/50719144" target="_blank" rel="noopener">5个Android开发中比较常见的内存泄漏问题及解决办法</a><br>单例造成的内存泄漏<br>非静态内部类创建静态实例造成的内存泄漏<br>Handler造成的内存泄漏<br>线程造成的内存泄漏<br>资源未关闭造成的内存泄漏</p></blockquote><blockquote><p><strong>布局优化</strong><br><a href="http://blog.csdn.net/qq_17766199/article/details/52863741" target="_blank" rel="noopener">一些你需要知道的布局优化技巧</a><br><a href="http://blog.csdn.net/lmj623565791/article/details/45556391" target="_blank" rel="noopener"> <a href="http://blog.csdn.net/lmj623565791/article/details/45556391" target="_blank" rel="noopener">Android UI性能优化实战 识别绘制中的性能问题(张鸿洋)</a></a><br><a href="http://blog.csdn.net/guolin_blog/article/details/43376527" target="_blank" rel="noopener">Android最佳性能实践(四)——布局优化技巧(郭霖)</a><br><a href="https://developer.android.com/training/best-performance.html" target="_blank" rel="noopener">Google官方文档</a><br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>导入本地SQLite文件</title>
    <link href="/2017/10/12/Android/%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0SQLite%E6%96%87%E4%BB%B6/"/>
    <url>/2017/10/12/Android/%E5%AF%BC%E5%85%A5%E6%9C%AC%E5%9C%B0SQLite%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>借鉴自 <em><a href="http://blog.csdn.net/u010800530/article/details/40192279" target="_blank" rel="noopener">读取assets目录下的数据库文件</a></em></p><ol><li><p>Project-app-main文件夹下new一个assets folder，如图：<br><img src="http://upload-images.jianshu.io/upload_images/7177220-e0eee73bb5017626.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p></li><li><p>准备好的数据库文件直接复制粘贴过去。</p></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/7177220-387f2bc0d796600a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>3. 用代码把assets路径下的该文件用I/O的方式写入对应包名的路径下，代码如下：</p><pre><code>public class DataBaseManager {    String filePath = &quot;data/data/com.solory.william.myweather/databases/my_db.db&quot;;    String pathStr = &quot;data/data/com.solory.william.myweather/databases&quot;;    SQLiteDatabase sqLiteDatabase;    public SQLiteDatabase openDataBase(Context context) {        File jhPath = new File(filePath);        if (jhPath.exists()) {            //存在则直接打开            return SQLiteDatabase.openOrCreateDatabase(jhPath, null);        } else {            //不存在则复制粘贴到该路径下            File path = new File(pathStr);            if (path.mkdir()) {                Log.d(&quot;tag&quot;, &quot;创建Path成功&quot;);            } else {                Log.d(&quot;tag&quot;, &quot;创建Path失败&quot;);            }            try {                AssetManager assetManager = context.getAssets();                InputStream is = assetManager.open(&quot;my_db.db&quot;);                FileOutputStream fos = new FileOutputStream(jhPath);                byte[] buffer = new byte[1024];                int count = 0;                while ((count = is.read(buffer)) &gt; 0) {                    fos.write(buffer, 0, count);                }                fos.flush();                fos.close();                is.close();            } catch (Exception e) {                e.printStackTrace();                return null;            }            return openDataBase(context);        }    }}</code></pre><ol start="4"><li>用的时候直接：</li></ol><p><img src="http://upload-images.jianshu.io/upload_images/7177220-dc9b5874a4fab837.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>5. run</p><p>end: 查看一下数据库的路径，发现出现我们要的数据库了。</p><blockquote><p>另外，这个导入的数据库是可以用GreenDao的，只要把对应的id和property都正确的生成就可以了。<br></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Thread的run方法和start方法</title>
    <link href="/2017/10/11/java%E5%B9%B6%E5%8F%91/Thread%E7%9A%84run%E6%96%B9%E6%B3%95%E5%92%8Cstart%E6%96%B9%E6%B3%95/"/>
    <url>/2017/10/11/java%E5%B9%B6%E5%8F%91/Thread%E7%9A%84run%E6%96%B9%E6%B3%95%E5%92%8Cstart%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>结论：</p><ul><li>调用Thread里的run方法的时候，会直接在主线程里通过对象调用该对象的run方法，就是普通的调用，不会开启线程。</li><li>start方法会开启一个新的线程去执行run方法里的代码。<blockquote><p>代码：</p></blockquote></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/7177220-e091499fe623a94e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><blockquote><p>结果：</p></blockquote><p><img src="http://upload-images.jianshu.io/upload_images/7177220-3a3b6da9d6b17873.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></p>]]></content>
    
    
    <categories>
      
      <category>java并发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>JSONObject，JSONArray解析</title>
    <link href="/2017/10/09/Android/JSONObject%EF%BC%8CJSONArray%E8%A7%A3%E6%9E%90/"/>
    <url>/2017/10/09/Android/JSONObject%EF%BC%8CJSONArray%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>参考博客：<a href="http://blog.csdn.net/lishuangzhe7047/article/details/28880009" target="_blank" rel="noopener"><a href="http://blog.csdn.net/lishuangzhe7047/article/details/28880009" target="_blank" rel="noopener">李双喆的JSONObject、JSONArray</a></a></p><blockquote><p>这玩意弄得我迷迷糊糊的，今天终于搞明白了，记录之。</p></blockquote><h3 id="看图先"><a href="#看图先" class="headerlink" title="看图先"></a>看图先</h3><p><img src="http://upload-images.jianshu.io/upload_images/7177220-6e7ab4169b5a9b4a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>首先搞明白两个概念：</p><ul><li>JSONObject是用｛｝来表示的，没有｛｝不是JSONObject。</li><li>JSONArray使用[]来表示的，没有[]不是JSONArray。</li></ul><p>解释一下上图，比如上图，直接出来一个[ ]，[ ]就是数组，数组里有两个元素，也就是两个{}，也就是两个JSONObject。注意这里第二个{}是空的。</p><p>好的，整明白了之后，比如我们要拿到键name4对应的值value2时，怎么操作？</p><pre><code>                    JSONArray jsonArray=new JSONArray(content);                    //jsonArray=[{name1:{name2:{name3:&quot;value1&quot;,name4:&quot;value2}}},{}]                    JSONObject object1=jsonArray.getJSONObject(0);                    //object1={name1:{name2:{name3:&quot;value1&quot;,name4:&quot;value2&quot;}}}                    JSONObject object2=object1.getJSONObject(&quot;name1&quot;);                    //object2={name2:{name3:&quot;value1&quot;,name4:&quot;value2&quot;}}                    JSONObject object3=object2.getJSONObject(&quot;name2&quot;);                    //object3={name3:&quot;value1&quot;,name4:&quot;value2&quot;}                    String value2=object3.getString(&quot;name4&quot;);</code></pre><p>以上是详细解剖，快速的这样：</p><pre><code>JSONArray jsonArray=new JSONArray(content);String value2=jsonArray.getJSONObject(0).getJSONObject(&quot;name&quot;).getJSONObject(&quot;name2&quot;).getString(&quot;name4&quot;);</code></pre><hr><p><strong>以上是一个抽象的例子，我们来搞个实战：</strong></p><p>解析一个天气数据：<br><a href="https://www.heweather.com/documents/api/v5/now" target="_blank" rel="noopener">和风天气的API文档</a></p><p>JSON如下：</p><pre><code>{    &quot;HeWeather5&quot;: [        {            &quot;basic&quot;: { //基本信息                &quot;city&quot;: &quot;北京&quot;,  //城市名称                &quot;cnty&quot;: &quot;中国&quot;,   //国家                &quot;id&quot;: &quot;CN101010100&quot;,  //城市ID                &quot;lat&quot;: &quot;39.904000&quot;, //城市维度                &quot;lon&quot;: &quot;116.391000&quot;, //城市经度                &quot;prov&quot;: &quot;北京&quot;,  //城市所属省份（仅限国内城市）                &quot;update&quot;: {  //更新时间                    &quot;loc&quot;: &quot;2016-08-31 11:52&quot;,  //当地时间                    &quot;utc&quot;: &quot;2016-08-31 03:52&quot; //UTC时间                }            },            &quot;now&quot;: {  //实况天气                &quot;cond&quot;: {  //天气状况                    &quot;code&quot;: &quot;104&quot;,  //天气状况代码                    &quot;txt&quot;: &quot;阴&quot;  //天气状况描述                },                &quot;fl&quot;: &quot;11&quot;,  //体感温度                &quot;hum&quot;: &quot;31&quot;,  //相对湿度（%）                &quot;pcpn&quot;: &quot;0&quot;,  //降水量（mm）                &quot;pres&quot;: &quot;1025&quot;,  //气压                &quot;tmp&quot;: &quot;13&quot;,  //温度                &quot;vis&quot;: &quot;10&quot;,  //能见度（km）                &quot;wind&quot;: {  //风力风向                    &quot;deg&quot;: &quot;40&quot;,  //风向（360度）                    &quot;dir&quot;: &quot;东北风&quot;,  //风向                    &quot;sc&quot;: &quot;4-5&quot;,  //风力                    &quot;spd&quot;: &quot;24&quot;  //风速（kmph）                }            },            &quot;status&quot;: &quot;ok&quot;  //接口状态        }    ]}</code></pre><p>我要拿到的数据是”city”:”北京”</p><pre><code>JSONObject jsonObject=new JSONObject(content);//因为返回的数据整个就是用｛｝包裹的，所以先new一个JSONObjectString city=jsonObject.getJSONArray(&quot;HeWeather5&quot;).getJSONObject(0).getJSONObject(&quot;basic&quot;).getString(&quot;city&quot;);//稳了</code></pre><p>稳了</p><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>GreenDao安全地升级数据库</title>
    <link href="/2017/10/08/Android/GreenDao%E5%AE%89%E5%85%A8%E5%9C%B0%E5%8D%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2017/10/08/Android/GreenDao%E5%AE%89%E5%85%A8%E5%9C%B0%E5%8D%87%E7%BA%A7%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h4 id="首先-这玩意怎么升级数据库？"><a href="#首先-这玩意怎么升级数据库？" class="headerlink" title="首先,这玩意怎么升级数据库？"></a>首先,这玩意怎么升级数据库？</h4><ol><li>传统SQLite语句做法：<br>写一个自己的Helper继承自SQLiteOpenHelper，重写里面的onUpgrade方法，方法里做的事情就是（如图）：</li></ol><ul><li>先把原先的表drop下来，就是删了</li><li>然后再重新创建<img src="http://upload-images.jianshu.io/upload_images/7177220-b362526a47bd073a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="">)然后拿helper的时候就用的自己的Helper就完事了，接着这里第四个参数就是数据库版本号，填一个比之前大的数字就OK了。<img src="http://upload-images.jianshu.io/upload_images/7177220-24283403976e0889.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></li></ul><ol start="2"><li>GreenDao：<br>问题：greendao里面没有那种指定版本号就升级的方法，摸索之后如下：<img src="http://upload-images.jianshu.io/upload_images/7177220-079549c4fe653457.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br><img src="http://upload-images.jianshu.io/upload_images/7177220-806fd77372e0a3ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>在这里更改数据库版本，然后点击make project，下次安装的时候就升级了~</li></ol><h1 id="然而，默认情况下GreenDao升级数据库也是会直接drop掉table，那样数据就全部清空了！！！"><a href="#然而，默认情况下GreenDao升级数据库也是会直接drop掉table，那样数据就全部清空了！！！" class="headerlink" title="然而，默认情况下GreenDao升级数据库也是会直接drop掉table，那样数据就全部清空了！！！"></a>然而，默认情况下GreenDao升级数据库也是会直接drop掉table，那样数据就全部清空了！！！</h1><ul><li>解决方法如下：<br>借鉴github上面一个开源项目：<strong><a href="https://github.com/yuweiguocn/GreenDaoUpgradeHelper/blob/master/README_CH.md" target="_blank" rel="noopener">GreenDaoUpgradeHelper</a></strong><blockquote><p><em>按照作者的思路走就很简单了，以下是实践起来的步骤：</em></p></blockquote></li></ul><p>1.在根目录的build.gradle文件的repositories内添加如下代码：</p><pre><code>allprojects {    repositories {        ...        maven { url &quot;https://jitpack.io&quot; }    }}</code></pre><p>2.添加依赖（greendao 3.0及以上）</p><pre><code>dependencies {        compile &#39;org.greenrobot:greendao:3.2.0&#39;        compile &#39;com.github.yuweiguocn:GreenDaoUpgradeHelper:v2.0.0&#39;}</code></pre><ol start="3"><li><p>自己建一个Helper类继承OpenHelper:</p><pre><code>public class MyDataBaseHelper extends DaoMaster.OpenHelper { public MyDataBaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory) {     super(context, name, factory); } //这里重写onUpgrade方法 @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {     MigrationHelper.migrate(db, new MigrationHelper.ReCreateAllTableListener() {         @Override         public void onCreateAllTables(Database db, boolean ifNotExists) {             DaoMaster.createAllTables(db, ifNotExists);         }         @Override         public void onDropAllTables(Database db, boolean ifExists) {             DaoMaster.dropAllTables(db, ifExists);         }         //注意此处的参数StudentDao.class，很重要（一开始没注意，给坑了一下），它就是需要升级的table的Dao,         //不填的话数据丢失，         // 这里可以放多个Dao.class，也就是可以做到很多table的安全升级，Good~     }, StudentDao.class); }}</code></pre></li><li><p>记得这里的OpenHelper要用刚才自己写的那个。</p></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/7177220-5d1a7e544affa17b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>大功告成，然后每次要升级就去改gradle的schemaVersion就是了。</p><p>稳了稳了~~<br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Generate-Signed-APK的一个坑</title>
    <link href="/2017/10/07/Android/Generate-Signed-APK%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/"/>
    <url>/2017/10/07/Android/Generate-Signed-APK%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>给这玩意坑了好长时间，不过还好后面还是解决了。</p></blockquote><p> 入口：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-3072c2fc6dd43415.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>进入：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-9f03d8fca78d40da.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br>下一步：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-b43e55eb704797b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><blockquote><p>这个地方注意了，V2的签名方式是Android 7.0之后的签名方式，顾名思义：需要运行在7.0以后的手机上才能使用这种签名方式，但是如果不是android7.0的手机我们用V2的签名方式签名了会啥情况？</p></blockquote><p>很蛋疼</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-6dd845ef22e95bbd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><h1 id="是的是的，就是找不到签名证书了。"><a href="#是的是的，就是找不到签名证书了。" class="headerlink" title="是的是的，就是找不到签名证书了。"></a>是的是的，就是找不到签名证书了。</h1><ul><li>结论：<br>避免不适配咋办？直接用V1的签名就行了呀。<br>或者V1和V2都用，也没问题。<br></li></ul>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Application使用技巧</title>
    <link href="/2017/10/05/Android/Application%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2017/10/05/Android/Application%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<blockquote><p>这里简单介绍application类的使用技巧</p></blockquote><ul><li>首先，写一个类来继承自Application,然后重写onCreate方法：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/7177220-39f255abe2b7ae1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><p>然后在Manifest文件里面把我们自己写的Application配进去：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-b0ed6a4607a8c185.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><blockquote><p>这里注意了，此前我自己也遇到过这个麻烦，那么就是在用这个MyApplication的时候，是绝对不能这么写的：</p></blockquote><pre><code>MyApplication app=new MyApplication();我当时这么写的结果就是，代码都不知道怎么错的，调试了半天，还以为是我数据库初始化出了问题。这个很严重。错的原因是，Application这个东西是Android系统的一个类，是在应用打开的时候有且只有初始化一次，我们自己在代码里面创建的那已经不是Application了，是啥我也不懂，因此直接new一个Application是绝对不行的，用法是错的。</code></pre><p>#正确做法如下：<br>我们采取单例模式，这样application就可以不用创建多次，复用一个对象就可以了。</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-38e2c11226645a79.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""></p><ul><li>OK大功告成，现在任何的类都可以获取到我们的context了。</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/7177220-7000bc6cc9c953f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt=""><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>自定义CheckBox样式</title>
    <link href="/2017/10/03/Android/%E8%87%AA%E5%AE%9A%E4%B9%89CheckBox%E6%A0%B7%E5%BC%8F/"/>
    <url>/2017/10/03/Android/%E8%87%AA%E5%AE%9A%E4%B9%89CheckBox%E6%A0%B7%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>借鉴自<a href="http://www.cnblogs.com/Claire6649/p/5941145.html" target="_blank" rel="noopener">http://www.cnblogs.com/Claire6649/p/5941145.html</a></p></blockquote><ol><li>在drawable中创建selector:<pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:state_checked=&quot;true&quot; android:drawable=&quot;@mipmap/check&quot; /&gt; &lt;item android:state_checked=&quot;false&quot; android:drawable=&quot;@mipmap/uncheck&quot; /&gt; &lt;item android:drawable=&quot;@mipmap/uncheck&quot; /&gt;&lt;/selector&gt;</code></pre></li><li>在values文件夹下的styles.xml文件中添加CustomCheckboxTheme样式。<pre><code>&lt;style name=&quot;CustomCheckBoxTheme&quot; parent=&quot;Widget.AppCompat.CompoundButton.CheckBox&quot;&gt;     &lt;item name=&quot;android:button&quot;&gt;@drawable/check_box_selector&lt;/item&gt;        &lt;/style&gt;</code></pre></li></ol><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><ul><li>在drawable中引用mipmap的问题<br>mipmaps 是一种可视化技术渲染算法，速度相当快，所以google强烈建议使用mipmap装图片。把图片放到mipmaps可以提高系统渲染图片的速度，提高图片质量，减少GPU压力。</li></ul><hr><p>然而问题是我们在drawable中引用mipmap资源的时候是没有代码提示的，正确的做法就是直接自己动手打吧</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-e182f5763fccadd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="你看，这就没有代码提示"></p><p>但是当我们直接手动输入之后的样子：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-7e3de8748a11964c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="不会报错了"></p><h2 id="所以解决方法是：没有提示，自己敲出来"><a href="#所以解决方法是：没有提示，自己敲出来" class="headerlink" title="所以解决方法是：没有提示，自己敲出来"></a>所以解决方法是：没有提示，自己敲出来</h2><p></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android-用接口来给RecyclerView的item添加监听事件</title>
    <link href="/2017/09/20/Android/Android-%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9D%A5%E7%BB%99RecyclerView%E7%9A%84item%E6%B7%BB%E5%8A%A0%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6/"/>
    <url>/2017/09/20/Android/Android-%E7%94%A8%E6%8E%A5%E5%8F%A3%E6%9D%A5%E7%BB%99RecyclerView%E7%9A%84item%E6%B7%BB%E5%8A%A0%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>此前我添加item的监听事件是直接在Adapter里面的onCreate方法中直接holder.view.setOnClickListener(new OnClickListener){};<br><strong>此方法是学的郭霖的第二行代码。</strong></p><p>后面在hongyang的博客学的下面这个方法：</p><pre><code>    public interface OnItemClickListener {        void onItemClick(View v,int position);    }    public interface OnItemLongClickListener {        void onItemLongClick(View v,int position);    }    private OnItemClickListener onItemClickListener;    private OnItemLongClickListener onItemLongClickListener;</code></pre><p>第一步：分别写两个public的接口，接口里面放方法，方法的参数注意了，一个是View一个是int，int 用来记录position。<br>第二步：引用两个private的接口。</p><pre><code>    public void setOnItemClickListener(OnItemClickListener listener){        onItemClickListener= listener;    }    public void setOnItemLongClickListener(OnItemLongClickListener listener){        onItemLongClickListener=listener;    }</code></pre><p>第三步：添加两个public的方法，供调用者调用，参数放接口进去，这样的效果是：只要调用者调用了这个方法，我们就强迫调用者去实现我们参数里面放的这个接口。</p><pre><code>    @Override    public void onBindViewHolder(final MyViewHolder holder, int position) {        if (getItemViewType(position) == NORMAL_VIEW) {            holder.textView.setText(list.get(position));            if (onItemClickListener!=null){                holder.textView.setOnClickListener(new View.OnClickListener() {                    @Override                    public void onClick(View view) {                        onItemClickListener.onItemClick(holder.itemView,holder.getLayoutPosition());                    }                });            }            if (onItemLongClickListener!=null){                holder.textView.setOnLongClickListener(new View.OnLongClickListener() {                    @Override                    public boolean onLongClick(View view) {                        onItemLongClickListener.onItemLongClick(holder.itemView,holder.getLayoutPosition());                        return false;                    }                });            }        }    }</code></pre><p>第四步：在onBind方法里面，先来一个if来判断我们的接口是不是null，是null，跳过,不是null，说明被实现了，进入，开始设置监听方法，具体的代码。</p><p><strong>现在可以跑回Activity里面去设置监听了!</strong></p><pre><code>adapter.setOnItemClickListener(new MyAdapter.OnItemClickListener() {            @Override            public void onItemClick(View v, int position) {                Toast.makeText(MainActivity.this,&quot;the number&quot;+position+&quot;has been clicked&quot;,Toast.LENGTH_SHORT).show();            }        });        adapter.setOnItemLongClickListener(new MyAdapter.OnItemLongClickListener() {            @Override            public void onItemLongClick(View v, int position) {                list.remove(position);                adapter.notifyItemRemoved(position);                 Toast.makeText(MainActivity.this,&quot;the number&quot;+position+&quot;has been removed&quot;,Toast.LENGTH_SHORT).show();            }        });</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/7177220-491f2a7c38b9c43a.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="~"><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Android-给recyclerview添加footView</title>
    <link href="/2017/09/20/Android/Android-%E7%BB%99recyclerview%E6%B7%BB%E5%8A%A0footView/"/>
    <url>/2017/09/20/Android/Android-%E7%BB%99recyclerview%E6%B7%BB%E5%8A%A0footView/</url>
    
    <content type="html"><![CDATA[<p><strong>效果图</strong>：</p><p><img src="http://upload-images.jianshu.io/upload_images/7177220-961dfa84256aa3cc.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="随便找了一个软件来录制，效果好差"></p><p>首先新建一个recyclerview</p><p>以下是MyAdapter</p><pre><code>public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {    private Context context;    private List&lt;String&gt; list;    MyAdapter(List&lt;String&gt; list, Context context) {        this.list = list;        this.context = context;    }//onCreateViewHolder    @Override    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {        View itemView = LayoutInflater.from(context).inflate(R.layout.rv_item, parent, false);        return new MyViewHolder(itemView, viewType);    }}    //返回item数量   @Override    public int getItemCount() {        return list.size() ;    }    class MyViewHolder extends RecyclerView.ViewHolder {        TextView textView;        MyViewHolder(View itemView, int viewType) {            super(itemView);            textView = itemView.findViewById(R.id.textView);        }    }</code></pre><p>非常基础简洁的一个Adapter。<strong>但是注意这里的onCreateViewHolder(ViewGroup parent, int viewType)，他的第二个参数是viewType,这是关键的地方，就是用来设置footView的。</strong></p><hr><p><strong>我们利用MyAdapter内部的一个getViewType方法来帮助我们获得FootView的效果：</strong></p><pre><code>public class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.MyViewHolder&gt; {    ........    ........    //这两个静态变量来区分是normalView还是footView。    private static final int NORMAL_VIEW = 0;    private static final int FOOT_VIEW = 1;    //重写一下getItemViewType,返回两个我们自己定义的参数，美滋滋~    @Override    public int getItemViewType(int position) {        if (position == getItemCount() - 1) {            return FOOT_VIEW;        }        return NORMAL_VIEW;    }</code></pre><p>上面是我们在MyAdapter中重写的方法<br><strong>下面是我们需要去修改的几个地方</strong></p><ol><li><p>修改内部类MyViewHolder</p><pre><code> class MyViewHolder extends RecyclerView.ViewHolder {     TextView textView;     RelativeLayout footView;     //在MyViewHolder构造方法中添加一个新的参数，int ViewType,然后判断。     MyViewHolder(View itemView,int viewType) {         super(itemView);         //如果是normalView那么给textView(就是item的内容)赋值。         if (viewType == NORMAL_VIEW) {             textView = itemView.findViewById(R.id.textView);         //如果是footView那么给footView赋值。         } else if (viewType == FOOT_VIEW) {             footView = (RelativeLayout) itemView;         }     } }</code></pre></li><li><p>修改getItemCount方法</p><pre><code> //因为我们多加了一个footView，所以这个地方+1. @Override public int getItemCount() {     return list.size() + 1; }</code></pre></li><li><p>修改onCreate方法：</p></li></ol><p>两种不同的viewType，判断一下，返回的MyViewHolder都是不一样的。</p><pre><code>    @Override    public MyViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {        if (viewType == NORMAL_VIEW) {            View itemView = LayoutInflater.from(context).inflate(R.layout.rv_item, parent, false);            return new MyViewHolder(itemView, viewType);        } else {            View footView = LayoutInflater.from(context).inflate(R.layout.foot_view, parent, false);            return new MyViewHolder(footView, viewType);        }    }</code></pre><ol start="4"><li><p>修改onBind方法：<br>简单干脆，加一个if判断完事，不是normalView的话还去bind数据干啥捏？</p><pre><code> @Override public void onBindViewHolder(final MyViewHolder holder, int position) {     if (getItemViewType(position) == NORMAL_VIEW) {         holder.textView.setText(list.get(position));     } }</code></pre><p>好的到了这里就结束了，但是我们有footView来干嘛？就是制造一个上拉加载的效果，制造一个加载中ing的view，下面来改进一下。一点点简单的代码就OK了。</p><pre><code>RecyclerView rv;rv= (RecyclerView) findViewById(R.id.rv);//添加滑动监听。rv.addOnScrollListener(new RecyclerView.OnScrollListener() {         //这个int用来记录最后一个可见的view         int lastVisibleItemPosition;         @Override         public void onScrollStateChanged(RecyclerView recyclerView, int newState) {             super.onScrollStateChanged(recyclerView, newState);             if (newState==RecyclerView.SCROLL_STATE_IDLE&amp;&amp;lastVisibleItemPosition+1==adapter.getItemCount()){                 list.add(String.valueOf(adapter.getItemCount()));                 list.add(String.valueOf(adapter.getItemCount()));                 //要在UI线程中更新，用一个Handler。                 new Handler().postDelayed(new Runnable() {                     @Override                     public void run() {                         adapter.notifyItemRangeInserted(adapter.getItemCount()-1,adapter.getItemCount());                     }                 },1000);             }         }         @Override         public void onScrolled(RecyclerView recyclerView, int dx, int dy) {             super.onScrolled(recyclerView, dx, dy);             //这个llm是LinearLayoutManager的一个实例。             lastVisibleItemPosition=llm.findLastVisibleItemPosition();         }     });</code></pre></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/7177220-d142876e603dbd90.gif?imageMogr2/auto-orient/strip" srcset="/img/loading.gif" alt="么么哒😙"><br></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
